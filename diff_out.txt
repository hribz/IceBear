Only in /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/: cg_plugin.json
Only in /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv: build
Only in /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv: build_0
diff -r -u0 /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/system.cpp.ii /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/system.cpp.ii
--- /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/system.cpp.ii	2024-07-24 11:49:09.434928967 +0800
+++ /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/system.cpp.ii	2024-07-24 11:49:31.494956032 +0800
@@ -66741 +66741 @@
-"    Timestamp:                   2024-07-23T13:15:36Z\n"
+"    Timestamp:                   2024-07-23T13:16:50Z\n"
@@ -66773 +66773 @@
-"    Extra dependencies:          dl m pthread rt\n"
+"    Extra dependencies:          dl m pthread rt /usr/lib/x86_64-linux-gnu/libClpSolver.so /usr/lib/x86_64-linux-gnu/libClp.so /usr/lib/x86_64-linux-gnu/libCoinUtils.so /usr/lib/x86_64-linux-gnu/libbz2.so /usr/lib/x86_64-linux-gnu/libz.so /usr/lib/x86_64-linux-gnu/liblapack.so /usr/lib/x86_64-linux-gnu/libblas.so /usr/lib/x86_64-linux-gnu/libm.so\n"
@@ -66819 +66819 @@
-"           at:                   /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/3rdparty/ippicv/ippicv_lnx/icv\n"
+"           at:                   /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/3rdparty/ippicv/ippicv_lnx/icv\n"
@@ -66821 +66821 @@
-"              at:                /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/3rdparty/ippicv/ippicv_lnx/iw\n"
+"              at:                /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/3rdparty/ippicv/ippicv_lnx/iw\n"
diff -r -u0 /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/utils/datafile.cpp.ii /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/utils/datafile.cpp.ii
--- /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/utils/datafile.cpp.ii	2024-07-24 11:49:09.544928968 +0800
+++ /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/core/src/utils/datafile.cpp.ii	2024-07-24 11:49:31.554956192 +0800
@@ -62824 +62824 @@
-    cv::String build_dir("/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build");
+    cv::String build_dir("/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0");
diff -r -u0 /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp.ii /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp.ii
--- /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp.ii	2024-07-24 11:49:25.864942510 +0800
+++ /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp.ii	2024-07-24 11:49:45.784959782 +0800
@@ -58777,0 +58778,11529 @@
+typedef int CoinBigIndex;
+typedef double CoinWorkDouble;
+typedef double CoinFactorizationDouble;
+
+void WindowsErrorPopupBlocker();
+class CoinError {
+  friend void CoinErrorUnitTest();
+private:
+  CoinError()
+    : message_()
+    , method_()
+    , class_()
+    , file_()
+    , lineNumber_()
+  {
+  }
+public:
+  inline const std::string &message() const
+  {
+    return message_;
+  }
+  inline const std::string &methodName() const
+  {
+    return method_;
+  }
+  inline const std::string &className() const
+  {
+    return class_;
+  }
+  inline const std::string &fileName() const
+  {
+    return file_;
+  }
+  inline int lineNumber() const
+  {
+    return lineNumber_;
+  }
+  inline void print(bool doPrint = true) const
+  {
+    if (!doPrint)
+      return;
+    if (lineNumber_ < 0) {
+      std::cout << message_ << " in " << class_ << "::" << method_ << std::endl;
+    } else {
+      std::cout << file_ << ":" << lineNumber_ << " method " << method_
+                << " : assertion \'" << message_ << "\' failed." << std::endl;
+      if (class_ != "")
+        std::cout << "Possible reason: " << class_ << std::endl;
+    }
+  }
+  CoinError(
+    std::string message__,
+    std::string methodName__,
+    std::string className__,
+    std::string fileName_ = std::string(),
+    int line = -1)
+    : message_(message__)
+    , method_(methodName__)
+    , class_(className__)
+    , file_(fileName_)
+    , lineNumber_(line)
+  {
+    print(printErrors_);
+  }
+  CoinError(const CoinError &source)
+    : message_(source.message_)
+    , method_(source.method_)
+    , class_(source.class_)
+    , file_(source.file_)
+    , lineNumber_(source.lineNumber_)
+  {
+  }
+  CoinError &operator=(const CoinError &rhs)
+  {
+    if (this != &rhs) {
+      message_ = rhs.message_;
+      method_ = rhs.method_;
+      class_ = rhs.class_;
+      file_ = rhs.file_;
+      lineNumber_ = rhs.lineNumber_;
+    }
+    return *this;
+  }
+  virtual ~CoinError()
+  {
+  }
+private:
+  std::string message_;
+  std::string method_;
+  std::string class_;
+  std::string file_;
+  int lineNumber_;
+public:
+  static bool printErrors_;
+};
+void CoinErrorUnitTest();
+
+namespace __gnu_cxx
+{
+  template<typename _Tp>
+    struct __aligned_membuf
+    {
+      struct _Tp2 { _Tp _M_t; };
+      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
+      __aligned_membuf() = default;
+      __aligned_membuf(std::nullptr_t) { }
+      void*
+      _M_addr() noexcept
+      { return static_cast<void*>(&_M_storage); }
+      const void*
+      _M_addr() const noexcept
+      { return static_cast<const void*>(&_M_storage); }
+      _Tp*
+      _M_ptr() noexcept
+      { return static_cast<_Tp*>(_M_addr()); }
+      const _Tp*
+      _M_ptr() const noexcept
+      { return static_cast<const _Tp*>(_M_addr()); }
+    };
+  template<typename _Tp>
+    struct __aligned_buffer
+    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
+    {
+      typename
+ std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
+      __aligned_buffer() = default;
+      __aligned_buffer(std::nullptr_t) { }
+      void*
+      _M_addr() noexcept
+      {
+        return static_cast<void*>(&_M_storage);
+      }
+      const void*
+      _M_addr() const noexcept
+      {
+        return static_cast<const void*>(&_M_storage);
+      }
+      _Tp*
+      _M_ptr() noexcept
+      { return static_cast<_Tp*>(_M_addr()); }
+      const _Tp*
+      _M_ptr() const noexcept
+      { return static_cast<const _Tp*>(_M_addr()); }
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  enum _Rb_tree_color { _S_red = false, _S_black = true };
+  struct _Rb_tree_node_base
+  {
+    typedef _Rb_tree_node_base* _Base_ptr;
+    typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    _Rb_tree_color _M_color;
+    _Base_ptr _M_parent;
+    _Base_ptr _M_left;
+    _Base_ptr _M_right;
+    static _Base_ptr
+    _S_minimum(_Base_ptr __x) noexcept
+    {
+      while (__x->_M_left != 0) __x = __x->_M_left;
+      return __x;
+    }
+    static _Const_Base_ptr
+    _S_minimum(_Const_Base_ptr __x) noexcept
+    {
+      while (__x->_M_left != 0) __x = __x->_M_left;
+      return __x;
+    }
+    static _Base_ptr
+    _S_maximum(_Base_ptr __x) noexcept
+    {
+      while (__x->_M_right != 0) __x = __x->_M_right;
+      return __x;
+    }
+    static _Const_Base_ptr
+    _S_maximum(_Const_Base_ptr __x) noexcept
+    {
+      while (__x->_M_right != 0) __x = __x->_M_right;
+      return __x;
+    }
+  };
+  template<typename _Key_compare>
+    struct _Rb_tree_key_compare
+    {
+      _Key_compare _M_key_compare;
+      _Rb_tree_key_compare()
+      noexcept(is_nothrow_default_constructible<_Key_compare>::value)
+      : _M_key_compare()
+      { }
+      _Rb_tree_key_compare(const _Key_compare& __comp)
+      : _M_key_compare(__comp)
+      { }
+      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;
+      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
+ noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
+      : _M_key_compare(__x._M_key_compare)
+      { }
+    };
+  struct _Rb_tree_header
+  {
+    _Rb_tree_node_base _M_header;
+    size_t _M_node_count;
+    _Rb_tree_header() noexcept
+    {
+      _M_header._M_color = _S_red;
+      _M_reset();
+    }
+    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
+    {
+      if (__x._M_header._M_parent != nullptr)
+ _M_move_data(__x);
+      else
+ {
+   _M_header._M_color = _S_red;
+   _M_reset();
+ }
+    }
+    void
+    _M_move_data(_Rb_tree_header& __from)
+    {
+      _M_header._M_color = __from._M_header._M_color;
+      _M_header._M_parent = __from._M_header._M_parent;
+      _M_header._M_left = __from._M_header._M_left;
+      _M_header._M_right = __from._M_header._M_right;
+      _M_header._M_parent->_M_parent = &_M_header;
+      _M_node_count = __from._M_node_count;
+      __from._M_reset();
+    }
+    void
+    _M_reset()
+    {
+      _M_header._M_parent = 0;
+      _M_header._M_left = &_M_header;
+      _M_header._M_right = &_M_header;
+      _M_node_count = 0;
+    }
+  };
+  template<typename _Val>
+    struct _Rb_tree_node : public _Rb_tree_node_base
+    {
+      typedef _Rb_tree_node<_Val>* _Link_type;
+      __gnu_cxx::__aligned_membuf<_Val> _M_storage;
+      _Val*
+      _M_valptr()
+      { return _M_storage._M_ptr(); }
+      const _Val*
+      _M_valptr() const
+      { return _M_storage._M_ptr(); }
+    };
+  __attribute__ ((__pure__)) _Rb_tree_node_base*
+  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) const _Rb_tree_node_base*
+  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) _Rb_tree_node_base*
+  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) const _Rb_tree_node_base*
+  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
+  template<typename _Tp>
+    struct _Rb_tree_iterator
+    {
+      typedef _Tp value_type;
+      typedef _Tp& reference;
+      typedef _Tp* pointer;
+      typedef bidirectional_iterator_tag iterator_category;
+      typedef ptrdiff_t difference_type;
+      typedef _Rb_tree_iterator<_Tp> _Self;
+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
+      typedef _Rb_tree_node<_Tp>* _Link_type;
+      _Rb_tree_iterator() noexcept
+      : _M_node() { }
+      explicit
+      _Rb_tree_iterator(_Base_ptr __x) noexcept
+      : _M_node(__x) { }
+      reference
+      operator*() const noexcept
+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      pointer
+      operator->() const noexcept
+      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
+      _Self&
+      operator++() noexcept
+      {
+ _M_node = _Rb_tree_increment(_M_node);
+ return *this;
+      }
+      _Self
+      operator++(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_increment(_M_node);
+ return __tmp;
+      }
+      _Self&
+      operator--() noexcept
+      {
+ _M_node = _Rb_tree_decrement(_M_node);
+ return *this;
+      }
+      _Self
+      operator--(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_decrement(_M_node);
+ return __tmp;
+      }
+      friend bool
+      operator==(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node == __y._M_node; }
+      friend bool
+      operator!=(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node != __y._M_node; }
+      _Base_ptr _M_node;
+    };
+  template<typename _Tp>
+    struct _Rb_tree_const_iterator
+    {
+      typedef _Tp value_type;
+      typedef const _Tp& reference;
+      typedef const _Tp* pointer;
+      typedef _Rb_tree_iterator<_Tp> iterator;
+      typedef bidirectional_iterator_tag iterator_category;
+      typedef ptrdiff_t difference_type;
+      typedef _Rb_tree_const_iterator<_Tp> _Self;
+      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
+      typedef const _Rb_tree_node<_Tp>* _Link_type;
+      _Rb_tree_const_iterator() noexcept
+      : _M_node() { }
+      explicit
+      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
+      : _M_node(__x) { }
+      _Rb_tree_const_iterator(const iterator& __it) noexcept
+      : _M_node(__it._M_node) { }
+      iterator
+      _M_const_cast() const noexcept
+      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }
+      reference
+      operator*() const noexcept
+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      pointer
+      operator->() const noexcept
+      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      _Self&
+      operator++() noexcept
+      {
+ _M_node = _Rb_tree_increment(_M_node);
+ return *this;
+      }
+      _Self
+      operator++(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_increment(_M_node);
+ return __tmp;
+      }
+      _Self&
+      operator--() noexcept
+      {
+ _M_node = _Rb_tree_decrement(_M_node);
+ return *this;
+      }
+      _Self
+      operator--(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_decrement(_M_node);
+ return __tmp;
+      }
+      friend bool
+      operator==(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node == __y._M_node; }
+      friend bool
+      operator!=(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node != __y._M_node; }
+      _Base_ptr _M_node;
+    };
+  __attribute__((__nonnull__))
+  void
+  _Rb_tree_insert_and_rebalance(const bool __insert_left,
+    _Rb_tree_node_base* __x,
+    _Rb_tree_node_base* __p,
+    _Rb_tree_node_base& __header) throw ();
+  __attribute__((__nonnull__,__returns_nonnull__))
+  _Rb_tree_node_base*
+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
+          _Rb_tree_node_base& __header) throw ();
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc = allocator<_Val> >
+    class _Rb_tree
+    {
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
+      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
+    protected:
+      typedef _Rb_tree_node_base* _Base_ptr;
+      typedef const _Rb_tree_node_base* _Const_Base_ptr;
+      typedef _Rb_tree_node<_Val>* _Link_type;
+      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
+    private:
+      struct _Reuse_or_alloc_node
+      {
+ _Reuse_or_alloc_node(_Rb_tree& __t)
+ : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
+ {
+   if (_M_root)
+     {
+       _M_root->_M_parent = 0;
+       if (_M_nodes->_M_left)
+  _M_nodes = _M_nodes->_M_left;
+     }
+   else
+     _M_nodes = 0;
+ }
+ _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
+ ~_Reuse_or_alloc_node()
+ { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }
+ template<typename _Arg>
+   _Link_type
+   operator()(_Arg&& __arg)
+   {
+     _Link_type __node = static_cast<_Link_type>(_M_extract());
+     if (__node)
+       {
+  _M_t._M_destroy_node(__node);
+  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
+  return __node;
+       }
+     return _M_t._M_create_node(std::forward<_Arg>(__arg));
+   }
+      private:
+ _Base_ptr
+ _M_extract()
+ {
+   if (!_M_nodes)
+     return _M_nodes;
+   _Base_ptr __node = _M_nodes;
+   _M_nodes = _M_nodes->_M_parent;
+   if (_M_nodes)
+     {
+       if (_M_nodes->_M_right == __node)
+  {
+    _M_nodes->_M_right = 0;
+    if (_M_nodes->_M_left)
+      {
+        _M_nodes = _M_nodes->_M_left;
+        while (_M_nodes->_M_right)
+   _M_nodes = _M_nodes->_M_right;
+        if (_M_nodes->_M_left)
+   _M_nodes = _M_nodes->_M_left;
+      }
+  }
+       else
+  _M_nodes->_M_left = 0;
+     }
+   else
+     _M_root = 0;
+   return __node;
+ }
+ _Base_ptr _M_root;
+ _Base_ptr _M_nodes;
+ _Rb_tree& _M_t;
+      };
+      struct _Alloc_node
+      {
+ _Alloc_node(_Rb_tree& __t)
+ : _M_t(__t) { }
+ template<typename _Arg>
+   _Link_type
+   operator()(_Arg&& __arg) const
+   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }
+      private:
+ _Rb_tree& _M_t;
+      };
+    public:
+      typedef _Key key_type;
+      typedef _Val value_type;
+      typedef value_type* pointer;
+      typedef const value_type* const_pointer;
+      typedef value_type& reference;
+      typedef const value_type& const_reference;
+      typedef size_t size_type;
+      typedef ptrdiff_t difference_type;
+      typedef _Alloc allocator_type;
+      _Node_allocator&
+      _M_get_Node_allocator() noexcept
+      { return this->_M_impl; }
+      const _Node_allocator&
+      _M_get_Node_allocator() const noexcept
+      { return this->_M_impl; }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_get_Node_allocator()); }
+    protected:
+      _Link_type
+      _M_get_node()
+      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
+      void
+      _M_put_node(_Link_type __p) noexcept
+      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
+      template<typename... _Args>
+ void
+ _M_construct_node(_Link_type __node, _Args&&... __args)
+ {
+   try
+     {
+       ::new(__node) _Rb_tree_node<_Val>;
+       _Alloc_traits::construct(_M_get_Node_allocator(),
+           __node->_M_valptr(),
+           std::forward<_Args>(__args)...);
+     }
+   catch(...)
+     {
+       __node->~_Rb_tree_node<_Val>();
+       _M_put_node(__node);
+       throw;
+     }
+ }
+      template<typename... _Args>
+ _Link_type
+ _M_create_node(_Args&&... __args)
+ {
+   _Link_type __tmp = _M_get_node();
+   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
+   return __tmp;
+ }
+      void
+      _M_destroy_node(_Link_type __p) noexcept
+      {
+ _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
+ __p->~_Rb_tree_node<_Val>();
+      }
+      void
+      _M_drop_node(_Link_type __p) noexcept
+      {
+ _M_destroy_node(__p);
+ _M_put_node(__p);
+      }
+      template<bool _MoveValue, typename _NodeGen>
+ _Link_type
+ _M_clone_node(_Link_type __x, _NodeGen& __node_gen)
+ {
+   using _Vp = __conditional_t<_MoveValue,
+          value_type&&,
+          const value_type&>;
+   _Link_type __tmp
+     = __node_gen(std::forward<_Vp>(*__x->_M_valptr()));
+   __tmp->_M_color = __x->_M_color;
+   __tmp->_M_left = 0;
+   __tmp->_M_right = 0;
+   return __tmp;
+ }
+    protected:
+      template<typename _Key_compare,
+        bool = __is_pod(_Key_compare)>
+ struct _Rb_tree_impl
+ : public _Node_allocator
+ , public _Rb_tree_key_compare<_Key_compare>
+ , public _Rb_tree_header
+ {
+   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;
+   _Rb_tree_impl()
+     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)
+   : _Node_allocator()
+   { }
+   _Rb_tree_impl(const _Rb_tree_impl& __x)
+   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
+   , _Base_key_compare(__x._M_key_compare)
+   , _Rb_tree_header()
+   { }
+   _Rb_tree_impl(_Rb_tree_impl&&)
+     noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+   = default;
+   explicit
+   _Rb_tree_impl(_Node_allocator&& __a)
+   : _Node_allocator(std::move(__a))
+   { }
+   _Rb_tree_impl(_Rb_tree_impl&& __x, _Node_allocator&& __a)
+   : _Node_allocator(std::move(__a)),
+     _Base_key_compare(std::move(__x)),
+     _Rb_tree_header(std::move(__x))
+   { }
+   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
+   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
+   { }
+ };
+      _Rb_tree_impl<_Compare> _M_impl;
+    protected:
+      _Base_ptr&
+      _M_root() noexcept
+      { return this->_M_impl._M_header._M_parent; }
+      _Const_Base_ptr
+      _M_root() const noexcept
+      { return this->_M_impl._M_header._M_parent; }
+      _Base_ptr&
+      _M_leftmost() noexcept
+      { return this->_M_impl._M_header._M_left; }
+      _Const_Base_ptr
+      _M_leftmost() const noexcept
+      { return this->_M_impl._M_header._M_left; }
+      _Base_ptr&
+      _M_rightmost() noexcept
+      { return this->_M_impl._M_header._M_right; }
+      _Const_Base_ptr
+      _M_rightmost() const noexcept
+      { return this->_M_impl._M_header._M_right; }
+      _Link_type
+      _M_mbegin() const noexcept
+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
+      _Link_type
+      _M_begin() noexcept
+      { return _M_mbegin(); }
+      _Const_Link_type
+      _M_begin() const noexcept
+      {
+ return static_cast<_Const_Link_type>
+   (this->_M_impl._M_header._M_parent);
+      }
+      _Base_ptr
+      _M_end() noexcept
+      { return &this->_M_impl._M_header; }
+      _Const_Base_ptr
+      _M_end() const noexcept
+      { return &this->_M_impl._M_header; }
+      static const _Key&
+      _S_key(_Const_Link_type __x)
+      {
+ static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
+        "comparison object must be invocable "
+        "with two arguments of key type");
+ return _KeyOfValue()(*__x->_M_valptr());
+      }
+      static _Link_type
+      _S_left(_Base_ptr __x) noexcept
+      { return static_cast<_Link_type>(__x->_M_left); }
+      static _Const_Link_type
+      _S_left(_Const_Base_ptr __x) noexcept
+      { return static_cast<_Const_Link_type>(__x->_M_left); }
+      static _Link_type
+      _S_right(_Base_ptr __x) noexcept
+      { return static_cast<_Link_type>(__x->_M_right); }
+      static _Const_Link_type
+      _S_right(_Const_Base_ptr __x) noexcept
+      { return static_cast<_Const_Link_type>(__x->_M_right); }
+      static const _Key&
+      _S_key(_Const_Base_ptr __x)
+      { return _S_key(static_cast<_Const_Link_type>(__x)); }
+      static _Base_ptr
+      _S_minimum(_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_minimum(__x); }
+      static _Const_Base_ptr
+      _S_minimum(_Const_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_minimum(__x); }
+      static _Base_ptr
+      _S_maximum(_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_maximum(__x); }
+      static _Const_Base_ptr
+      _S_maximum(_Const_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_maximum(__x); }
+    public:
+      typedef _Rb_tree_iterator<value_type> iterator;
+      typedef _Rb_tree_const_iterator<value_type> const_iterator;
+      typedef std::reverse_iterator<iterator> reverse_iterator;
+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_unique_pos(const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_equal_pos(const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_hint_unique_pos(const_iterator __pos,
+        const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_hint_equal_pos(const_iterator __pos,
+       const key_type& __k);
+    private:
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);
+      iterator
+      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
+      template<typename _Arg>
+ iterator
+ _M_insert_lower(_Base_ptr __y, _Arg&& __v);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal_lower(_Arg&& __x);
+      iterator
+      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
+      iterator
+      _M_insert_equal_lower_node(_Link_type __z);
+      enum { __as_lvalue, __as_rvalue };
+      template<bool _MoveValues, typename _NodeGen>
+ _Link_type
+ _M_copy(_Link_type, _Base_ptr, _NodeGen&);
+      template<bool _MoveValues, typename _NodeGen>
+ _Link_type
+ _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
+ {
+   _Link_type __root =
+     _M_copy<_MoveValues>(__x._M_mbegin(), _M_end(), __gen);
+   _M_leftmost() = _S_minimum(__root);
+   _M_rightmost() = _S_maximum(__root);
+   _M_impl._M_node_count = __x._M_impl._M_node_count;
+   return __root;
+ }
+      _Link_type
+      _M_copy(const _Rb_tree& __x)
+      {
+ _Alloc_node __an(*this);
+ return _M_copy<__as_lvalue>(__x, __an);
+      }
+      void
+      _M_erase(_Link_type __x);
+      iterator
+      _M_lower_bound(_Link_type __x, _Base_ptr __y,
+       const _Key& __k);
+      const_iterator
+      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+       const _Key& __k) const;
+      iterator
+      _M_upper_bound(_Link_type __x, _Base_ptr __y,
+       const _Key& __k);
+      const_iterator
+      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+       const _Key& __k) const;
+    public:
+      _Rb_tree() = default;
+      _Rb_tree(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_impl(__comp, _Node_allocator(__a)) { }
+      _Rb_tree(const _Rb_tree& __x)
+      : _M_impl(__x._M_impl)
+      {
+ if (__x._M_root() != 0)
+   _M_root() = _M_copy(__x);
+      }
+      _Rb_tree(const allocator_type& __a)
+      : _M_impl(_Node_allocator(__a))
+      { }
+      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
+      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
+      {
+ if (__x._M_root() != nullptr)
+   _M_root() = _M_copy(__x);
+      }
+      _Rb_tree(_Rb_tree&&) = default;
+      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
+      : _Rb_tree(std::move(__x), _Node_allocator(__a))
+      { }
+    private:
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, true_type)
+      noexcept(is_nothrow_default_constructible<_Compare>::value)
+      : _M_impl(std::move(__x._M_impl), std::move(__a))
+      { }
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, false_type)
+      : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
+      {
+ if (__x._M_root() != nullptr)
+   _M_move_data(__x, false_type{});
+      }
+    public:
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
+      noexcept( noexcept(
+ _Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
+   std::declval<typename _Alloc_traits::is_always_equal>())) )
+      : _Rb_tree(std::move(__x), std::move(__a),
+   typename _Alloc_traits::is_always_equal{})
+      { }
+      ~_Rb_tree() noexcept
+      { _M_erase(_M_begin()); }
+      _Rb_tree&
+      operator=(const _Rb_tree& __x);
+      _Compare
+      key_comp() const
+      { return _M_impl._M_key_compare; }
+      iterator
+      begin() noexcept
+      { return iterator(this->_M_impl._M_header._M_left); }
+      const_iterator
+      begin() const noexcept
+      { return const_iterator(this->_M_impl._M_header._M_left); }
+      iterator
+      end() noexcept
+      { return iterator(&this->_M_impl._M_header); }
+      const_iterator
+      end() const noexcept
+      { return const_iterator(&this->_M_impl._M_header); }
+      reverse_iterator
+      rbegin() noexcept
+      { return reverse_iterator(end()); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return const_reverse_iterator(end()); }
+      reverse_iterator
+      rend() noexcept
+      { return reverse_iterator(begin()); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return const_reverse_iterator(begin()); }
+                         bool
+      empty() const noexcept
+      { return _M_impl._M_node_count == 0; }
+      size_type
+      size() const noexcept
+      { return _M_impl._M_node_count; }
+      size_type
+      max_size() const noexcept
+      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
+      void
+      swap(_Rb_tree& __t)
+      noexcept(__is_nothrow_swappable<_Compare>::value);
+      template<typename _Arg>
+ pair<iterator, bool>
+ _M_insert_unique(_Arg&& __x);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal(_Arg&& __x);
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);
+      template<typename _Arg>
+ iterator
+ _M_insert_unique_(const_iterator __pos, _Arg&& __x)
+ {
+   _Alloc_node __an(*this);
+   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
+ }
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal_(const_iterator __pos, _Arg&& __x)
+ {
+   _Alloc_node __an(*this);
+   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
+ }
+      template<typename... _Args>
+ pair<iterator, bool>
+ _M_emplace_unique(_Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_equal(_Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
+      template<typename _Iter>
+ using __same_value_type
+   = is_same<value_type, typename iterator_traits<_Iter>::value_type>;
+      template<typename _InputIterator>
+ __enable_if_t<__same_value_type<_InputIterator>::value>
+ _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_insert_unique_(end(), *__first, __an);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<!__same_value_type<_InputIterator>::value>
+ _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
+ {
+   for (; __first != __last; ++__first)
+     _M_emplace_unique(*__first);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<__same_value_type<_InputIterator>::value>
+ _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_insert_equal_(end(), *__first, __an);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<!__same_value_type<_InputIterator>::value>
+ _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_emplace_equal(*__first);
+ }
+    private:
+      void
+      _M_erase_aux(const_iterator __position);
+      void
+      _M_erase_aux(const_iterator __first, const_iterator __last);
+    public:
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      {
+ do { if (std::__is_constant_evaluated() && !bool(__position != end())) __builtin_unreachable(); } while (false);
+ const_iterator __result = __position;
+ ++__result;
+ _M_erase_aux(__position);
+ return __result._M_const_cast();
+      }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      {
+ do { if (std::__is_constant_evaluated() && !bool(__position != end())) __builtin_unreachable(); } while (false);
+ iterator __result = __position;
+ ++__result;
+ _M_erase_aux(__position);
+ return __result;
+      }
+      size_type
+      erase(const key_type& __x);
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      {
+ _M_erase_aux(__first, __last);
+ return __last._M_const_cast();
+      }
+      void
+      clear() noexcept
+      {
+ _M_erase(_M_begin());
+ _M_impl._M_reset();
+      }
+      iterator
+      find(const key_type& __k);
+      const_iterator
+      find(const key_type& __k) const;
+      size_type
+      count(const key_type& __k) const;
+      iterator
+      lower_bound(const key_type& __k)
+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
+      const_iterator
+      lower_bound(const key_type& __k) const
+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
+      iterator
+      upper_bound(const key_type& __k)
+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
+      const_iterator
+      upper_bound(const key_type& __k) const
+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
+      pair<iterator, iterator>
+      equal_range(const key_type& __k);
+      pair<const_iterator, const_iterator>
+      equal_range(const key_type& __k) const;
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_find_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_find_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_find_tr(const _Kt& __k) const
+ {
+   auto __j = _M_lower_bound_tr(__k);
+   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
+     __j = end();
+   return __j;
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ size_type
+ _M_count_tr(const _Kt& __k) const
+ {
+   auto __p = _M_equal_range_tr(__k);
+   return std::distance(__p.first, __p.second);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_lower_bound_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_lower_bound_tr(const _Kt& __k) const
+ {
+   auto __x = _M_begin();
+   auto __y = _M_end();
+   while (__x != 0)
+     if (!_M_impl._M_key_compare(_S_key(__x), __k))
+       {
+  __y = __x;
+  __x = _S_left(__x);
+       }
+     else
+       __x = _S_right(__x);
+   return const_iterator(__y);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_upper_bound_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_upper_bound_tr(const _Kt& __k) const
+ {
+   auto __x = _M_begin();
+   auto __y = _M_end();
+   while (__x != 0)
+     if (_M_impl._M_key_compare(__k, _S_key(__x)))
+       {
+  __y = __x;
+  __x = _S_left(__x);
+       }
+     else
+       __x = _S_right(__x);
+   return const_iterator(__y);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ pair<iterator, iterator>
+ _M_equal_range_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   auto __ret = __const_this->_M_equal_range_tr(__k);
+   return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ pair<const_iterator, const_iterator>
+ _M_equal_range_tr(const _Kt& __k) const
+ {
+   auto __low = _M_lower_bound_tr(__k);
+   auto __high = __low;
+   auto& __cmp = _M_impl._M_key_compare;
+   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
+     ++__high;
+   return { __low, __high };
+ }
+      bool
+      __rb_verify() const;
+      _Rb_tree&
+      operator=(_Rb_tree&&)
+      noexcept(_Alloc_traits::_S_nothrow_move()
+        && is_nothrow_move_assignable<_Compare>::value);
+      template<typename _Iterator>
+ void
+ _M_assign_unique(_Iterator, _Iterator);
+      template<typename _Iterator>
+ void
+ _M_assign_equal(_Iterator, _Iterator);
+    private:
+      void
+      _M_move_data(_Rb_tree& __x, true_type)
+      { _M_impl._M_move_data(__x._M_impl); }
+      void
+      _M_move_data(_Rb_tree&, false_type);
+      void
+      _M_move_assign(_Rb_tree&, true_type);
+      void
+      _M_move_assign(_Rb_tree&, false_type);
+      friend bool
+      operator==(const _Rb_tree& __x, const _Rb_tree& __y)
+      {
+ return __x.size() == __y.size()
+   && std::equal(__x.begin(), __x.end(), __y.begin());
+      }
+      friend bool
+      operator<(const _Rb_tree& __x, const _Rb_tree& __y)
+      {
+ return std::lexicographical_compare(__x.begin(), __x.end(),
+         __y.begin(), __y.end());
+      }
+    private:
+      struct _Auto_node
+      {
+ template<typename... _Args>
+   _Auto_node(_Rb_tree& __t, _Args&&... __args)
+   : _M_t(__t),
+     _M_node(__t._M_create_node(std::forward<_Args>(__args)...))
+   { }
+ ~_Auto_node()
+ {
+   if (_M_node)
+     _M_t._M_drop_node(_M_node);
+ }
+ _Auto_node(_Auto_node&& __n)
+ : _M_t(__n._M_t), _M_node(__n._M_node)
+ { __n._M_node = nullptr; }
+ const _Key&
+ _M_key() const
+ { return _S_key(_M_node); }
+ iterator
+ _M_insert(pair<_Base_ptr, _Base_ptr> __p)
+ {
+   auto __it = _M_t._M_insert_node(__p.first, __p.second, _M_node);
+   _M_node = nullptr;
+   return __it;
+ }
+ iterator
+ _M_insert_equal_lower()
+ {
+   auto __it = _M_t._M_insert_equal_lower_node(_M_node);
+   _M_node = nullptr;
+   return __it;
+ }
+ _Rb_tree& _M_t;
+ _Link_type _M_node;
+      };
+    };
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline void
+    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
+  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
+    { __x.swap(__y); }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_data(_Rb_tree& __x, false_type)
+    {
+      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
+ _M_move_data(__x, true_type());
+      else
+ {
+   constexpr bool __move = !__move_if_noexcept_cond<value_type>::value;
+   _Alloc_node __an(*this);
+   _M_root() = _M_copy<__move>(__x, __an);
+   if (__move)
+     __x.clear();
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_assign(_Rb_tree& __x, true_type)
+    {
+      clear();
+      if (__x._M_root() != nullptr)
+ _M_move_data(__x, true_type());
+      std::__alloc_on_move(_M_get_Node_allocator(),
+      __x._M_get_Node_allocator());
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_assign(_Rb_tree& __x, false_type)
+    {
+      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
+ return _M_move_assign(__x, true_type{});
+      _Reuse_or_alloc_node __roan(*this);
+      _M_impl._M_reset();
+      if (__x._M_root() != nullptr)
+ {
+   _M_root() = _M_copy<__as_rvalue>(__x, __roan);
+   __x.clear();
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    operator=(_Rb_tree&& __x)
+    noexcept(_Alloc_traits::_S_nothrow_move()
+      && is_nothrow_move_assignable<_Compare>::value)
+    {
+      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
+      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
+      return *this;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Iterator>
+      void
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_assign_unique(_Iterator __first, _Iterator __last)
+      {
+ _Reuse_or_alloc_node __roan(*this);
+ _M_impl._M_reset();
+ for (; __first != __last; ++__first)
+   _M_insert_unique_(end(), *__first, __roan);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Iterator>
+      void
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_assign_equal(_Iterator __first, _Iterator __last)
+      {
+ _Reuse_or_alloc_node __roan(*this);
+ _M_impl._M_reset();
+ for (; __first != __last; ++__first)
+   _M_insert_equal_(end(), *__first, __roan);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    operator=(const _Rb_tree& __x)
+    {
+      if (this != std::__addressof(__x))
+ {
+   if (_Alloc_traits::_S_propagate_on_copy_assign())
+     {
+       auto& __this_alloc = this->_M_get_Node_allocator();
+       auto& __that_alloc = __x._M_get_Node_allocator();
+       if (!_Alloc_traits::_S_always_equal()
+    && __this_alloc != __that_alloc)
+  {
+    clear();
+    std::__alloc_on_copy(__this_alloc, __that_alloc);
+  }
+     }
+   _Reuse_or_alloc_node __roan(*this);
+   _M_impl._M_reset();
+   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
+   if (__x._M_root() != 0)
+     _M_root() = _M_copy<__as_lvalue>(__x, __roan);
+ }
+      return *this;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_(_Base_ptr __x, _Base_ptr __p,
+   _Arg&& __v,
+   _NodeGen& __node_gen)
+      {
+ bool __insert_left = (__x != 0 || __p == _M_end()
+         || _M_impl._M_key_compare(_KeyOfValue()(__v),
+       _S_key(__p)));
+ _Link_type __z = __node_gen(std::forward<_Arg>(__v));
+ _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+          this->_M_impl._M_header);
+ ++_M_impl._M_node_count;
+ return iterator(__z);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
+    {
+      bool __insert_left = (__p == _M_end()
+       || !_M_impl._M_key_compare(_S_key(__p),
+             _KeyOfValue()(__v)));
+      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal_lower(_Arg&& __v)
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _M_insert_lower(__y, std::forward<_Arg>(__v));
+    }
+  template<typename _Key, typename _Val, typename _KoV,
+    typename _Compare, typename _Alloc>
+    template<bool _MoveValues, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
+      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
+      _M_copy(_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
+      {
+ _Link_type __top = _M_clone_node<_MoveValues>(__x, __node_gen);
+ __top->_M_parent = __p;
+ try
+   {
+     if (__x->_M_right)
+       __top->_M_right =
+  _M_copy<_MoveValues>(_S_right(__x), __top, __node_gen);
+     __p = __top;
+     __x = _S_left(__x);
+     while (__x != 0)
+       {
+  _Link_type __y = _M_clone_node<_MoveValues>(__x, __node_gen);
+  __p->_M_left = __y;
+  __y->_M_parent = __p;
+  if (__x->_M_right)
+    __y->_M_right = _M_copy<_MoveValues>(_S_right(__x),
+             __y, __node_gen);
+  __p = __y;
+  __x = _S_left(__x);
+       }
+   }
+ catch(...)
+   {
+     _M_erase(__top);
+     throw;
+   }
+ return __top;
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase(_Link_type __x)
+    {
+      while (__x != 0)
+ {
+   _M_erase(_S_right(__x));
+   _Link_type __y = _S_left(__x);
+   _M_drop_node(__x);
+   __x = __y;
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_lower_bound(_Link_type __x, _Base_ptr __y,
+     const _Key& __k)
+    {
+      while (__x != 0)
+ if (!_M_impl._M_key_compare(_S_key(__x), __k))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+     const _Key& __k) const
+    {
+      while (__x != 0)
+ if (!_M_impl._M_key_compare(_S_key(__x), __k))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return const_iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_upper_bound(_Link_type __x, _Base_ptr __y,
+     const _Key& __k)
+    {
+      while (__x != 0)
+ if (_M_impl._M_key_compare(__k, _S_key(__x)))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+     const _Key& __k) const
+    {
+      while (__x != 0)
+ if (_M_impl._M_key_compare(__k, _S_key(__x)))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return const_iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    equal_range(const _Key& __k)
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   if (_M_impl._M_key_compare(_S_key(__x), __k))
+     __x = _S_right(__x);
+   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
+     __y = __x, __x = _S_left(__x);
+   else
+     {
+       _Link_type __xu(__x);
+       _Base_ptr __yu(__y);
+       __y = __x, __x = _S_left(__x);
+       __xu = _S_right(__xu);
+       return pair<iterator,
+     iterator>(_M_lower_bound(__x, __y, __k),
+        _M_upper_bound(__xu, __yu, __k));
+     }
+ }
+      return pair<iterator, iterator>(iterator(__y),
+          iterator(__y));
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::const_iterator,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::const_iterator>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    equal_range(const _Key& __k) const
+    {
+      _Const_Link_type __x = _M_begin();
+      _Const_Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   if (_M_impl._M_key_compare(_S_key(__x), __k))
+     __x = _S_right(__x);
+   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
+     __y = __x, __x = _S_left(__x);
+   else
+     {
+       _Const_Link_type __xu(__x);
+       _Const_Base_ptr __yu(__y);
+       __y = __x, __x = _S_left(__x);
+       __xu = _S_right(__xu);
+       return pair<const_iterator,
+     const_iterator>(_M_lower_bound(__x, __y, __k),
+       _M_upper_bound(__xu, __yu, __k));
+     }
+ }
+      return pair<const_iterator, const_iterator>(const_iterator(__y),
+        const_iterator(__y));
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    swap(_Rb_tree& __t)
+    noexcept(__is_nothrow_swappable<_Compare>::value)
+    {
+      if (_M_root() == 0)
+ {
+   if (__t._M_root() != 0)
+     _M_impl._M_move_data(__t._M_impl);
+ }
+      else if (__t._M_root() == 0)
+ __t._M_impl._M_move_data(_M_impl);
+      else
+ {
+   std::swap(_M_root(),__t._M_root());
+   std::swap(_M_leftmost(),__t._M_leftmost());
+   std::swap(_M_rightmost(),__t._M_rightmost());
+   _M_root()->_M_parent = _M_end();
+   __t._M_root()->_M_parent = __t._M_end();
+   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
+ }
+      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
+      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
+    __t._M_get_Node_allocator());
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_unique_pos(const key_type& __k)
+    {
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      bool __comp = true;
+      while (__x != 0)
+ {
+   __y = __x;
+   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
+   __x = __comp ? _S_left(__x) : _S_right(__x);
+ }
+      iterator __j = iterator(__y);
+      if (__comp)
+ {
+   if (__j == begin())
+     return _Res(__x, __y);
+   else
+     --__j;
+ }
+      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
+ return _Res(__x, __y);
+      return _Res(__j._M_node, 0);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_equal_pos(const key_type& __k)
+    {
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _Res(__x, __y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator, bool>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_unique(_Arg&& __v)
+    {
+      typedef pair<iterator, bool> _Res;
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_unique_pos(_KeyOfValue()(__v));
+      if (__res.second)
+ {
+   _Alloc_node __an(*this);
+   return _Res(_M_insert_(__res.first, __res.second,
+     std::forward<_Arg>(__v), __an),
+        true);
+ }
+      return _Res(iterator(__res.first), false);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal(_Arg&& __v)
+    {
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_equal_pos(_KeyOfValue()(__v));
+      _Alloc_node __an(*this);
+      return _M_insert_(__res.first, __res.second,
+   std::forward<_Arg>(__v), __an);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_hint_unique_pos(const_iterator __position,
+      const key_type& __k)
+    {
+      iterator __pos = __position._M_const_cast();
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      if (__pos._M_node == _M_end())
+ {
+   if (size() > 0
+       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
+     return _Res(0, _M_rightmost());
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
+ {
+   iterator __before = __pos;
+   if (__pos._M_node == _M_leftmost())
+     return _Res(_M_leftmost(), _M_leftmost());
+   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
+     {
+       if (_S_right(__before._M_node) == 0)
+  return _Res(0, __before._M_node);
+       else
+  return _Res(__pos._M_node, __pos._M_node);
+     }
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
+ {
+   iterator __after = __pos;
+   if (__pos._M_node == _M_rightmost())
+     return _Res(0, _M_rightmost());
+   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
+     {
+       if (_S_right(__pos._M_node) == 0)
+  return _Res(0, __pos._M_node);
+       else
+  return _Res(__after._M_node, __after._M_node);
+     }
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else
+ return _Res(__pos._M_node, 0);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_unique_(const_iterator __position,
+   _Arg&& __v,
+   _NodeGen& __node_gen)
+    {
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
+      if (__res.second)
+ return _M_insert_(__res.first, __res.second,
+     std::forward<_Arg>(__v),
+     __node_gen);
+      return iterator(__res.first);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
+    {
+      iterator __pos = __position._M_const_cast();
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      if (__pos._M_node == _M_end())
+ {
+   if (size() > 0
+       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
+     return _Res(0, _M_rightmost());
+   else
+     return _M_get_insert_equal_pos(__k);
+ }
+      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
+ {
+   iterator __before = __pos;
+   if (__pos._M_node == _M_leftmost())
+     return _Res(_M_leftmost(), _M_leftmost());
+   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
+     {
+       if (_S_right(__before._M_node) == 0)
+  return _Res(0, __before._M_node);
+       else
+  return _Res(__pos._M_node, __pos._M_node);
+     }
+   else
+     return _M_get_insert_equal_pos(__k);
+ }
+      else
+ {
+   iterator __after = __pos;
+   if (__pos._M_node == _M_rightmost())
+     return _Res(0, _M_rightmost());
+   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
+     {
+       if (_S_right(__pos._M_node) == 0)
+  return _Res(0, __pos._M_node);
+       else
+  return _Res(__after._M_node, __after._M_node);
+     }
+   else
+     return _Res(0, 0);
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_equal_(const_iterator __position,
+         _Arg&& __v,
+         _NodeGen& __node_gen)
+      {
+ pair<_Base_ptr, _Base_ptr> __res
+   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
+ if (__res.second)
+   return _M_insert_(__res.first, __res.second,
+       std::forward<_Arg>(__v),
+       __node_gen);
+ return _M_insert_equal_lower(std::forward<_Arg>(__v));
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
+    -> iterator
+    {
+      bool __insert_left = (__x != 0 || __p == _M_end()
+       || _M_impl._M_key_compare(_S_key(__z),
+            _S_key(__p)));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
+    -> iterator
+    {
+      bool __insert_left = (__p == _M_end()
+       || !_M_impl._M_key_compare(_S_key(__p),
+             _S_key(__z)));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal_lower_node(_Link_type __z)
+    -> iterator
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _M_insert_lower_node(__y, __z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_unique(_Args&&... __args)
+      -> pair<iterator, bool>
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_unique_pos(__z._M_key());
+ if (__res.second)
+   return {__z._M_insert(__res), true};
+ return {iterator(__res.first), false};
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_equal(_Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_equal_pos(__z._M_key());
+ return __z._M_insert(__res);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_hint_unique_pos(__pos, __z._M_key());
+ if (__res.second)
+   return __z._M_insert(__res);
+ return iterator(__res.first);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_hint_equal_pos(__pos, __z._M_key());
+ if (__res.second)
+   return __z._M_insert(__res);
+ return __z._M_insert_equal_lower();
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase_aux(const_iterator __position)
+    {
+      _Link_type __y =
+ static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
+    (const_cast<_Base_ptr>(__position._M_node),
+     this->_M_impl._M_header));
+      _M_drop_node(__y);
+      --_M_impl._M_node_count;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase_aux(const_iterator __first, const_iterator __last)
+    {
+      if (__first == begin() && __last == end())
+ clear();
+      else
+ while (__first != __last)
+   _M_erase_aux(__first++);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    erase(const _Key& __x)
+    {
+      pair<iterator, iterator> __p = equal_range(__x);
+      const size_type __old_size = size();
+      _M_erase_aux(__p.first, __p.second);
+      return __old_size - size();
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    find(const _Key& __k)
+    {
+      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
+      return (__j == end()
+       || _M_impl._M_key_compare(__k,
+     _S_key(__j._M_node))) ? end() : __j;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    find(const _Key& __k) const
+    {
+      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
+      return (__j == end()
+       || _M_impl._M_key_compare(__k,
+     _S_key(__j._M_node))) ? end() : __j;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    count(const _Key& __k) const
+    {
+      pair<const_iterator, const_iterator> __p = equal_range(__k);
+      const size_type __n = std::distance(__p.first, __p.second);
+      return __n;
+    }
+  __attribute__ ((__pure__)) unsigned int
+  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
+         const _Rb_tree_node_base* __root) throw ();
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    bool
+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
+    {
+      if (_M_impl._M_node_count == 0 || begin() == end())
+ return _M_impl._M_node_count == 0 && begin() == end()
+        && this->_M_impl._M_header._M_left == _M_end()
+        && this->_M_impl._M_header._M_right == _M_end();
+      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
+      for (const_iterator __it = begin(); __it != end(); ++__it)
+ {
+   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
+   _Const_Link_type __L = _S_left(__x);
+   _Const_Link_type __R = _S_right(__x);
+   if (__x->_M_color == _S_red)
+     if ((__L && __L->_M_color == _S_red)
+  || (__R && __R->_M_color == _S_red))
+       return false;
+   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
+     return false;
+   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
+     return false;
+   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
+     return false;
+ }
+      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
+ return false;
+      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
+ return false;
+      return true;
+    }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<typename _Key, typename _Compare, typename _Alloc>
+    class multiset;
+  template<typename _Key, typename _Compare = std::less<_Key>,
+    typename _Alloc = std::allocator<_Key> >
+    class set
+    {
+      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
+   "std::set must have a non-const, non-volatile value_type");
+    public:
+      typedef _Key key_type;
+      typedef _Key value_type;
+      typedef _Compare key_compare;
+      typedef _Compare value_compare;
+      typedef _Alloc allocator_type;
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Key>::other _Key_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
+         key_compare, _Key_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::const_iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      set() = default;
+      explicit
+      set(const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a)) { }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last,
+     const _Compare& __comp,
+     const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Key_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      set(const set&) = default;
+      set(set&&) = default;
+      set(initializer_list<value_type> __l,
+   const _Compare& __comp = _Compare(),
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      explicit
+      set(const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a)) { }
+      set(const set& __x, const __type_identity_t<allocator_type>& __a)
+      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }
+      set(set&& __x, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }
+      set(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last,
+     const allocator_type& __a)
+ : _M_t(_Key_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      ~set() = default;
+      set&
+      operator=(const set&) = default;
+      set&
+      operator=(set&&) = default;
+      set&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_unique(__l.begin(), __l.end());
+ return *this;
+      }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return _M_t.key_comp(); }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      void
+      swap(set& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      template<typename... _Args>
+ std::pair<iterator, bool>
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_unique(__pos,
+          std::forward<_Args>(__args)...);
+ }
+      std::pair<iterator, bool>
+      insert(const value_type& __x)
+      {
+ std::pair<typename _Rep_type::iterator, bool> __p =
+   _M_t._M_insert_unique(__x);
+ return std::pair<iterator, bool>(__p.first, __p.second);
+      }
+      std::pair<iterator, bool>
+      insert(value_type&& __x)
+      {
+ std::pair<typename _Rep_type::iterator, bool> __p =
+   _M_t._M_insert_unique(std::move(__x));
+ return std::pair<iterator, bool>(__p.first, __p.second);
+      }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_unique_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_unique(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const
+ -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x)
+ -> decltype(iterator{_M_t._M_find_tr(__x)})
+ { return iterator{_M_t._M_find_tr(__x)}; }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const
+ -> decltype(const_iterator{_M_t._M_find_tr(__x)})
+ { return const_iterator{_M_t._M_find_tr(__x)}; }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const set<_Key, _Compare, _Alloc>& __x,
+       const set<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const set<_Key, _Compare, _Alloc>& __x,
+       const set<_Key, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline void
+    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<typename _Key, typename _Compare, typename _Alloc>
+    class set;
+  template <typename _Key, typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<_Key> >
+    class multiset
+    {
+      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
+   "std::multiset must have a non-const, non-volatile value_type");
+    public:
+      typedef _Key key_type;
+      typedef _Key value_type;
+      typedef _Compare key_compare;
+      typedef _Compare value_compare;
+      typedef _Alloc allocator_type;
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Key>::other _Key_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
+         key_compare, _Key_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::const_iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      multiset() = default;
+      explicit
+      multiset(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a)) { }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last,
+   const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Key_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      multiset(const multiset&) = default;
+      multiset(multiset&&) = default;
+      multiset(initializer_list<value_type> __l,
+        const _Compare& __comp = _Compare(),
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      explicit
+      multiset(const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a)) { }
+      multiset(const multiset& __m,
+        const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }
+      multiset(multiset&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }
+      multiset(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last,
+   const allocator_type& __a)
+ : _M_t(_Key_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      ~multiset() = default;
+      multiset&
+      operator=(const multiset&) = default;
+      multiset&
+      operator=(multiset&&) = default;
+      multiset&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_equal(__l.begin(), __l.end());
+ return *this;
+      }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return _M_t.key_comp(); }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      void
+      swap(multiset& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      template<typename... _Args>
+ iterator
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_equal(__pos,
+         std::forward<_Args>(__args)...);
+ }
+      iterator
+      insert(const value_type& __x)
+      { return _M_t._M_insert_equal(__x); }
+      iterator
+      insert(value_type&& __x)
+      { return _M_t._M_insert_equal(std::move(__x)); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_equal_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_equal(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.count(__x); }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x)
+ -> decltype(iterator{_M_t._M_find_tr(__x)})
+ { return iterator{_M_t._M_find_tr(__x)}; }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const
+ -> decltype(const_iterator{_M_t._M_find_tr(__x)})
+ { return const_iterator{_M_t._M_find_tr(__x)}; }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator==(const multiset<_K1, _C1, _A1>&,
+     const multiset<_K1, _C1, _A1>&);
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator< (const multiset<_K1, _C1, _A1>&,
+     const multiset<_K1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
+       const multiset<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
+       const multiset<_Key,_Compare,_Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline void
+    swap(multiset<_Key, _Compare, _Alloc>& __x,
+  multiset<_Key, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+
+namespace std
+{
+  namespace __detail
+  {
+    template<typename _Container, typename _UnsafeContainer,
+      typename _Predicate>
+      typename _Container::size_type
+      __erase_nodes_if(_Container& __cont, _UnsafeContainer& __ucont,
+         _Predicate __pred)
+      {
+ typename _Container::size_type __num = 0;
+ for (auto __iter = __ucont.begin(), __last = __ucont.end();
+      __iter != __last;)
+   {
+     if (__pred(*__iter))
+       {
+  __iter = __cont.erase(__iter);
+  ++__num;
+       }
+     else
+       ++__iter;
+   }
+ return __num;
+      }
+  }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    class multimap;
+  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
+    class map
+    {
+    public:
+      typedef _Key key_type;
+      typedef _Tp mapped_type;
+      typedef std::pair<const _Key, _Tp> value_type;
+      typedef _Compare key_compare;
+      typedef _Alloc allocator_type;
+    private:
+    public:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+      class value_compare
+      : public std::binary_function<value_type, value_type, bool>
+      {
+ friend class map<_Key, _Tp, _Compare, _Alloc>;
+      protected:
+ _Compare comp;
+ value_compare(_Compare __c)
+ : comp(__c) { }
+      public:
+ bool operator()(const value_type& __x, const value_type& __y) const
+ { return comp(__x.first, __y.first); }
+      };
+#pragma GCC diagnostic pop
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<value_type>::other _Pair_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
+         key_compare, _Pair_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      typedef typename _Rep_type::reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      map() = default;
+      explicit
+      map(const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a)) { }
+      map(const map&) = default;
+      map(map&&) = default;
+      map(initializer_list<value_type> __l,
+   const _Compare& __comp = _Compare(),
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      explicit
+      map(const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a)) { }
+      map(const map& __m, const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }
+      map(map&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }
+      map(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last,
+     const allocator_type& __a)
+ : _M_t(_Pair_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last,
+     const _Compare& __comp,
+     const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Pair_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      ~map() = default;
+      map&
+      operator=(const map&) = default;
+      map&
+      operator=(map&&) = default;
+      map&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_unique(__l.begin(), __l.end());
+ return *this;
+      }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() noexcept
+      { return _M_t.end(); }
+      const_iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() noexcept
+      { return _M_t.rend(); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      const_iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      const_reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      mapped_type&
+      operator[](const key_type& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
+         std::tuple<const key_type&>(__k),
+         std::tuple<>());
+ return (*__i).second;
+      }
+      mapped_type&
+      operator[](key_type&& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
+     std::forward_as_tuple(std::move(__k)),
+     std::tuple<>());
+ return (*__i).second;
+      }
+      mapped_type&
+      at(const key_type& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __throw_out_of_range(("map::at"));
+ return (*__i).second;
+      }
+      const mapped_type&
+      at(const key_type& __k) const
+      {
+ const_iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __throw_out_of_range(("map::at"));
+ return (*__i).second;
+      }
+      template<typename... _Args>
+ std::pair<iterator, bool>
+ emplace(_Args&&... __args)
+ {
+   return _M_t._M_emplace_unique(std::forward<_Args>(__args)...);
+ }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_unique(__pos,
+          std::forward<_Args>(__args)...);
+ }
+      std::pair<iterator, bool>
+      insert(const value_type& __x)
+      { return _M_t._M_insert_unique(__x); }
+      std::pair<iterator, bool>
+      insert(value_type&& __x)
+      { return _M_t._M_insert_unique(std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value,
+        pair<iterator, bool>>
+ insert(_Pair&& __x)
+ {
+   return _M_t._M_emplace_unique(std::forward<_Pair>(__x));
+ }
+      void
+      insert(std::initializer_list<value_type> __list)
+      { insert(__list.begin(), __list.end()); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_unique_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
+ insert(const_iterator __position, _Pair&& __x)
+ {
+   return _M_t._M_emplace_hint_unique(__position,
+          std::forward<_Pair>(__x));
+ }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_unique(__first, __last); }
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      swap(map& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return value_compare(_M_t.key_comp()); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x)))
+ {
+   return pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x));
+ }
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator==(const map<_K1, _T1, _C1, _A1>&,
+     const map<_K1, _T1, _C1, _A1>&);
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator<(const map<_K1, _T1, _C1, _A1>&,
+    const map<_K1, _T1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+       const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+       const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline void
+    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
+  map<_Key, _Tp, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    class map;
+  template <typename _Key, typename _Tp,
+     typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
+    class multimap
+    {
+    public:
+      typedef _Key key_type;
+      typedef _Tp mapped_type;
+      typedef std::pair<const _Key, _Tp> value_type;
+      typedef _Compare key_compare;
+      typedef _Alloc allocator_type;
+    private:
+    public:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+      class value_compare
+      : public std::binary_function<value_type, value_type, bool>
+      {
+ friend class multimap<_Key, _Tp, _Compare, _Alloc>;
+      protected:
+ _Compare comp;
+ value_compare(_Compare __c)
+ : comp(__c) { }
+      public:
+ bool operator()(const value_type& __x, const value_type& __y) const
+ { return comp(__x.first, __y.first); }
+      };
+#pragma GCC diagnostic pop
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<value_type>::other _Pair_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
+         key_compare, _Pair_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      typedef typename _Rep_type::reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      multimap() = default;
+      explicit
+      multimap(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a)) { }
+      multimap(const multimap&) = default;
+      multimap(multimap&&) = default;
+      multimap(initializer_list<value_type> __l,
+        const _Compare& __comp = _Compare(),
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      explicit
+      multimap(const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a)) { }
+      multimap(const multimap& __m,
+        const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }
+      multimap(multimap&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }
+      multimap(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last,
+   const allocator_type& __a)
+ : _M_t(_Pair_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last,
+   const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Pair_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      ~multimap() = default;
+      multimap&
+      operator=(const multimap&) = default;
+      multimap&
+      operator=(multimap&&) = default;
+      multimap&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_equal(__l.begin(), __l.end());
+ return *this;
+      }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() noexcept
+      { return _M_t.end(); }
+      const_iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() noexcept
+      { return _M_t.rend(); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      const_iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      const_reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      template<typename... _Args>
+ iterator
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_equal(__pos,
+         std::forward<_Args>(__args)...);
+ }
+      iterator
+      insert(const value_type& __x)
+      { return _M_t._M_insert_equal(__x); }
+      iterator
+      insert(value_type&& __x)
+      { return _M_t._M_insert_equal(std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
+ insert(_Pair&& __x)
+ { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_equal_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
+ insert(const_iterator __position, _Pair&& __x)
+ {
+   return _M_t._M_emplace_hint_equal(__position,
+         std::forward<_Pair>(__x));
+ }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_equal(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      swap(multimap& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return value_compare(_M_t.key_comp()); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.count(__x); }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x)))
+ {
+   return pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x));
+ }
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator==(const multimap<_K1, _T1, _C1, _A1>&,
+     const multimap<_K1, _T1, _C1, _A1>&);
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator<(const multimap<_K1, _T1, _C1, _A1>&,
+    const multimap<_K1, _T1, _C1, _A1>&);
+  };
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline void
+    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+class CoinPackedVector;
+class CoinPackedVectorBase {
+public:
+  virtual int getNumElements() const = 0;
+  virtual const int *getIndices() const = 0;
+  virtual const double *getElements() const = 0;
+  void setTestForDuplicateIndex(bool test) const;
+  void setTestForDuplicateIndexWhenTrue(bool test) const;
+  bool testForDuplicateIndex() const { return testForDuplicateIndex_; }
+  inline void setTestsOff() const
+  {
+    testForDuplicateIndex_ = false;
+    testedDuplicateIndex_ = false;
+  }
+  double *denseVector(int denseSize) const;
+  double operator[](int i) const;
+  int getMaxIndex() const;
+  int getMinIndex() const;
+  void duplicateIndex(const char *methodName = __null,
+    const char *className = __null) const;
+  bool isExistingIndex(int i) const;
+  int findIndex(int i) const;
+  bool operator==(const CoinPackedVectorBase &rhs) const;
+  bool operator!=(const CoinPackedVectorBase &rhs) const;
+  int compare(const CoinPackedVectorBase &rhs) const;
+  template < class FloatEqual >
+  bool
+  isEquivalent(const CoinPackedVectorBase &rhs, const FloatEqual &eq) const
+  {
+    if (getNumElements() != rhs.getNumElements())
+      return false;
+    duplicateIndex("equivalent", "CoinPackedVector");
+    rhs.duplicateIndex("equivalent", "CoinPackedVector");
+    std::map< int, double > mv;
+    const int *inds = getIndices();
+    const double *elems = getElements();
+    int i;
+    for (i = getNumElements() - 1; i >= 0; --i) {
+      mv.insert(std::make_pair(inds[i], elems[i]));
+    }
+    std::map< int, double > mvRhs;
+    inds = rhs.getIndices();
+    elems = rhs.getElements();
+    for (i = getNumElements() - 1; i >= 0; --i) {
+      mvRhs.insert(std::make_pair(inds[i], elems[i]));
+    }
+    std::map< int, double >::const_iterator mvI = mv.begin();
+    std::map< int, double >::const_iterator mvIlast = mv.end();
+    std::map< int, double >::const_iterator mvIrhs = mvRhs.begin();
+    while (mvI != mvIlast) {
+      if (mvI->first != mvIrhs->first || !eq(mvI->second, mvIrhs->second))
+        return false;
+      ++mvI;
+      ++mvIrhs;
+    }
+    return true;
+  }
+  bool isEquivalent(const CoinPackedVectorBase &rhs) const;
+  double dotProduct(const double *dense) const;
+  double oneNorm() const;
+  double normSquare() const;
+  double twoNorm() const;
+  double infNorm() const;
+  double sum() const;
+protected:
+  CoinPackedVectorBase();
+public:
+  virtual ~CoinPackedVectorBase();
+private:
+  CoinPackedVectorBase(const CoinPackedVectorBase &);
+  CoinPackedVectorBase &operator=(const CoinPackedVectorBase &);
+protected:
+  void findMaxMinIndices() const;
+  std::set< int > *indexSet(const char *methodName = __null,
+    const char *className = __null) const;
+  void clearIndexSet() const;
+  void clearBase() const;
+  void copyMaxMinIndex(const CoinPackedVectorBase &x) const
+  {
+    maxIndex_ = x.maxIndex_;
+    minIndex_ = x.minIndex_;
+  }
+private:
+  mutable int maxIndex_;
+  mutable int minIndex_;
+  mutable std::set< int > *indexSetPtr_;
+  mutable bool testForDuplicateIndex_;
+  mutable bool testedDuplicateIndex_;
+};
+class CoinShallowPackedVector : public CoinPackedVectorBase {
+  friend void CoinShallowPackedVectorUnitTest();
+public:
+  virtual int getNumElements() const { return nElements_; }
+  virtual const int *getIndices() const { return indices_; }
+  virtual const double *getElements() const { return elements_; }
+  void clear();
+  CoinShallowPackedVector &operator=(const CoinShallowPackedVector &x);
+  CoinShallowPackedVector &operator=(const CoinPackedVectorBase &x);
+  void setVector(int size, const int *indices, const double *elements,
+    bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(int size,
+    const int *indices, const double *elements,
+    bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(const CoinPackedVectorBase &);
+  CoinShallowPackedVector(const CoinShallowPackedVector &);
+  virtual ~CoinShallowPackedVector() {}
+  void print();
+private:
+  const int *indices_;
+  const double *elements_;
+  int nElements_;
+};
+void CoinShallowPackedVectorUnitTest();
+class CoinPackedMatrix {
+  friend void CoinPackedMatrixUnitTest();
+public:
+  inline double getExtraGap() const { return extraGap_; }
+  inline double getExtraMajor() const { return extraMajor_; }
+  void reserve(const int newMaxMajorDim, const CoinBigIndex newMaxSize,
+    bool create = false);
+  void clear();
+  inline bool isColOrdered() const { return colOrdered_; }
+  inline bool hasGaps() const { return (size_ < start_[majorDim_]); }
+  inline CoinBigIndex getNumElements() const { return size_; }
+  inline int getNumCols() const
+  {
+    return colOrdered_ ? majorDim_ : minorDim_;
+  }
+  inline int getNumRows() const
+  {
+    return colOrdered_ ? minorDim_ : majorDim_;
+  }
+  inline const double *getElements() const { return element_; }
+  inline const int *getIndices() const { return index_; }
+  inline int getSizeVectorStarts() const
+  {
+    return ((majorDim_ > 0) ? (majorDim_ + 1) : (0));
+  }
+  inline int getSizeVectorLengths() const { return majorDim_; }
+  inline const CoinBigIndex *getVectorStarts() const { return start_; }
+  inline const int *getVectorLengths() const { return length_; }
+  CoinBigIndex getVectorFirst(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorFirst", "CoinPackedMatrix");
+    return start_[i];
+  }
+  CoinBigIndex getVectorLast(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorLast", "CoinPackedMatrix");
+    return start_[i] + length_[i];
+  }
+  inline int getVectorSize(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorSize", "CoinPackedMatrix");
+    return length_[i];
+  }
+  const CoinShallowPackedVector getVector(int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vector", "CoinPackedMatrix");
+    return CoinShallowPackedVector(length_[i],
+      index_ + start_[i],
+      element_ + start_[i],
+      false);
+  }
+  int *getMajorIndices() const;
+  void setDimensions(int numrows, int numcols);
+  void setExtraGap(const double newGap);
+  void setExtraMajor(const double newMajor);
+  void appendCol(const CoinPackedVectorBase &vec);
+  void appendCol(const int vecsize,
+    const int *vecind, const double *vecelem);
+  void appendCols(const int numcols,
+    const CoinPackedVectorBase *const *cols);
+  int appendCols(const int numcols,
+    const CoinBigIndex *columnStarts, const int *row,
+    const double *element, int numberRows = -1);
+  void appendRow(const CoinPackedVectorBase &vec);
+  void appendRow(const int vecsize,
+    const int *vecind, const double *vecelem);
+  void appendRows(const int numrows,
+    const CoinPackedVectorBase *const *rows);
+  int appendRows(const int numrows,
+    const CoinBigIndex *rowStarts, const int *column,
+    const double *element, int numberColumns = -1);
+  void rightAppendPackedMatrix(const CoinPackedMatrix &matrix);
+  void bottomAppendPackedMatrix(const CoinPackedMatrix &matrix);
+  void deleteCols(const int numDel, const int *indDel);
+  void deleteRows(const int numDel, const int *indDel);
+  void replaceVector(const int index,
+    const int numReplace, const double *newElements);
+  void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false);
+  double getCoefficient(int row, int column) const;
+  CoinBigIndex compress(double threshold);
+  CoinBigIndex eliminateDuplicates(double threshold);
+  void orderMatrix();
+  CoinBigIndex cleanMatrix(double threshold = 1.0e-20);
+  void removeGaps(double removeValue = -1.0);
+  void submatrixOf(const CoinPackedMatrix &matrix,
+    const int numMajor, const int *indMajor);
+  void submatrixOfWithDuplicates(const CoinPackedMatrix &matrix,
+    const int numMajor, const int *indMajor);
+  void copyOf(const CoinPackedMatrix &rhs);
+  void copyOf(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor = 0.0, const double extraGap = 0.0);
+  void copyReuseArrays(const CoinPackedMatrix &rhs);
+  void reverseOrderedCopyOf(const CoinPackedMatrix &rhs);
+  void assignMatrix(const bool colordered,
+    const int minor, const int major,
+    const CoinBigIndex numels,
+    double *&elem, int *&ind,
+    CoinBigIndex *&start, int *&len,
+    const int maxmajor = -1, const CoinBigIndex maxsize = -1);
+  CoinPackedMatrix &operator=(const CoinPackedMatrix &rhs);
+  void reverseOrdering();
+  void transpose();
+  void swap(CoinPackedMatrix &matrix);
+  void times(const double *x, double *y) const;
+  void times(const CoinPackedVectorBase &x, double *y) const;
+  void transposeTimes(const double *x, double *y) const;
+  void transposeTimes(const CoinPackedVectorBase &x, double *y) const;
+  int *countOrthoLength() const;
+  void countOrthoLength(int *counts) const;
+  inline int getMajorDim() const { return majorDim_; }
+  inline void setMajorDim(int value) { majorDim_ = value; }
+  inline int getMinorDim() const { return minorDim_; }
+  inline void setMinorDim(int value) { minorDim_ = value; }
+  inline int getMaxMajorDim() const { return maxMajorDim_; }
+  void dumpMatrix(const char *fname = __null) const;
+  void printMatrixElement(const int row_val, const int col_val) const;
+  void appendMajorVector(const CoinPackedVectorBase &vec);
+  void appendMajorVector(const int vecsize, const int *vecind,
+    const double *vecelem);
+  void appendMajorVectors(const int numvecs,
+    const CoinPackedVectorBase *const *vecs);
+  void appendMinorVector(const CoinPackedVectorBase &vec);
+  void appendMinorVector(const int vecsize, const int *vecind,
+    const double *vecelem);
+  void appendMinorVectors(const int numvecs,
+    const CoinPackedVectorBase *const *vecs);
+  void appendMinorFast(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element);
+  void majorAppendSameOrdered(const CoinPackedMatrix &matrix);
+  void minorAppendSameOrdered(const CoinPackedMatrix &matrix);
+  void majorAppendOrthoOrdered(const CoinPackedMatrix &matrix);
+  void minorAppendOrthoOrdered(const CoinPackedMatrix &matrix);
+  void deleteMajorVectors(const int numDel, const int *indDel);
+  void deleteMinorVectors(const int numDel, const int *indDel);
+  void timesMajor(const double *x, double *y) const;
+  void timesMajor(const CoinPackedVectorBase &x, double *y) const;
+  void timesMinor(const double *x, double *y) const;
+  void timesMinor(const CoinPackedVectorBase &x, double *y) const;
+  template < class FloatEqual >
+  bool
+  isEquivalent(const CoinPackedMatrix &rhs, const FloatEqual &eq) const
+  {
+    if ((isColOrdered() ^ rhs.isColOrdered()) || (getNumCols() != rhs.getNumCols()) || (getNumRows() != rhs.getNumRows()) || (getNumElements() != rhs.getNumElements()))
+      return false;
+    for (int i = getMajorDim() - 1; i >= 0; --i) {
+      CoinShallowPackedVector pv = getVector(i);
+      CoinShallowPackedVector rhsPv = rhs.getVector(i);
+      if (!pv.isEquivalent(rhsPv, eq))
+        return false;
+    }
+    return true;
+  }
+  bool isEquivalent2(const CoinPackedMatrix &rhs) const;
+  bool isEquivalent(const CoinPackedMatrix &rhs) const;
+  inline double *getMutableElements() const { return element_; }
+  inline int *getMutableIndices() const { return index_; }
+  inline CoinBigIndex *getMutableVectorStarts() const { return start_; }
+  inline int *getMutableVectorLengths() const { return length_; }
+  inline void setNumElements(CoinBigIndex value)
+  {
+    size_ = value;
+  }
+  inline void nullElementArray() { element_ = __null; }
+  inline void nullStartArray() { start_ = __null; }
+  inline void nullLengthArray() { length_ = __null; }
+  inline void nullIndexArray() { index_ = __null; }
+  CoinPackedMatrix();
+  CoinPackedMatrix(const bool colordered,
+    const double extraMajor, const double extraGap);
+  CoinPackedMatrix(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor, const double extraGap);
+  CoinPackedMatrix(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len);
+  CoinPackedMatrix(const bool colordered,
+    const int *rowIndices,
+    const int *colIndices,
+    const double *elements,
+    CoinBigIndex numels);
+  CoinPackedMatrix(const CoinPackedMatrix &m);
+  CoinPackedMatrix(const CoinPackedMatrix &m,
+    int extraForMajor, int extraElements,
+    bool reverseOrdering = false);
+  CoinPackedMatrix(const CoinPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  virtual ~CoinPackedMatrix();
+  int verifyMtx(int verbosity = 1, bool zeroesAreError = false) const;
+protected:
+  void gutsOfDestructor();
+  void gutsOfCopyOf(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor = 0.0, const double extraGap = 0.0);
+  void gutsOfCopyOfNoGaps(const bool colordered,
+    const int minor, const int major,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start);
+  void gutsOfOpEqual(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len);
+  void resizeForAddingMajorVectors(const int numVec, const int *lengthVec);
+  void resizeForAddingMinorVectors(const int *addedEntries);
+  int appendMajor(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  int appendMinor(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+private:
+  inline CoinBigIndex getLastStart() const
+  {
+    return majorDim_ == 0 ? 0 : start_[majorDim_];
+  }
+protected:
+  bool colOrdered_;
+  double extraGap_;
+  double extraMajor_;
+  double *element_;
+  int *index_;
+  CoinBigIndex *start_;
+  int *length_;
+  int majorDim_;
+  int minorDim_;
+  CoinBigIndex size_;
+  int maxMajorDim_;
+  CoinBigIndex maxSize_;
+};
+void CoinPackedMatrixUnitTest();
+class CoinIndexedVector;
+class ClpSimplex;
+class ClpModel;
+class ClpMatrixBase {
+public:
+  virtual CoinPackedMatrix *getPackedMatrix() const = 0;
+  virtual bool isColOrdered() const = 0;
+  virtual CoinBigIndex getNumElements() const = 0;
+  virtual int getNumCols() const = 0;
+  virtual int getNumRows() const = 0;
+  virtual const double *getElements() const = 0;
+  virtual const int *getIndices() const = 0;
+  virtual const CoinBigIndex *getVectorStarts() const = 0;
+  virtual const int *getVectorLengths() const = 0;
+  virtual int getVectorLength(int index) const;
+  virtual void deleteCols(const int numDel, const int *indDel) = 0;
+  virtual void deleteRows(const int numDel, const int *indDel) = 0;
+  virtual void appendCols(int number, const CoinPackedVectorBase *const *columns);
+  virtual void appendRows(int number, const CoinPackedVectorBase *const *rows);
+  virtual void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false);
+  virtual int appendMatrix(int number, int type,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  virtual ClpMatrixBase *reverseOrderedCopy() const
+  {
+    return __null;
+  }
+  virtual int countBasis(const int *whichColumn,
+    int &numberColumnBasic)
+    = 0;
+  virtual void fillBasis(ClpSimplex *model,
+    const int *whichColumn,
+    int &numberColumnBasic,
+    int *row, int *start,
+    int *rowCount, int *columnCount,
+    CoinFactorizationDouble *element)
+    = 0;
+  virtual int scale(ClpModel *, ClpSimplex * = __null) const
+  {
+    return 1;
+  }
+  virtual void scaleRowCopy(ClpModel *) const {}
+  virtual bool canGetRowCopy() const
+  {
+    return true;
+  }
+  inline virtual ClpMatrixBase *scaledColumnCopy(ClpModel *) const
+  {
+    return this->clone();
+  }
+  virtual bool allElementsInRange(ClpModel *,
+    double, double,
+    int = 15)
+  {
+    return true;
+  }
+  virtual void setDimensions(int numrows, int numcols);
+  virtual void rangeOfElements(double &smallestNegative, double &largestNegative,
+    double &smallestPositive, double &largestPositive);
+  virtual void unpack(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column) const = 0;
+  virtual void unpackPacked(ClpSimplex *model,
+    CoinIndexedVector *rowArray,
+    int column) const = 0;
+  virtual int refresh(ClpSimplex *)
+  {
+    return 0;
+  }
+  virtual void reallyScale(const double *rowScale, const double *columnScale);
+  virtual CoinBigIndex *dubiousWeights(const ClpSimplex *model, int *inputWeights) const;
+  virtual void add(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column, double multiplier) const = 0;
+  virtual void add(const ClpSimplex *model, double *array,
+    int column, double multiplier) const = 0;
+  virtual void releasePackedMatrix() const = 0;
+  virtual bool canDoPartialPricing() const;
+  virtual int hiddenRows() const;
+  virtual void partialPricing(ClpSimplex *model, double start, double end,
+    int &bestSequence, int &numberWanted);
+  virtual int extendUpdated(ClpSimplex *model, CoinIndexedVector *update, int mode);
+  virtual void primalExpanded(ClpSimplex *model, int mode);
+  virtual void dualExpanded(ClpSimplex *model, CoinIndexedVector *array,
+    double *other, int mode);
+  virtual int generalExpanded(ClpSimplex *model, int mode, int &number);
+  virtual int updatePivot(ClpSimplex *model, double oldInValue, double oldOutValue);
+  virtual void createVariable(ClpSimplex *model, int &bestSequence);
+  virtual int checkFeasible(ClpSimplex *model, double &sum) const;
+  double reducedCost(ClpSimplex *model, int sequence) const;
+  virtual void correctSequence(const ClpSimplex *model, int &sequenceIn, int &sequenceOut);
+  virtual void times(double scalar,
+    const double * x, double * y) const = 0;
+  virtual void times(double scalar,
+    const double * x, double * y,
+    const double * rowScale,
+    const double * columnScale) const;
+  virtual void transposeTimes(double scalar,
+    const double * x, double * y) const = 0;
+  virtual void transposeTimes(double scalar,
+    const double * x, double * y,
+    const double * rowScale,
+    const double * columnScale,
+    double * spare = __null) const;
+  virtual void transposeTimes(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const = 0;
+  virtual void subsetTransposeTimes(const ClpSimplex *model,
+    const CoinIndexedVector *x,
+    const CoinIndexedVector *y,
+    CoinIndexedVector *z) const = 0;
+  virtual bool canCombine(const ClpSimplex *,
+    const CoinIndexedVector *) const
+  {
+    return false;
+  }
+  virtual int transposeTimes2(const ClpSimplex *model,
+    const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2,
+    CoinIndexedVector *spare,
+    double *infeas, double *reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void subsetTimes2(const ClpSimplex *model,
+    CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void listTransposeTimes(const ClpSimplex *model,
+    double *x,
+    int *y,
+    int number,
+    double *z) const;
+  virtual ClpMatrixBase *clone() const = 0;
+  virtual ClpMatrixBase *subsetClone(
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns) const;
+  virtual void backToBasics() {}
+  inline int type() const
+  {
+    return type_;
+  }
+  void setType(int newtype)
+  {
+    type_ = newtype;
+  }
+  void useEffectiveRhs(ClpSimplex *model);
+  virtual double *rhsOffset(ClpSimplex *model, bool forceRefresh = false,
+    bool check = false);
+  inline int lastRefresh() const
+  {
+    return lastRefresh_;
+  }
+  inline int refreshFrequency() const
+  {
+    return refreshFrequency_;
+  }
+  inline void setRefreshFrequency(int value)
+  {
+    refreshFrequency_ = value;
+  }
+  inline bool skipDualCheck() const
+  {
+    return skipDualCheck_;
+  }
+  inline void setSkipDualCheck(bool yes)
+  {
+    skipDualCheck_ = yes;
+  }
+  inline int minimumObjectsScan() const
+  {
+    return minimumObjectsScan_;
+  }
+  inline void setMinimumObjectsScan(int value)
+  {
+    minimumObjectsScan_ = value;
+  }
+  inline int minimumGoodReducedCosts() const
+  {
+    return minimumGoodReducedCosts_;
+  }
+  inline void setMinimumGoodReducedCosts(int value)
+  {
+    minimumGoodReducedCosts_ = value;
+  }
+  inline double startFraction() const
+  {
+    return startFraction_;
+  }
+  inline void setStartFraction(double value)
+  {
+    startFraction_ = value;
+  }
+  inline double endFraction() const
+  {
+    return endFraction_;
+  }
+  inline void setEndFraction(double value)
+  {
+    endFraction_ = value;
+  }
+  inline double savedBestDj() const
+  {
+    return savedBestDj_;
+  }
+  inline void setSavedBestDj(double value)
+  {
+    savedBestDj_ = value;
+  }
+  inline int originalWanted() const
+  {
+    return originalWanted_;
+  }
+  inline void setOriginalWanted(int value)
+  {
+    originalWanted_ = value;
+  }
+  inline int currentWanted() const
+  {
+    return currentWanted_;
+  }
+  inline void setCurrentWanted(int value)
+  {
+    currentWanted_ = value;
+  }
+  inline int savedBestSequence() const
+  {
+    return savedBestSequence_;
+  }
+  inline void setSavedBestSequence(int value)
+  {
+    savedBestSequence_ = value;
+  }
+protected:
+  ClpMatrixBase();
+public:
+  virtual ~ClpMatrixBase();
+protected:
+  ClpMatrixBase(const ClpMatrixBase &);
+  ClpMatrixBase &operator=(const ClpMatrixBase &);
+protected:
+  double *rhsOffset_;
+  double startFraction_;
+  double endFraction_;
+  double savedBestDj_;
+  int originalWanted_;
+  int currentWanted_;
+  int savedBestSequence_;
+  int type_;
+  int lastRefresh_;
+  int refreshFrequency_;
+  int minimumObjectsScan_;
+  int minimumGoodReducedCosts_;
+  int trueSequenceIn_;
+  int trueSequenceOut_;
+  bool skipDualCheck_;
+};
+class ClpSimplex;
+class CoinIndexedVector;
+class ClpPrimalColumnPivot {
+public:
+  virtual int pivotColumn(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2)
+    = 0;
+  virtual void updateWeights(CoinIndexedVector *input);
+  virtual void saveWeights(ClpSimplex *model, int mode) = 0;
+  virtual int pivotRow(double &way)
+  {
+    way = 0;
+    return -2;
+  }
+  virtual void clearArrays();
+  virtual bool looksOptimal() const
+  {
+    return looksOptimal_;
+  }
+  virtual void setLooksOptimal(bool flag)
+  {
+    looksOptimal_ = flag;
+  }
+  ClpPrimalColumnPivot();
+  ClpPrimalColumnPivot(const ClpPrimalColumnPivot &);
+  ClpPrimalColumnPivot &operator=(const ClpPrimalColumnPivot &rhs);
+  virtual ~ClpPrimalColumnPivot();
+  virtual ClpPrimalColumnPivot *clone(bool copyData = true) const = 0;
+  inline ClpSimplex *model()
+  {
+    return model_;
+  }
+  inline void setModel(ClpSimplex *newmodel)
+  {
+    model_ = newmodel;
+  }
+  inline int type()
+  {
+    return type_;
+  }
+  virtual int numberSprintColumns(int &numberIterations) const;
+  virtual void switchOffSprint();
+  virtual void maximumPivotsChanged() {}
+protected:
+  ClpSimplex *model_;
+  int type_;
+  bool looksOptimal_;
+};
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<size_t _Nw>
+    struct _Base_bitset
+    {
+      typedef unsigned long _WordT;
+      _WordT _M_w[_Nw];
+      constexpr _Base_bitset() noexcept
+      : _M_w() { }
+      constexpr _Base_bitset(unsigned long long __val) noexcept
+      : _M_w{ _WordT(__val)
+       } { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t __pos) noexcept
+      { return _M_w[_S_whichword(__pos)]; }
+      constexpr _WordT
+      _M_getword(size_t __pos) const noexcept
+      { return _M_w[_S_whichword(__pos)]; }
+      const _WordT*
+      _M_getdata() const noexcept
+      { return _M_w; }
+      _WordT&
+      _M_hiword() noexcept
+      { return _M_w[_Nw - 1]; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return _M_w[_Nw - 1]; }
+      void
+      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] &= __x._M_w[__i];
+      }
+      void
+      _M_do_or(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] |= __x._M_w[__i];
+      }
+      void
+      _M_do_xor(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] ^= __x._M_w[__i];
+      }
+      void
+      _M_do_left_shift(size_t __shift) noexcept;
+      void
+      _M_do_right_shift(size_t __shift) noexcept;
+      void
+      _M_do_flip() noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] = ~_M_w[__i];
+      }
+      void
+      _M_do_set() noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] = ~static_cast<_WordT>(0);
+      }
+      void
+      _M_do_reset() noexcept
+      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }
+      bool
+      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; ++__i)
+   if (_M_w[__i] != __x._M_w[__i])
+     return false;
+ return true;
+      }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        {
+   for (size_t __i = 0; __i < _Nw - 1; __i++)
+     if (_M_w[__i] != ~static_cast<_WordT>(0))
+       return false;
+   return _M_hiword() == (~static_cast<_WordT>(0)
+     >> (_Nw * (8 * 8)
+         - _Nb));
+ }
+      bool
+      _M_is_any() const noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   if (_M_w[__i] != static_cast<_WordT>(0))
+     return true;
+ return false;
+      }
+      size_t
+      _M_do_count() const noexcept
+      {
+ size_t __result = 0;
+ for (size_t __i = 0; __i < _Nw; __i++)
+   __result += __builtin_popcountl(_M_w[__i]);
+ return __result;
+      }
+      unsigned long
+      _M_do_to_ulong() const;
+      unsigned long long
+      _M_do_to_ullong() const;
+      size_t
+      _M_do_find_first(size_t) const noexcept;
+      size_t
+      _M_do_find_next(size_t, size_t) const noexcept;
+    };
+  template<size_t _Nw>
+    void
+    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept
+    {
+      if (__builtin_expect(__shift != 0, 1))
+ {
+   const size_t __wshift = __shift / (8 * 8);
+   const size_t __offset = __shift % (8 * 8);
+   if (__offset == 0)
+     for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
+       _M_w[__n] = _M_w[__n - __wshift];
+   else
+     {
+       const size_t __sub_offset = ((8 * 8)
+        - __offset);
+       for (size_t __n = _Nw - 1; __n > __wshift; --__n)
+  _M_w[__n] = ((_M_w[__n - __wshift] << __offset)
+        | (_M_w[__n - __wshift - 1] >> __sub_offset));
+       _M_w[__wshift] = _M_w[0] << __offset;
+     }
+   std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
+ }
+    }
+  template<size_t _Nw>
+    void
+    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept
+    {
+      if (__builtin_expect(__shift != 0, 1))
+ {
+   const size_t __wshift = __shift / (8 * 8);
+   const size_t __offset = __shift % (8 * 8);
+   const size_t __limit = _Nw - __wshift - 1;
+   if (__offset == 0)
+     for (size_t __n = 0; __n <= __limit; ++__n)
+       _M_w[__n] = _M_w[__n + __wshift];
+   else
+     {
+       const size_t __sub_offset = ((8 * 8)
+        - __offset);
+       for (size_t __n = 0; __n < __limit; ++__n)
+  _M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
+        | (_M_w[__n + __wshift + 1] << __sub_offset));
+       _M_w[__limit] = _M_w[_Nw-1] >> __offset;
+     }
+   std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
+ }
+    }
+  template<size_t _Nw>
+    unsigned long
+    _Base_bitset<_Nw>::_M_do_to_ulong() const
+    {
+      for (size_t __i = 1; __i < _Nw; ++__i)
+ if (_M_w[__i])
+   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
+      return _M_w[0];
+    }
+  template<size_t _Nw>
+    unsigned long long
+    _Base_bitset<_Nw>::_M_do_to_ullong() const
+    {
+      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
+      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
+ if (_M_w[__i])
+   __throw_overflow_error(("_Base_bitset::_M_do_to_ullong"));
+      if (__dw)
+ return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
+     << (8 * 8));
+      return _M_w[0];
+    }
+  template<size_t _Nw>
+    size_t
+    _Base_bitset<_Nw>::
+    _M_do_find_first(size_t __not_found) const noexcept
+    {
+      for (size_t __i = 0; __i < _Nw; __i++)
+ {
+   _WordT __thisword = _M_w[__i];
+   if (__thisword != static_cast<_WordT>(0))
+     return (__i * (8 * 8)
+      + __builtin_ctzl(__thisword));
+ }
+      return __not_found;
+    }
+  template<size_t _Nw>
+    size_t
+    _Base_bitset<_Nw>::
+    _M_do_find_next(size_t __prev, size_t __not_found) const noexcept
+    {
+      ++__prev;
+      if (__prev >= _Nw * (8 * 8))
+ return __not_found;
+      size_t __i = _S_whichword(__prev);
+      _WordT __thisword = _M_w[__i];
+      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
+      if (__thisword != static_cast<_WordT>(0))
+ return (__i * (8 * 8)
+  + __builtin_ctzl(__thisword));
+      __i++;
+      for (; __i < _Nw; __i++)
+ {
+   __thisword = _M_w[__i];
+   if (__thisword != static_cast<_WordT>(0))
+     return (__i * (8 * 8)
+      + __builtin_ctzl(__thisword));
+ }
+      return __not_found;
+    }
+  template<>
+    struct _Base_bitset<1>
+    {
+      typedef unsigned long _WordT;
+      _WordT _M_w;
+      constexpr _Base_bitset() noexcept
+      : _M_w(0)
+      { }
+      constexpr _Base_bitset(unsigned long long __val) noexcept
+      : _M_w(__val)
+      { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t) noexcept
+      { return _M_w; }
+      constexpr _WordT
+      _M_getword(size_t) const noexcept
+      { return _M_w; }
+      const _WordT*
+      _M_getdata() const noexcept
+      { return &_M_w; }
+      _WordT&
+      _M_hiword() noexcept
+      { return _M_w; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return _M_w; }
+      void
+      _M_do_and(const _Base_bitset<1>& __x) noexcept
+      { _M_w &= __x._M_w; }
+      void
+      _M_do_or(const _Base_bitset<1>& __x) noexcept
+      { _M_w |= __x._M_w; }
+      void
+      _M_do_xor(const _Base_bitset<1>& __x) noexcept
+      { _M_w ^= __x._M_w; }
+      void
+      _M_do_left_shift(size_t __shift) noexcept
+      { _M_w <<= __shift; }
+      void
+      _M_do_right_shift(size_t __shift) noexcept
+      { _M_w >>= __shift; }
+      void
+      _M_do_flip() noexcept
+      { _M_w = ~_M_w; }
+      void
+      _M_do_set() noexcept
+      { _M_w = ~static_cast<_WordT>(0); }
+      void
+      _M_do_reset() noexcept
+      { _M_w = 0; }
+      bool
+      _M_is_equal(const _Base_bitset<1>& __x) const noexcept
+      { return _M_w == __x._M_w; }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        { return _M_w == (~static_cast<_WordT>(0)
+     >> ((8 * 8) - _Nb)); }
+      bool
+      _M_is_any() const noexcept
+      { return _M_w != 0; }
+      size_t
+      _M_do_count() const noexcept
+      { return __builtin_popcountl(_M_w); }
+      unsigned long
+      _M_do_to_ulong() const noexcept
+      { return _M_w; }
+      unsigned long long
+      _M_do_to_ullong() const noexcept
+      { return _M_w; }
+      size_t
+      _M_do_find_first(size_t __not_found) const noexcept
+      {
+        if (_M_w != 0)
+          return __builtin_ctzl(_M_w);
+        else
+          return __not_found;
+      }
+      size_t
+      _M_do_find_next(size_t __prev, size_t __not_found) const
+ noexcept
+      {
+ ++__prev;
+ if (__prev >= ((size_t) (8 * 8)))
+   return __not_found;
+ _WordT __x = _M_w >> __prev;
+ if (__x != 0)
+   return __builtin_ctzl(__x) + __prev;
+ else
+   return __not_found;
+      }
+    };
+  template<>
+    struct _Base_bitset<0>
+    {
+      typedef unsigned long _WordT;
+      constexpr _Base_bitset() noexcept
+      { }
+      constexpr _Base_bitset(unsigned long long) noexcept
+      { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t) noexcept
+      {
+ __throw_out_of_range(("_Base_bitset::_M_getword"));
+ return *new _WordT;
+      }
+      constexpr _WordT
+      _M_getword(size_t) const noexcept
+      { return 0; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return 0; }
+      void
+      _M_do_and(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_or(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_xor(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_left_shift(size_t) noexcept
+      { }
+      void
+      _M_do_right_shift(size_t) noexcept
+      { }
+      void
+      _M_do_flip() noexcept
+      { }
+      void
+      _M_do_set() noexcept
+      { }
+      void
+      _M_do_reset() noexcept
+      { }
+      bool
+      _M_is_equal(const _Base_bitset<0>&) const noexcept
+      { return true; }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        { return true; }
+      bool
+      _M_is_any() const noexcept
+      { return false; }
+      size_t
+      _M_do_count() const noexcept
+      { return 0; }
+      unsigned long
+      _M_do_to_ulong() const noexcept
+      { return 0; }
+      unsigned long long
+      _M_do_to_ullong() const noexcept
+      { return 0; }
+      size_t
+      _M_do_find_first(size_t) const noexcept
+      { return 0; }
+      size_t
+      _M_do_find_next(size_t, size_t) const noexcept
+      { return 0; }
+    };
+  template<size_t _Extrabits>
+    struct _Sanitize
+    {
+      typedef unsigned long _WordT;
+      static void
+      _S_do_sanitize(_WordT& __val) noexcept
+      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
+    };
+  template<>
+    struct _Sanitize<0>
+    {
+      typedef unsigned long _WordT;
+      static void
+      _S_do_sanitize(_WordT) noexcept { }
+    };
+  template<size_t _Nb, bool = (_Nb < (8 * 8))>
+    struct _Sanitize_val
+    {
+      static constexpr unsigned long long
+      _S_do_sanitize_val(unsigned long long __val)
+      { return __val; }
+    };
+  template<size_t _Nb>
+    struct _Sanitize_val<_Nb, true>
+    {
+      static constexpr unsigned long long
+      _S_do_sanitize_val(unsigned long long __val)
+      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
+    };
+  template<size_t _Nb>
+    class bitset
+    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
+    {
+    private:
+      typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))> _Base;
+      typedef unsigned long _WordT;
+      template<class _CharT, class _Traits, class _Alloc>
+      void
+      _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+    size_t __position) const
+      {
+ if (__position > __s.size())
+   __throw_out_of_range_fmt(("bitset::bitset: __position " "(which is %zu) > __s.size() " "(which is %zu)"),
+       __position, __s.size());
+      }
+      void _M_check(size_t __position, const char *__s) const
+      {
+ if (__position >= _Nb)
+   __throw_out_of_range_fmt(("%s: __position (which is %zu) " ">= _Nb (which is %zu)"),
+       __s, __position, _Nb);
+      }
+      void
+      _M_do_sanitize() noexcept
+      {
+ typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
+ __sanitize_type::_S_do_sanitize(this->_M_hiword());
+      }
+      friend struct std::hash<bitset>;
+    public:
+      class reference
+      {
+ friend class bitset;
+ _WordT* _M_wp;
+ size_t _M_bpos;
+ reference();
+      public:
+ reference(bitset& __b, size_t __pos) noexcept
+ {
+   _M_wp = &__b._M_getword(__pos);
+   _M_bpos = _Base::_S_whichbit(__pos);
+ }
+ reference(const reference&) = default;
+ ~reference() noexcept
+ { }
+ reference&
+ operator=(bool __x) noexcept
+ {
+   if (__x)
+     *_M_wp |= _Base::_S_maskbit(_M_bpos);
+   else
+     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+ reference&
+ operator=(const reference& __j) noexcept
+ {
+   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
+     *_M_wp |= _Base::_S_maskbit(_M_bpos);
+   else
+     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+ bool
+ operator~() const noexcept
+ { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }
+ operator bool() const noexcept
+ { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
+ reference&
+ flip() noexcept
+ {
+   *_M_wp ^= _Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+      };
+      friend class reference;
+      constexpr bitset() noexcept
+      { }
+      constexpr bitset(unsigned long long __val) noexcept
+      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
+      template<class _CharT, class _Traits, class _Alloc>
+ explicit
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position = 0)
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position,
+         std::basic_string<_CharT, _Traits, _Alloc>::npos,
+         _CharT('0'), _CharT('1'));
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position, size_t __n)
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position, size_t __n,
+        _CharT __zero, _CharT __one = _CharT('1'))
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position, __n, __zero, __one);
+ }
+      template<typename _CharT>
+        explicit
+        bitset(const _CharT* __str,
+        typename std::basic_string<_CharT>::size_type __n
+        = std::basic_string<_CharT>::npos,
+        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
+        : _Base()
+        {
+   if (!__str)
+     __throw_logic_error(("bitset::bitset(const _CharT*, ...)"));
+   if (__n == std::basic_string<_CharT>::npos)
+     __n = std::char_traits<_CharT>::length(__str);
+   _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
+            __n, __zero,
+            __one);
+ }
+      bitset<_Nb>&
+      operator&=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_and(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator|=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_or(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator^=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_xor(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator<<=(size_t __position) noexcept
+      {
+ if (__builtin_expect(__position < _Nb, 1))
+   {
+     this->_M_do_left_shift(__position);
+     this->_M_do_sanitize();
+   }
+ else
+   this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      operator>>=(size_t __position) noexcept
+      {
+ if (__builtin_expect(__position < _Nb, 1))
+   {
+     this->_M_do_right_shift(__position);
+     this->_M_do_sanitize();
+   }
+ else
+   this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_set(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_set(size_t __pos, int __val) noexcept
+      {
+ if (__val)
+   this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
+ else
+   this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_reset(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_flip(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
+ return *this;
+      }
+      constexpr bool
+      _Unchecked_test(size_t __pos) const noexcept
+      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
+  != static_cast<_WordT>(0)); }
+      bitset<_Nb>&
+      set() noexcept
+      {
+ this->_M_do_set();
+ this->_M_do_sanitize();
+ return *this;
+      }
+      bitset<_Nb>&
+      set(size_t __position, bool __val = true)
+      {
+ this->_M_check(__position, ("bitset::set"));
+ return _Unchecked_set(__position, __val);
+      }
+      bitset<_Nb>&
+      reset() noexcept
+      {
+ this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      reset(size_t __position)
+      {
+ this->_M_check(__position, ("bitset::reset"));
+ return _Unchecked_reset(__position);
+      }
+      bitset<_Nb>&
+      flip() noexcept
+      {
+ this->_M_do_flip();
+ this->_M_do_sanitize();
+ return *this;
+      }
+      bitset<_Nb>&
+      flip(size_t __position)
+      {
+ this->_M_check(__position, ("bitset::flip"));
+ return _Unchecked_flip(__position);
+      }
+      bitset<_Nb>
+      operator~() const noexcept
+      { return bitset<_Nb>(*this).flip(); }
+      reference
+      operator[](size_t __position)
+      { return reference(*this, __position); }
+      constexpr bool
+      operator[](size_t __position) const
+      { return _Unchecked_test(__position); }
+      unsigned long
+      to_ulong() const
+      { return this->_M_do_to_ulong(); }
+      unsigned long long
+      to_ullong() const
+      { return this->_M_do_to_ullong(); }
+      template<class _CharT, class _Traits, class _Alloc>
+ std::basic_string<_CharT, _Traits, _Alloc>
+ to_string() const
+ {
+   std::basic_string<_CharT, _Traits, _Alloc> __result;
+   _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
+   return __result;
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ std::basic_string<_CharT, _Traits, _Alloc>
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ {
+   std::basic_string<_CharT, _Traits, _Alloc> __result;
+   _M_copy_to_string(__result, __zero, __one);
+   return __result;
+ }
+      template<class _CharT, class _Traits>
+ std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
+ to_string() const
+ { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }
+      template<class _CharT, class _Traits>
+ std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ { return to_string<_CharT, _Traits,
+                    std::allocator<_CharT> >(__zero, __one); }
+      template<class _CharT>
+ std::basic_string<_CharT, std::char_traits<_CharT>,
+                   std::allocator<_CharT> >
+ to_string() const
+ {
+   return to_string<_CharT, std::char_traits<_CharT>,
+                    std::allocator<_CharT> >();
+ }
+      template<class _CharT>
+ std::basic_string<_CharT, std::char_traits<_CharT>,
+                   std::allocator<_CharT> >
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ {
+   return to_string<_CharT, std::char_traits<_CharT>,
+                    std::allocator<_CharT> >(__zero, __one);
+ }
+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
+      to_string() const
+      {
+ return to_string<char, std::char_traits<char>,
+                  std::allocator<char> >();
+      }
+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
+      to_string(char __zero, char __one = '1') const
+      {
+ return to_string<char, std::char_traits<char>,
+                  std::allocator<char> >(__zero, __one);
+      }
+      template<class _CharT, class _Traits>
+        void
+        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
+    _CharT, _CharT);
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+ _M_copy_from_string(const std::basic_string<_CharT,
+       _Traits, _Alloc>& __s, size_t __pos, size_t __n,
+       _CharT __zero, _CharT __one)
+ { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
+         __zero, __one); }
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
+     _CharT, _CharT) const;
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+ _M_copy_from_string(const std::basic_string<_CharT,
+       _Traits, _Alloc>& __s, size_t __pos, size_t __n)
+ { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
+ { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }
+      size_t
+      count() const noexcept
+      { return this->_M_do_count(); }
+      constexpr size_t
+      size() const noexcept
+      { return _Nb; }
+      bool
+      operator==(const bitset<_Nb>& __rhs) const noexcept
+      { return this->_M_is_equal(__rhs); }
+      bool
+      operator!=(const bitset<_Nb>& __rhs) const noexcept
+      { return !this->_M_is_equal(__rhs); }
+      bool
+      test(size_t __position) const
+      {
+ this->_M_check(__position, ("bitset::test"));
+ return _Unchecked_test(__position);
+      }
+      bool
+      all() const noexcept
+      { return this->template _M_are_all<_Nb>(); }
+      bool
+      any() const noexcept
+      { return this->_M_is_any(); }
+      bool
+      none() const noexcept
+      { return !this->_M_is_any(); }
+      bitset<_Nb>
+      operator<<(size_t __position) const noexcept
+      { return bitset<_Nb>(*this) <<= __position; }
+      bitset<_Nb>
+      operator>>(size_t __position) const noexcept
+      { return bitset<_Nb>(*this) >>= __position; }
+      size_t
+      _Find_first() const noexcept
+      { return this->_M_do_find_first(_Nb); }
+      size_t
+      _Find_next(size_t __prev) const noexcept
+      { return this->_M_do_find_next(__prev, _Nb); }
+    };
+  template<size_t _Nb>
+    template<class _CharT, class _Traits>
+      void
+      bitset<_Nb>::
+      _M_copy_from_ptr(const _CharT* __s, size_t __len,
+         size_t __pos, size_t __n, _CharT __zero, _CharT __one)
+      {
+ reset();
+ const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
+ for (size_t __i = __nbits; __i > 0; --__i)
+   {
+     const _CharT __c = __s[__pos + __nbits - __i];
+     if (_Traits::eq(__c, __zero))
+       ;
+     else if (_Traits::eq(__c, __one))
+       _Unchecked_set(__i - 1);
+     else
+       __throw_invalid_argument(("bitset::_M_copy_from_ptr"));
+   }
+      }
+  template<size_t _Nb>
+    template<class _CharT, class _Traits, class _Alloc>
+      void
+      bitset<_Nb>::
+      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
+   _CharT __zero, _CharT __one) const
+      {
+ __s.assign(_Nb, __zero);
+ size_t __n = this->_Find_first();
+ while (__n < _Nb)
+   {
+     __s[_Nb - __n - 1] = __one;
+     __n = _Find_next(__n);
+   }
+      }
+  template<size_t _Nb>
+    inline bitset<_Nb>
+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result &= __y;
+      return __result;
+    }
+  template<size_t _Nb>
+    inline bitset<_Nb>
+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result |= __y;
+      return __result;
+    }
+  template <size_t _Nb>
+    inline bitset<_Nb>
+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result ^= __y;
+      return __result;
+    }
+  template<class _CharT, class _Traits, size_t _Nb>
+    std::basic_istream<_CharT, _Traits>&
+    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
+    {
+      typedef typename _Traits::char_type char_type;
+      typedef std::basic_istream<_CharT, _Traits> __istream_type;
+      typedef typename __istream_type::ios_base __ios_base;
+      std::basic_string<_CharT, _Traits> __tmp;
+      __tmp.reserve(_Nb);
+      const char_type __zero = __is.widen('0');
+      const char_type __one = __is.widen('1');
+      typename __ios_base::iostate __state = __ios_base::goodbit;
+      typename __istream_type::sentry __sentry(__is);
+      if (__sentry)
+ {
+   try
+     {
+       for (size_t __i = _Nb; __i > 0; --__i)
+  {
+    static typename _Traits::int_type __eof = _Traits::eof();
+    typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
+    if (_Traits::eq_int_type(__c1, __eof))
+      {
+        __state |= __ios_base::eofbit;
+        break;
+      }
+    else
+      {
+        const char_type __c2 = _Traits::to_char_type(__c1);
+        if (_Traits::eq(__c2, __zero))
+   __tmp.push_back(__zero);
+        else if (_Traits::eq(__c2, __one))
+   __tmp.push_back(__one);
+        else if (_Traits::
+          eq_int_type(__is.rdbuf()->sputbackc(__c2),
+        __eof))
+   {
+     __state |= __ios_base::failbit;
+     break;
+   }
+      }
+  }
+     }
+   catch(__cxxabiv1::__forced_unwind&)
+     {
+       __is._M_setstate(__ios_base::badbit);
+       throw;
+     }
+   catch(...)
+     { __is._M_setstate(__ios_base::badbit); }
+ }
+      if (__tmp.empty() && _Nb)
+ __state |= __ios_base::failbit;
+      else
+ __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
+    __zero, __one);
+      if (__state)
+ __is.setstate(__state);
+      return __is;
+    }
+  template <class _CharT, class _Traits, size_t _Nb>
+    std::basic_ostream<_CharT, _Traits>&
+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
+        const bitset<_Nb>& __x)
+    {
+      std::basic_string<_CharT, _Traits> __tmp;
+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
+      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
+      return __os << __tmp;
+    }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<size_t _Nb>
+    struct hash<std::bitset<_Nb>>
+    : public __hash_base<size_t, std::bitset<_Nb>>
+    {
+      size_t
+      operator()(const std::bitset<_Nb>& __b) const noexcept
+      {
+ const size_t __clength = (_Nb + 8 - 1) / 8;
+ return std::_Hash_impl::hash(__b._M_getdata(), __clength);
+      }
+    };
+  template<>
+    struct hash<std::bitset<0>>
+    : public __hash_base<size_t, std::bitset<0>>
+    {
+      size_t
+      operator()(const std::bitset<0>&) const noexcept
+      { return 0; }
+    };
+}
+class CoinIndexedVector;
+class ClpPrimalColumnSteepest : public ClpPrimalColumnPivot {
+public:
+  virtual int pivotColumn(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int pivotColumnOldMethod(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justDjs(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int partialPricing(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    int numberWanted,
+    int numberLook);
+  void djsAndDevex(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndSteepest(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndDevex2(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndSteepest2(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justDevex(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justSteepest(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int transposeTimes2(const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    CoinIndexedVector *spare, double scaleFactor);
+  virtual void updateWeights(CoinIndexedVector *input);
+  void checkAccuracy(int sequence, double relativeTolerance,
+    CoinIndexedVector *rowArray1,
+    CoinIndexedVector *rowArray2);
+  void initializeWeights();
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  void redoInfeasibilities();
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const;
+  virtual void maximumPivotsChanged();
+  inline int mode() const
+  {
+    return mode_;
+  }
+  inline void setMode(int mode)
+  {
+    mode_ = mode;
+  }
+  inline CoinIndexedVector *infeasible() const
+  {
+    return infeasible_;
+  }
+  inline const double *weights() const
+  {
+    return weights_;
+  }
+  inline CoinIndexedVector *alternateWeights() const
+  {
+    return alternateWeights_;
+  }
+  virtual int numberSprintColumns(int &numberIterations) const;
+  virtual void switchOffSprint();
+  enum Persistence {
+    normal = 0x00,
+    keep = 0x01
+  };
+  ClpPrimalColumnSteepest(int mode = 3);
+  ClpPrimalColumnSteepest(const ClpPrimalColumnSteepest &rhs);
+  ClpPrimalColumnSteepest &operator=(const ClpPrimalColumnSteepest &rhs);
+  virtual ~ClpPrimalColumnSteepest();
+  virtual ClpPrimalColumnPivot *clone(bool copyData = true) const;
+  inline bool reference(int i) const
+  {
+    return ((reference_[i >> 5] >> (i & 31)) & 1) != 0;
+  }
+  inline void setReference(int i, bool trueFalse)
+  {
+    unsigned int &value = reference_[i >> 5];
+    int bit = i & 31;
+    if (trueFalse)
+      value |= (1 << bit);
+    else
+      value &= ~(1 << bit);
+  }
+  inline void setPersistence(Persistence life)
+  {
+    persistence_ = life;
+  }
+  inline Persistence persistence() const
+  {
+    return persistence_;
+  }
+protected:
+  double devex_;
+  double *weights_;
+  CoinIndexedVector *infeasible_;
+  CoinIndexedVector *alternateWeights_;
+  double *savedWeights_;
+  unsigned int *reference_;
+  int state_;
+  int mode_;
+  int infeasibilitiesState_;
+  Persistence persistence_;
+  int numberSwitched_;
+  int pivotSequence_;
+  int savedPivotSequence_;
+  int savedSequenceOut_;
+  int lastRectified_;
+  int sizeFactorization_;
+};
+class ClpPackedMatrix2;
+class ClpPackedMatrix3;
+class CoinDoubleArrayWithLength;
+class ClpPackedMatrix : public ClpMatrixBase {
+public:
+  virtual CoinPackedMatrix *getPackedMatrix() const
+  {
+    return matrix_;
+  }
+  virtual bool isColOrdered() const
+  {
+    return matrix_->isColOrdered();
+  }
+  virtual CoinBigIndex getNumElements() const
+  {
+    return matrix_->getNumElements();
+  }
+  virtual int getNumCols() const
+  {
+    return matrix_->getNumCols();
+  }
+  virtual int getNumRows() const
+  {
+    return matrix_->getNumRows();
+  }
+  virtual const double *getElements() const
+  {
+    return matrix_->getElements();
+  }
+  inline double *getMutableElements() const
+  {
+    return matrix_->getMutableElements();
+  }
+  virtual const int *getIndices() const
+  {
+    return matrix_->getIndices();
+  }
+  virtual const CoinBigIndex *getVectorStarts() const
+  {
+    return matrix_->getVectorStarts();
+  }
+  virtual const int *getVectorLengths() const
+  {
+    return matrix_->getVectorLengths();
+  }
+  virtual int getVectorLength(int index) const
+  {
+    return matrix_->getVectorSize(index);
+  }
+  virtual void deleteCols(const int numDel, const int *indDel);
+  virtual void deleteRows(const int numDel, const int *indDel);
+  virtual void appendCols(int number, const CoinPackedVectorBase *const *columns);
+  virtual void appendRows(int number, const CoinPackedVectorBase *const *rows);
+  virtual int appendMatrix(int number, int type,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  virtual void replaceVector(const int index,
+    const int numReplace, const double *newElements)
+  {
+    matrix_->replaceVector(index, numReplace, newElements);
+  }
+  virtual void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false)
+  {
+    matrix_->modifyCoefficient(row, column, newElement, keepZero);
+  }
+  virtual ClpMatrixBase *reverseOrderedCopy() const;
+  virtual int countBasis(const int *whichColumn,
+    int &numberColumnBasic);
+  virtual void fillBasis(ClpSimplex *model,
+    const int *whichColumn,
+    int &numberColumnBasic,
+    int *row, int *start,
+    int *rowCount, int *columnCount,
+    CoinFactorizationDouble *element);
+  virtual int scale(ClpModel *model, ClpSimplex *simplex = __null) const;
+  virtual void scaleRowCopy(ClpModel *model) const;
+  void createScaledMatrix(ClpSimplex *model) const;
+  virtual ClpMatrixBase *scaledColumnCopy(ClpModel *model) const;
+  virtual bool allElementsInRange(ClpModel *model,
+    double smallest, double largest,
+    int check = 15);
+  virtual void rangeOfElements(double &smallestNegative, double &largestNegative,
+    double &smallestPositive, double &largestPositive);
+  virtual void unpack(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column) const;
+  virtual void unpackPacked(ClpSimplex *model,
+    CoinIndexedVector *rowArray,
+    int column) const;
+  virtual void add(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column, double multiplier) const;
+  virtual void add(const ClpSimplex *model, double *array,
+    int column, double multiplier) const;
+  virtual void releasePackedMatrix() const {}
+  virtual CoinBigIndex *dubiousWeights(const ClpSimplex *model, int *inputWeights) const;
+  virtual bool canDoPartialPricing() const;
+  virtual void partialPricing(ClpSimplex *model, double start, double end,
+    int &bestSequence, int &numberWanted);
+  virtual int refresh(ClpSimplex *model);
+  virtual void reallyScale(const double *rowScale, const double *columnScale);
+  virtual void setDimensions(int numrows, int numcols);
+  virtual void times(double scalar,
+    const double *x, double *y) const;
+  virtual void times(double scalar,
+    const double *x, double *y,
+    const double *rowScale,
+    const double *columnScale) const;
+  virtual void transposeTimes(double scalar,
+    const double *x, double *y) const;
+  virtual void transposeTimes(double scalar,
+    const double *x, double *y,
+    const double *rowScale,
+    const double *columnScale,
+    double *spare = __null) const;
+  void transposeTimesSubset(int number,
+    const int *which,
+    const double *pi, double *y,
+    const double *rowScale,
+    const double *columnScale,
+    double *spare = __null) const;
+  virtual void transposeTimes(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  void transposeTimesByColumn(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual void transposeTimesByRow(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual void subsetTransposeTimes(const ClpSimplex *model,
+    const CoinIndexedVector *x,
+    const CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual bool canCombine(const ClpSimplex *model,
+    const CoinIndexedVector *pi) const;
+  virtual int transposeTimes2(const ClpSimplex *model,
+    const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2,
+    CoinIndexedVector *spare,
+    double *infeas, double *reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void subsetTimes2(const ClpSimplex *model,
+    CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  void useEffectiveRhs(ClpSimplex *model);
+  inline CoinPackedMatrix *matrix() const
+  {
+    return matrix_;
+  }
+  inline void setMatrixNull()
+  {
+    matrix_ = __null;
+  }
+  inline void makeSpecialColumnCopy()
+  {
+    flags_ |= 16;
+  }
+  void releaseSpecialColumnCopy();
+  inline bool zeros() const
+  {
+    return ((flags_ & 1) != 0);
+  }
+  inline bool wantsSpecialColumnCopy() const
+  {
+    return ((flags_ & 16) != 0);
+  }
+  inline int flags() const
+  {
+    return flags_;
+  }
+  inline void checkGaps()
+  {
+    flags_ = (matrix_->hasGaps()) ? (flags_ | 2) : (flags_ & (~2));
+  }
+  inline int numberActiveColumns() const
+  {
+    return numberActiveColumns_;
+  }
+  inline void setNumberActiveColumns(int value)
+  {
+    numberActiveColumns_ = value;
+  }
+  ClpPackedMatrix();
+  virtual ~ClpPackedMatrix();
+  ClpPackedMatrix(const ClpPackedMatrix &);
+  ClpPackedMatrix(const CoinPackedMatrix &);
+  ClpPackedMatrix(const ClpPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  ClpPackedMatrix(const CoinPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  ClpPackedMatrix(CoinPackedMatrix *matrix);
+  ClpPackedMatrix &operator=(const ClpPackedMatrix &);
+  virtual ClpMatrixBase *clone() const;
+  virtual void copy(const ClpPackedMatrix *from);
+  virtual ClpMatrixBase *subsetClone(
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns) const;
+  void specialRowCopy(ClpSimplex *model, const ClpMatrixBase *rowCopy);
+  void specialColumnCopy(ClpSimplex *model);
+  virtual void correctSequence(const ClpSimplex *model, int &sequenceIn, int &sequenceOut);
+private:
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const double tolerance) const;
+  int gutsOfTransposeTimesScaled(const double * pi,
+    const double * columnScale,
+    int * index,
+    double * array,
+    const double tolerance) const;
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    const double tolerance) const;
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    int * spareIndex,
+    double * spareArray,
+    const double * reducedCost,
+    double &upperTheta,
+    double acceptablePivot,
+    double dualTolerance,
+    int &numberRemaining,
+    const double zeroTolerance) const;
+  int gutsOfTransposeTimesScaled(const double * pi,
+    const double * columnScale,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    const double tolerance) const;
+  int gutsOfTransposeTimesByRowGEK(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    int numberColumns,
+    const double tolerance,
+    const double scalar) const;
+  int gutsOfTransposeTimesByRowGE3(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    double * array2,
+    const double tolerance,
+    const double scalar) const;
+  int gutsOfTransposeTimesByRowGE3a(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    int * lookup,
+    char * marked,
+    const double tolerance,
+    const double scalar) const;
+  void gutsOfTransposeTimesByRowEQ2(const CoinIndexedVector *piVector, CoinIndexedVector *output,
+    CoinIndexedVector *spareVector, const double tolerance, const double scalar) const;
+  void gutsOfTransposeTimesByRowEQ1(const CoinIndexedVector *piVector, CoinIndexedVector *output,
+    const double tolerance, const double scalar) const;
+  void clearCopies();
+protected:
+  void checkFlags(int type) const;
+  CoinPackedMatrix *matrix_;
+  int numberActiveColumns_;
+  mutable int flags_;
+  ClpPackedMatrix2 *rowCopy_;
+  ClpPackedMatrix3 *columnCopy_;
+};
+class ClpPackedMatrix2 {
+public:
+  void transposeTimes(const ClpSimplex *model,
+    const CoinPackedMatrix *rowCopy,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *spareArray,
+    CoinIndexedVector *z) const;
+  inline bool usefulInfo() const
+  {
+    return rowStart_ != __null;
+  }
+  ClpPackedMatrix2();
+  ClpPackedMatrix2(ClpSimplex *model, const CoinPackedMatrix *rowCopy);
+  virtual ~ClpPackedMatrix2();
+  ClpPackedMatrix2(const ClpPackedMatrix2 &);
+  ClpPackedMatrix2 &operator=(const ClpPackedMatrix2 &);
+protected:
+  int numberBlocks_;
+  int numberRows_;
+  int *offset_;
+  mutable unsigned short *count_;
+  mutable CoinBigIndex *rowStart_;
+  unsigned short *column_;
+  double *work_;
+};
+typedef struct {
+  CoinBigIndex startElements_;
+  CoinBigIndex startRows_;
+  int startIndices_;
+  int numberInBlock_;
+  int numberScan_;
+  int firstAtLower_;
+  int firstAtUpper_;
+  int firstBasic_;
+  int numberElements_;
+  int numberOnes_;
+} blockStruct;
+class ClpPackedMatrix3 {
+public:
+  void transposeTimes(const ClpSimplex *model,
+    const double *pi,
+    CoinIndexedVector *output) const;
+  void transposeTimes(const ClpSimplex *model,
+    const double *pi,
+    CoinIndexedVector *output,
+    CoinIndexedVector *candidate,
+    const CoinIndexedVector *rowArray) const;
+  void transposeTimes2(const ClpSimplex *model,
+    const double *pi, CoinIndexedVector *dj1,
+    const double *piWeight,
+    double * infeas,
+    double * reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  ClpPackedMatrix3();
+  ClpPackedMatrix3(ClpSimplex *model, const CoinPackedMatrix *columnCopy);
+  virtual ~ClpPackedMatrix3();
+  ClpPackedMatrix3(const ClpPackedMatrix3 &);
+  ClpPackedMatrix3 &operator=(const ClpPackedMatrix3 &);
+  void sortBlocks(const ClpSimplex *model);
+  void swapOne(const ClpSimplex *model, const ClpPackedMatrix *matrix,
+    int iColumn);
+  void swapOne(int iBlock, int kA, int kB);
+  void checkBlocks(const ClpSimplex *model);
+  int redoInfeasibilities(const ClpSimplex *model,
+    ClpPrimalColumnSteepest *pivotChoose,
+    int type);
+protected:
+  int numberBlocks_;
+  int numberColumns_;
+  int numberColumnsWithGaps_;
+  CoinBigIndex numberElements_;
+  int maxBlockSize_;
+  int *column_;
+  CoinBigIndex *start_;
+  int *row_;
+  double *element_;
+  CoinDoubleArrayWithLength *temporary_;
+  blockStruct *block_;
+  int ifActive_;
+};
+class CoinOneMessage {
+public:
+  CoinOneMessage();
+  CoinOneMessage(int externalNumber, char detail,
+    const char *message);
+  ~CoinOneMessage();
+  CoinOneMessage(const CoinOneMessage &);
+  CoinOneMessage &operator=(const CoinOneMessage &);
+  void replaceMessage(const char *message);
+  inline int externalNumber() const
+  {
+    return externalNumber_;
+  }
+  inline void setExternalNumber(int number)
+  {
+    externalNumber_ = number;
+  }
+  inline char severity() const
+  {
+    return severity_;
+  }
+  inline void setDetail(int level)
+  {
+    detail_ = static_cast< char >(level);
+  }
+  inline int detail() const
+  {
+    return detail_;
+  }
+  inline char *message() const
+  {
+    return message_;
+  }
+  int externalNumber_;
+  char detail_;
+  char severity_;
+  mutable char message_[400];
+};
+class CoinMessages {
+public:
+  enum Language {
+    us_en = 0,
+    uk_en,
+    it
+  };
+  CoinMessages(int numberMessages = 0);
+  ~CoinMessages();
+  CoinMessages(const CoinMessages &);
+  CoinMessages &operator=(const CoinMessages &);
+  void addMessage(int messageNumber, const CoinOneMessage &message);
+  void replaceMessage(int messageNumber, const char *message);
+  inline Language language() const
+  {
+    return language_;
+  }
+  void setLanguage(Language newlanguage)
+  {
+    language_ = newlanguage;
+  }
+  void setDetailMessage(int newLevel, int messageNumber);
+  void setDetailMessages(int newLevel, int numberMessages,
+    int *messageNumbers);
+  void setDetailMessages(int newLevel, int low, int high);
+  inline int getClass() const
+  {
+    return class_;
+  }
+  void toCompact();
+  void fromCompact();
+  int numberMessages_;
+  Language language_;
+  char source_[5];
+  int class_;
+  int lengthMessages_;
+  CoinOneMessage **message_;
+};
+enum CoinMessageMarker {
+  CoinMessageEol = 0,
+  CoinMessageNewline = 1
+};
+class CoinMessageHandler {
+  friend bool CoinMessageHandlerUnitTest();
+public:
+  virtual int print();
+  virtual void checkSeverity();
+  CoinMessageHandler();
+  CoinMessageHandler(FILE *fp);
+  virtual ~CoinMessageHandler();
+  CoinMessageHandler(const CoinMessageHandler &);
+  CoinMessageHandler &operator=(const CoinMessageHandler &);
+  virtual CoinMessageHandler *clone() const;
+  inline int detail(int messageNumber, const CoinMessages &normalMessage) const
+  {
+    return normalMessage.message_[messageNumber]->detail();
+  }
+  inline int logLevel() const
+  {
+    return logLevel_;
+  }
+  void setLogLevel(int value);
+  inline int logLevel(int which) const
+  {
+    return logLevels_[which];
+  }
+  void setLogLevel(int which, int value);
+  void setPrecision(unsigned int new_precision);
+  inline int precision() { return (g_precision_); }
+  void setPrefix(bool yesNo);
+  bool prefix() const;
+  inline double doubleValue(int position) const
+  {
+    return doubleValue_[position];
+  }
+  inline int numberDoubleFields() const
+  {
+    return static_cast< int >(doubleValue_.size());
+  }
+  inline CoinBigIndex intValue(int position) const
+  {
+    return longValue_[position];
+  }
+  inline int numberIntFields() const
+  {
+    return static_cast< int >(longValue_.size());
+  }
+  inline char charValue(int position) const
+  {
+    return charValue_[position];
+  }
+  inline int numberCharFields() const
+  {
+    return static_cast< int >(charValue_.size());
+  }
+  inline std::string stringValue(int position) const
+  {
+    return stringValue_[position];
+  }
+  inline int numberStringFields() const
+  {
+    return static_cast< int >(stringValue_.size());
+  }
+  inline CoinOneMessage currentMessage() const
+  {
+    return currentMessage_;
+  }
+  inline std::string currentSource() const
+  {
+    return source_;
+  }
+  inline const char *messageBuffer() const
+  {
+    return messageBuffer_;
+  }
+  inline int highestNumber() const
+  {
+    return highestNumber_;
+  }
+  inline FILE *filePointer() const
+  {
+    return fp_;
+  }
+  inline void setFilePointer(FILE *fp)
+  {
+    fp_ = fp;
+  }
+  CoinMessageHandler &message(int messageNumber,
+    const CoinMessages &messages);
+  CoinMessageHandler &message(int detail = -1);
+  CoinMessageHandler &message(int externalNumber, const char *source,
+    const char *msg,
+    char severity, int detail = -1);
+  CoinMessageHandler &operator<<(int intvalue);
+  CoinMessageHandler &operator<<(double doublevalue);
+  CoinMessageHandler &operator<<(const std::string &stringvalue);
+  CoinMessageHandler &operator<<(char charvalue);
+  CoinMessageHandler &operator<<(const char *stringvalue);
+  CoinMessageHandler &operator<<(CoinMessageMarker);
+  int finish();
+  CoinMessageHandler &printing(bool onOff);
+protected:
+  std::vector< double > doubleValue_;
+  std::vector< CoinBigIndex > longValue_;
+  std::vector< char > charValue_;
+  std::vector< std::string > stringValue_;
+  int logLevel_;
+  int logLevels_[4];
+  int prefix_;
+  CoinOneMessage currentMessage_;
+  int internalNumber_;
+  char *format_;
+  char messageBuffer_[1000];
+  char *messageOut_;
+  std::string source_;
+  int printStatus_;
+  int highestNumber_;
+  FILE *fp_;
+  char g_format_[8];
+  int g_precision_;
+private:
+  void gutsOfCopy(const CoinMessageHandler &rhs);
+  char *nextPerCent(char *start, const bool initial = false);
+  int internalPrint();
+  void calcPrintStatus(int msglvl, int msgclass);
+};
+bool CoinMessageHandlerUnitTest();
+extern "C" {
+typedef __socklen_t socklen_t;
+extern int access (const char *__name, int __type) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int euidaccess (const char *__name, int __type)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int eaccess (const char *__name, int __type)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int execveat (int __fd, const char *__path, char *const __argv[],
+                     char *const __envp[], int __flags)
+    noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
+extern int faccessat (int __fd, const char *__file, int __type, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
+extern __off_t lseek (int __fd, __off_t __offset, int __whence) noexcept (true);
+extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
+     noexcept (true);
+extern int close (int __fd);
+extern void closefrom (int __lowfd) noexcept (true);
+extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
+                                                  ;
+extern ssize_t write (int __fd, const void *__buf, size_t __n)
+                                         ;
+extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
+        __off_t __offset)
+                                                  ;
+extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
+         __off_t __offset)
+                                         ;
+extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
+   __off64_t __offset)
+                                                  ;
+extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
+    __off64_t __offset)
+                                         ;
+extern int pipe (int __pipedes[2]) noexcept (true) ;
+extern int pipe2 (int __pipedes[2], int __flags) noexcept (true) ;
+extern unsigned int alarm (unsigned int __seconds) noexcept (true);
+extern unsigned int sleep (unsigned int __seconds);
+extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
+     noexcept (true);
+extern int usleep (__useconds_t __useconds);
+extern int pause (void);
+extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchown (int __fd, __uid_t __owner, __gid_t __group) noexcept (true) ;
+extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchownat (int __fd, const char *__file, __uid_t __owner,
+       __gid_t __group, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
+extern int chdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchdir (int __fd) noexcept (true) ;
+extern char *getcwd (char *__buf, size_t __size) noexcept (true) ;
+extern char *get_current_dir_name (void) noexcept (true);
+extern char *getwd (char *__buf)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
+                                       ;
+extern int dup (int __fd) noexcept (true) ;
+extern int dup2 (int __fd, int __fd2) noexcept (true);
+extern int dup3 (int __fd, int __fd2, int __flags) noexcept (true);
+extern char **__environ;
+extern char **environ;
+extern int execve (const char *__path, char *const __argv[],
+     char *const __envp[]) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
+     noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int execv (const char *__path, char *const __argv[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execle (const char *__path, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execl (const char *__path, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execvp (const char *__file, char *const __argv[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execlp (const char *__file, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execvpe (const char *__file, char *const __argv[],
+      char *const __envp[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int nice (int __inc) noexcept (true) ;
+extern void _exit (int __status) __attribute__ ((__noreturn__));
+enum
+  {
+    _PC_LINK_MAX,
+    _PC_MAX_CANON,
+    _PC_MAX_INPUT,
+    _PC_NAME_MAX,
+    _PC_PATH_MAX,
+    _PC_PIPE_BUF,
+    _PC_CHOWN_RESTRICTED,
+    _PC_NO_TRUNC,
+    _PC_VDISABLE,
+    _PC_SYNC_IO,
+    _PC_ASYNC_IO,
+    _PC_PRIO_IO,
+    _PC_SOCK_MAXBUF,
+    _PC_FILESIZEBITS,
+    _PC_REC_INCR_XFER_SIZE,
+    _PC_REC_MAX_XFER_SIZE,
+    _PC_REC_MIN_XFER_SIZE,
+    _PC_REC_XFER_ALIGN,
+    _PC_ALLOC_SIZE_MIN,
+    _PC_SYMLINK_MAX,
+    _PC_2_SYMLINKS
+  };
+enum
+  {
+    _SC_ARG_MAX,
+    _SC_CHILD_MAX,
+    _SC_CLK_TCK,
+    _SC_NGROUPS_MAX,
+    _SC_OPEN_MAX,
+    _SC_STREAM_MAX,
+    _SC_TZNAME_MAX,
+    _SC_JOB_CONTROL,
+    _SC_SAVED_IDS,
+    _SC_REALTIME_SIGNALS,
+    _SC_PRIORITY_SCHEDULING,
+    _SC_TIMERS,
+    _SC_ASYNCHRONOUS_IO,
+    _SC_PRIORITIZED_IO,
+    _SC_SYNCHRONIZED_IO,
+    _SC_FSYNC,
+    _SC_MAPPED_FILES,
+    _SC_MEMLOCK,
+    _SC_MEMLOCK_RANGE,
+    _SC_MEMORY_PROTECTION,
+    _SC_MESSAGE_PASSING,
+    _SC_SEMAPHORES,
+    _SC_SHARED_MEMORY_OBJECTS,
+    _SC_AIO_LISTIO_MAX,
+    _SC_AIO_MAX,
+    _SC_AIO_PRIO_DELTA_MAX,
+    _SC_DELAYTIMER_MAX,
+    _SC_MQ_OPEN_MAX,
+    _SC_MQ_PRIO_MAX,
+    _SC_VERSION,
+    _SC_PAGESIZE,
+    _SC_RTSIG_MAX,
+    _SC_SEM_NSEMS_MAX,
+    _SC_SEM_VALUE_MAX,
+    _SC_SIGQUEUE_MAX,
+    _SC_TIMER_MAX,
+    _SC_BC_BASE_MAX,
+    _SC_BC_DIM_MAX,
+    _SC_BC_SCALE_MAX,
+    _SC_BC_STRING_MAX,
+    _SC_COLL_WEIGHTS_MAX,
+    _SC_EQUIV_CLASS_MAX,
+    _SC_EXPR_NEST_MAX,
+    _SC_LINE_MAX,
+    _SC_RE_DUP_MAX,
+    _SC_CHARCLASS_NAME_MAX,
+    _SC_2_VERSION,
+    _SC_2_C_BIND,
+    _SC_2_C_DEV,
+    _SC_2_FORT_DEV,
+    _SC_2_FORT_RUN,
+    _SC_2_SW_DEV,
+    _SC_2_LOCALEDEF,
+    _SC_PII,
+    _SC_PII_XTI,
+    _SC_PII_SOCKET,
+    _SC_PII_INTERNET,
+    _SC_PII_OSI,
+    _SC_POLL,
+    _SC_SELECT,
+    _SC_UIO_MAXIOV,
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+    _SC_PII_INTERNET_STREAM,
+    _SC_PII_INTERNET_DGRAM,
+    _SC_PII_OSI_COTS,
+    _SC_PII_OSI_CLTS,
+    _SC_PII_OSI_M,
+    _SC_T_IOV_MAX,
+    _SC_THREADS,
+    _SC_THREAD_SAFE_FUNCTIONS,
+    _SC_GETGR_R_SIZE_MAX,
+    _SC_GETPW_R_SIZE_MAX,
+    _SC_LOGIN_NAME_MAX,
+    _SC_TTY_NAME_MAX,
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+    _SC_THREAD_KEYS_MAX,
+    _SC_THREAD_STACK_MIN,
+    _SC_THREAD_THREADS_MAX,
+    _SC_THREAD_ATTR_STACKADDR,
+    _SC_THREAD_ATTR_STACKSIZE,
+    _SC_THREAD_PRIORITY_SCHEDULING,
+    _SC_THREAD_PRIO_INHERIT,
+    _SC_THREAD_PRIO_PROTECT,
+    _SC_THREAD_PROCESS_SHARED,
+    _SC_NPROCESSORS_CONF,
+    _SC_NPROCESSORS_ONLN,
+    _SC_PHYS_PAGES,
+    _SC_AVPHYS_PAGES,
+    _SC_ATEXIT_MAX,
+    _SC_PASS_MAX,
+    _SC_XOPEN_VERSION,
+    _SC_XOPEN_XCU_VERSION,
+    _SC_XOPEN_UNIX,
+    _SC_XOPEN_CRYPT,
+    _SC_XOPEN_ENH_I18N,
+    _SC_XOPEN_SHM,
+    _SC_2_CHAR_TERM,
+    _SC_2_C_VERSION,
+    _SC_2_UPE,
+    _SC_XOPEN_XPG2,
+    _SC_XOPEN_XPG3,
+    _SC_XOPEN_XPG4,
+    _SC_CHAR_BIT,
+    _SC_CHAR_MAX,
+    _SC_CHAR_MIN,
+    _SC_INT_MAX,
+    _SC_INT_MIN,
+    _SC_LONG_BIT,
+    _SC_WORD_BIT,
+    _SC_MB_LEN_MAX,
+    _SC_NZERO,
+    _SC_SSIZE_MAX,
+    _SC_SCHAR_MAX,
+    _SC_SCHAR_MIN,
+    _SC_SHRT_MAX,
+    _SC_SHRT_MIN,
+    _SC_UCHAR_MAX,
+    _SC_UINT_MAX,
+    _SC_ULONG_MAX,
+    _SC_USHRT_MAX,
+    _SC_NL_ARGMAX,
+    _SC_NL_LANGMAX,
+    _SC_NL_MSGMAX,
+    _SC_NL_NMAX,
+    _SC_NL_SETMAX,
+    _SC_NL_TEXTMAX,
+    _SC_XBS5_ILP32_OFF32,
+    _SC_XBS5_ILP32_OFFBIG,
+    _SC_XBS5_LP64_OFF64,
+    _SC_XBS5_LPBIG_OFFBIG,
+    _SC_XOPEN_LEGACY,
+    _SC_XOPEN_REALTIME,
+    _SC_XOPEN_REALTIME_THREADS,
+    _SC_ADVISORY_INFO,
+    _SC_BARRIERS,
+    _SC_BASE,
+    _SC_C_LANG_SUPPORT,
+    _SC_C_LANG_SUPPORT_R,
+    _SC_CLOCK_SELECTION,
+    _SC_CPUTIME,
+    _SC_THREAD_CPUTIME,
+    _SC_DEVICE_IO,
+    _SC_DEVICE_SPECIFIC,
+    _SC_DEVICE_SPECIFIC_R,
+    _SC_FD_MGMT,
+    _SC_FIFO,
+    _SC_PIPE,
+    _SC_FILE_ATTRIBUTES,
+    _SC_FILE_LOCKING,
+    _SC_FILE_SYSTEM,
+    _SC_MONOTONIC_CLOCK,
+    _SC_MULTI_PROCESS,
+    _SC_SINGLE_PROCESS,
+    _SC_NETWORKING,
+    _SC_READER_WRITER_LOCKS,
+    _SC_SPIN_LOCKS,
+    _SC_REGEXP,
+    _SC_REGEX_VERSION,
+    _SC_SHELL,
+    _SC_SIGNALS,
+    _SC_SPAWN,
+    _SC_SPORADIC_SERVER,
+    _SC_THREAD_SPORADIC_SERVER,
+    _SC_SYSTEM_DATABASE,
+    _SC_SYSTEM_DATABASE_R,
+    _SC_TIMEOUTS,
+    _SC_TYPED_MEMORY_OBJECTS,
+    _SC_USER_GROUPS,
+    _SC_USER_GROUPS_R,
+    _SC_2_PBS,
+    _SC_2_PBS_ACCOUNTING,
+    _SC_2_PBS_LOCATE,
+    _SC_2_PBS_MESSAGE,
+    _SC_2_PBS_TRACK,
+    _SC_SYMLOOP_MAX,
+    _SC_STREAMS,
+    _SC_2_PBS_CHECKPOINT,
+    _SC_V6_ILP32_OFF32,
+    _SC_V6_ILP32_OFFBIG,
+    _SC_V6_LP64_OFF64,
+    _SC_V6_LPBIG_OFFBIG,
+    _SC_HOST_NAME_MAX,
+    _SC_TRACE,
+    _SC_TRACE_EVENT_FILTER,
+    _SC_TRACE_INHERIT,
+    _SC_TRACE_LOG,
+    _SC_LEVEL1_ICACHE_SIZE,
+    _SC_LEVEL1_ICACHE_ASSOC,
+    _SC_LEVEL1_ICACHE_LINESIZE,
+    _SC_LEVEL1_DCACHE_SIZE,
+    _SC_LEVEL1_DCACHE_ASSOC,
+    _SC_LEVEL1_DCACHE_LINESIZE,
+    _SC_LEVEL2_CACHE_SIZE,
+    _SC_LEVEL2_CACHE_ASSOC,
+    _SC_LEVEL2_CACHE_LINESIZE,
+    _SC_LEVEL3_CACHE_SIZE,
+    _SC_LEVEL3_CACHE_ASSOC,
+    _SC_LEVEL3_CACHE_LINESIZE,
+    _SC_LEVEL4_CACHE_SIZE,
+    _SC_LEVEL4_CACHE_ASSOC,
+    _SC_LEVEL4_CACHE_LINESIZE,
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+    _SC_RAW_SOCKETS,
+    _SC_V7_ILP32_OFF32,
+    _SC_V7_ILP32_OFFBIG,
+    _SC_V7_LP64_OFF64,
+    _SC_V7_LPBIG_OFFBIG,
+    _SC_SS_REPL_MAX,
+    _SC_TRACE_EVENT_NAME_MAX,
+    _SC_TRACE_NAME_MAX,
+    _SC_TRACE_SYS_MAX,
+    _SC_TRACE_USER_EVENT_MAX,
+    _SC_XOPEN_STREAMS,
+    _SC_THREAD_ROBUST_PRIO_INHERIT,
+    _SC_THREAD_ROBUST_PRIO_PROTECT,
+    _SC_MINSIGSTKSZ,
+    _SC_SIGSTKSZ
+  };
+enum
+  {
+    _CS_PATH,
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+    _CS_GNU_LIBC_VERSION,
+    _CS_GNU_LIBPTHREAD_VERSION,
+    _CS_V5_WIDTH_RESTRICTED_ENVS,
+    _CS_V7_WIDTH_RESTRICTED_ENVS,
+    _CS_LFS_CFLAGS = 1000,
+    _CS_LFS_LDFLAGS,
+    _CS_LFS_LIBS,
+    _CS_LFS_LINTFLAGS,
+    _CS_LFS64_CFLAGS,
+    _CS_LFS64_LDFLAGS,
+    _CS_LFS64_LIBS,
+    _CS_LFS64_LINTFLAGS,
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+    _CS_XBS5_ILP32_OFF32_LIBS,
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+    _CS_XBS5_LP64_OFF64_LIBS,
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LIBS,
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LIBS,
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_V6_ENV,
+    _CS_V7_ENV
+  };
+extern long int pathconf (const char *__path, int __name)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern long int fpathconf (int __fd, int __name) noexcept (true);
+extern long int sysconf (int __name) noexcept (true);
+extern size_t confstr (int __name, char *__buf, size_t __len) noexcept (true)
+                                                  ;
+extern __pid_t getpid (void) noexcept (true);
+extern __pid_t getppid (void) noexcept (true);
+extern __pid_t getpgrp (void) noexcept (true);
+extern __pid_t __getpgid (__pid_t __pid) noexcept (true);
+extern __pid_t getpgid (__pid_t __pid) noexcept (true);
+extern int setpgid (__pid_t __pid, __pid_t __pgid) noexcept (true);
+extern int setpgrp (void) noexcept (true);
+extern __pid_t setsid (void) noexcept (true);
+extern __pid_t getsid (__pid_t __pid) noexcept (true);
+extern __uid_t getuid (void) noexcept (true);
+extern __uid_t geteuid (void) noexcept (true);
+extern __gid_t getgid (void) noexcept (true);
+extern __gid_t getegid (void) noexcept (true);
+extern int getgroups (int __size, __gid_t __list[]) noexcept (true)
+                                                  ;
+extern int group_member (__gid_t __gid) noexcept (true);
+extern int setuid (__uid_t __uid) noexcept (true) ;
+extern int setreuid (__uid_t __ruid, __uid_t __euid) noexcept (true) ;
+extern int seteuid (__uid_t __uid) noexcept (true) ;
+extern int setgid (__gid_t __gid) noexcept (true) ;
+extern int setregid (__gid_t __rgid, __gid_t __egid) noexcept (true) ;
+extern int setegid (__gid_t __gid) noexcept (true) ;
+extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
+     noexcept (true);
+extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
+     noexcept (true);
+extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
+     noexcept (true) ;
+extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
+     noexcept (true) ;
+extern __pid_t fork (void) noexcept (true);
+extern __pid_t vfork (void) noexcept (true);
+extern __pid_t _Fork (void) noexcept (true);
+extern char *ttyname (int __fd) noexcept (true);
+extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
+     noexcept (true) __attribute__ ((__nonnull__ (2)))
+                                                   ;
+extern int isatty (int __fd) noexcept (true);
+extern int ttyslot (void) noexcept (true);
+extern int link (const char *__from, const char *__to)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;
+extern int linkat (int __fromfd, const char *__from, int __tofd,
+     const char *__to, int __flags)
+     noexcept (true) __attribute__ ((__nonnull__ (2, 4))) ;
+extern int symlink (const char *__from, const char *__to)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;
+extern ssize_t readlink (const char *__restrict __path,
+    char *__restrict __buf, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
+                                                   ;
+extern int symlinkat (const char *__from, int __tofd,
+        const char *__to) noexcept (true) __attribute__ ((__nonnull__ (1, 3))) ;
+extern ssize_t readlinkat (int __fd, const char *__restrict __path,
+      char *__restrict __buf, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (2, 3)))
+                                                   ;
+extern int unlink (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int unlinkat (int __fd, const char *__name, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int rmdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern __pid_t tcgetpgrp (int __fd) noexcept (true);
+extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) noexcept (true);
+extern char *getlogin (void);
+extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
+                                                  ;
+extern int setlogin (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern "C" {
+extern char *optarg;
+extern int optind;
+extern int opterr;
+extern int optopt;
+extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
+       noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
+}
+
+extern "C" {
+}
+extern int gethostname (char *__name, size_t __len) noexcept (true) __attribute__ ((__nonnull__ (1)))
+                                                  ;
+extern int sethostname (const char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int sethostid (long int __id) noexcept (true) ;
+extern int getdomainname (char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1)))
+                                                   ;
+extern int setdomainname (const char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int vhangup (void) noexcept (true);
+extern int revoke (const char *__file) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int profil (unsigned short int *__sample_buffer, size_t __size,
+     size_t __offset, unsigned int __scale)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int acct (const char *__name) noexcept (true);
+extern char *getusershell (void) noexcept (true);
+extern void endusershell (void) noexcept (true);
+extern void setusershell (void) noexcept (true);
+extern int daemon (int __nochdir, int __noclose) noexcept (true) ;
+extern int chroot (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));
+extern int fsync (int __fd);
+extern int syncfs (int __fd) noexcept (true);
+extern long int gethostid (void);
+extern void sync (void) noexcept (true);
+extern int getpagesize (void) noexcept (true) __attribute__ ((__const__));
+extern int getdtablesize (void) noexcept (true);
+extern int truncate (const char *__file, __off_t __length)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int truncate64 (const char *__file, __off64_t __length)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int ftruncate (int __fd, __off_t __length) noexcept (true) ;
+extern int ftruncate64 (int __fd, __off64_t __length) noexcept (true) ;
+extern int brk (void *__addr) noexcept (true) ;
+extern void *sbrk (intptr_t __delta) noexcept (true);
+extern long int syscall (long int __sysno, ...) noexcept (true);
+extern int lockf (int __fd, int __cmd, __off_t __len) ;
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
+ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
+    int __outfd, __off64_t *__poutoff,
+    size_t __length, unsigned int __flags);
+extern int fdatasync (int __fildes);
+extern char *crypt (const char *__key, const char *__salt)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern void swab (const void *__restrict __from, void *__restrict __to,
+    ssize_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
+                                          ;
+int getentropy (void *__buffer, size_t __length)
+                                          ;
+extern int close_range (unsigned int __fd, unsigned int __max_fd,
+   int __flags) noexcept (true);
+extern __pid_t gettid (void) noexcept (true);
+
+}
+template < class T >
+inline void
+CoinCopyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+  CoinBigIndex n = (size + 7) / 8;
+  if (to > from) {
+    const T *downfrom = from + size;
+    T *downto = to + size;
+    switch (size % 8) {
+    case 0:
+      do {
+        *--downto = *--downfrom;
+      case 7:
+        *--downto = *--downfrom;
+      case 6:
+        *--downto = *--downfrom;
+      case 5:
+        *--downto = *--downfrom;
+      case 4:
+        *--downto = *--downfrom;
+      case 3:
+        *--downto = *--downfrom;
+      case 2:
+        *--downto = *--downfrom;
+      case 1:
+        *--downto = *--downfrom;
+      } while (--n > 0);
+    }
+  } else {
+    --from;
+    --to;
+    switch (size % 8) {
+    case 0:
+      do {
+        *++to = *++from;
+      case 7:
+        *++to = *++from;
+      case 6:
+        *++to = *++from;
+      case 5:
+        *++to = *++from;
+      case 4:
+        *++to = *++from;
+      case 3:
+        *++to = *++from;
+      case 2:
+        *++to = *++from;
+      case 1:
+        *++to = *++from;
+      } while (--n > 0);
+    }
+  }
+}
+template < class T >
+inline void
+CoinCopy(const T *first, const T *last, T *to)
+{
+  CoinCopyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline void
+CoinDisjointCopyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, from += 8, to += 8) {
+    to[0] = from[0];
+    to[1] = from[1];
+    to[2] = from[2];
+    to[3] = from[3];
+    to[4] = from[4];
+    to[5] = from[5];
+    to[6] = from[6];
+    to[7] = from[7];
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = from[6];
+  case 6:
+    to[5] = from[5];
+  case 5:
+    to[4] = from[4];
+  case 4:
+    to[3] = from[3];
+  case 3:
+    to[2] = from[2];
+  case 2:
+    to[1] = from[1];
+  case 1:
+    to[0] = from[0];
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinDisjointCopy(const T *first, const T *last,
+  T *to)
+{
+  CoinDisjointCopyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline T *
+CoinCopyOfArray(const T *array, const CoinBigIndex size)
+{
+  if (array) {
+    T *arrayNew = new T[size];
+    std::memcpy(arrayNew, array, size * sizeof(T));
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+template < class T >
+inline T *
+CoinCopyOfArrayPartial(const T *array, const CoinBigIndex size, const CoinBigIndex copySize)
+{
+  if (array || size) {
+    T *arrayNew = new T[size];
+    (static_cast<void> (0));
+    std::memcpy(arrayNew, array, copySize * sizeof(T));
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+template < class T >
+inline T *
+CoinCopyOfArray(const T *array, const CoinBigIndex size, T value)
+{
+  T *arrayNew = new T[size];
+  if (array) {
+    std::memcpy(arrayNew, array, size * sizeof(T));
+  } else {
+    CoinBigIndex i;
+    for (i = 0; i < size; i++)
+      arrayNew[i] = value;
+  }
+  return arrayNew;
+}
+template < class T >
+inline T *
+CoinCopyOfArrayOrZero(const T *array, const CoinBigIndex size)
+{
+  T *arrayNew = new T[size];
+  if (array) {
+    std::memcpy(arrayNew, array, size * sizeof(T));
+  } else {
+    std::memset(arrayNew, 0, size * sizeof(T));
+  }
+  return arrayNew;
+}
+template < class T >
+inline void
+CoinMemcpyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+    for (CoinBigIndex n = static_cast<CoinBigIndex>(size>>3); n > 0; --n, from += 8, to += 8) {
+    to[0] = from[0];
+    to[1] = from[1];
+    to[2] = from[2];
+    to[3] = from[3];
+    to[4] = from[4];
+    to[5] = from[5];
+    to[6] = from[6];
+    to[7] = from[7];
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = from[6];
+  case 6:
+    to[5] = from[5];
+  case 5:
+    to[4] = from[4];
+  case 4:
+    to[3] = from[3];
+  case 3:
+    to[2] = from[2];
+  case 2:
+    to[1] = from[1];
+  case 1:
+    to[0] = from[0];
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinMemcpy(const T *first, const T *last,
+  T *to)
+{
+  CoinMemcpyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline void
+CoinFillN(T *to, const CoinBigIndex size, const T value)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, to += 8) {
+    to[0] = value;
+    to[1] = value;
+    to[2] = value;
+    to[3] = value;
+    to[4] = value;
+    to[5] = value;
+    to[6] = value;
+    to[7] = value;
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = value;
+  case 6:
+    to[5] = value;
+  case 5:
+    to[4] = value;
+  case 4:
+    to[3] = value;
+  case 3:
+    to[2] = value;
+  case 2:
+    to[1] = value;
+  case 1:
+    to[0] = value;
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinFill(T *first, T *last, const T value)
+{
+  CoinFillN(first, last - first, value);
+}
+template < class T >
+inline void
+CoinZeroN(T *to, const CoinBigIndex size)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, to += 8) {
+    to[0] = 0;
+    to[1] = 0;
+    to[2] = 0;
+    to[3] = 0;
+    to[4] = 0;
+    to[5] = 0;
+    to[6] = 0;
+    to[7] = 0;
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = 0;
+  case 6:
+    to[5] = 0;
+  case 5:
+    to[4] = 0;
+  case 4:
+    to[3] = 0;
+  case 3:
+    to[2] = 0;
+  case 2:
+    to[1] = 0;
+  case 1:
+    to[0] = 0;
+  case 0:
+    break;
+  }
+}
+inline void
+CoinCheckDoubleZero(double *to, const CoinBigIndex size)
+{
+  CoinBigIndex n = 0;
+  for (CoinBigIndex j = 0; j < size; j++) {
+    if (to[j])
+      n++;
+  }
+  if (n) {
+    printf("array of length %d should be zero has %d nonzero\n",
+      static_cast< int >(size), static_cast< int >(n));
+  }
+}
+inline void
+CoinCheckIntZero(int *to, const CoinBigIndex size)
+{
+  CoinBigIndex n = 0;
+  for (CoinBigIndex j = 0; j < size; j++) {
+    if (to[j])
+      n++;
+  }
+  if (n) {
+    printf("array of length %d should be zero has %d nonzero\n",
+      static_cast< int >(size),
+      static_cast< int >(n));
+  }
+}
+template < class T >
+inline void
+CoinZero(T *first, T *last)
+{
+  CoinZeroN(first, last - first);
+}
+inline char *CoinStrdup(const char *name)
+{
+  char *dup = __null;
+  if (name) {
+    const int len = static_cast< int >(strlen(name));
+    dup = static_cast< char * >(malloc(len + 1));
+    CoinMemcpyN(name, len, dup);
+    dup[len] = 0;
+  }
+  return dup;
+}
+template < class T >
+inline T
+CoinMax(const T x1, const T x2)
+{
+  return (x1 > x2) ? x1 : x2;
+}
+template < class T >
+inline T
+CoinMin(const T x1, const T x2)
+{
+  return (x1 < x2) ? x1 : x2;
+}
+template < class T >
+inline T
+CoinAbs(const T value)
+{
+  return value < 0 ? -value : value;
+}
+template < class T >
+inline bool
+CoinIsSorted(const T *first, const CoinBigIndex size)
+{
+  if (size == 0)
+    return true;
+  const CoinBigIndex size1 = size - 1;
+  for (CoinBigIndex n = size1 / 8; n > 0; --n, first += 8) {
+    if (first[8] < first[7])
+      return false;
+    if (first[7] < first[6])
+      return false;
+    if (first[6] < first[5])
+      return false;
+    if (first[5] < first[4])
+      return false;
+    if (first[4] < first[3])
+      return false;
+    if (first[3] < first[2])
+      return false;
+    if (first[2] < first[1])
+      return false;
+    if (first[1] < first[0])
+      return false;
+  }
+  switch (size1 % 8) {
+  case 7:
+    if (first[7] < first[6])
+      return false;
+  case 6:
+    if (first[6] < first[5])
+      return false;
+  case 5:
+    if (first[5] < first[4])
+      return false;
+  case 4:
+    if (first[4] < first[3])
+      return false;
+  case 3:
+    if (first[3] < first[2])
+      return false;
+  case 2:
+    if (first[2] < first[1])
+      return false;
+  case 1:
+    if (first[1] < first[0])
+      return false;
+  case 0:
+    break;
+  }
+  return true;
+}
+template < class T >
+inline bool
+CoinIsSorted(const T *first, const T *last)
+{
+  return CoinIsSorted(first, static_cast< CoinBigIndex >(last - first));
+}
+template < class T >
+inline void
+CoinIotaN(T *first, const CoinBigIndex size, T init)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, first += 8, init += 8) {
+    first[0] = init;
+    first[1] = init + 1;
+    first[2] = init + 2;
+    first[3] = init + 3;
+    first[4] = init + 4;
+    first[5] = init + 5;
+    first[6] = init + 6;
+    first[7] = init + 7;
+  }
+  switch (size % 8) {
+  case 7:
+    first[6] = init + 6;
+  case 6:
+    first[5] = init + 5;
+  case 5:
+    first[4] = init + 4;
+  case 4:
+    first[3] = init + 3;
+  case 3:
+    first[2] = init + 2;
+  case 2:
+    first[1] = init + 1;
+  case 1:
+    first[0] = init;
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinIota(T *first, const T *last, T init)
+{
+  CoinIotaN(first, last - first, init);
+}
+template < class T >
+inline T *
+CoinDeleteEntriesFromArray(T *arrayFirst, T *arrayLast,
+  const int *firstDelPos, const int *lastDelPos)
+{
+  CoinBigIndex delNum = static_cast< CoinBigIndex >(lastDelPos - firstDelPos);
+  if (delNum == 0)
+    return arrayLast;
+  if (delNum < 0)
+    throw CoinError("trying to delete negative number of entries",
+      "CoinDeleteEntriesFromArray", "");
+  int *delSortedPos = __null;
+  if (!(CoinIsSorted(firstDelPos, lastDelPos) && std::adjacent_find(firstDelPos, lastDelPos) == lastDelPos)) {
+    delSortedPos = new int[delNum];
+    CoinDisjointCopy(firstDelPos, lastDelPos, delSortedPos);
+    std::sort(delSortedPos, delSortedPos + delNum);
+    delNum = static_cast< CoinBigIndex >(std::unique(delSortedPos,
+                                           delSortedPos + delNum)
+      - delSortedPos);
+  }
+  const int *delSorted = delSortedPos ? delSortedPos : firstDelPos;
+  const CoinBigIndex last = delNum - 1;
+  int size = delSorted[0];
+  for (CoinBigIndex i = 0; i < last; ++i) {
+    const int copyFirst = delSorted[i] + 1;
+    const int copyLast = delSorted[i + 1];
+    CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
+      arrayFirst + size);
+    size += copyLast - copyFirst;
+  }
+  const int copyFirst = delSorted[last] + 1;
+  const int copyLast = static_cast< int >(arrayLast - arrayFirst);
+  CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
+    arrayFirst + size);
+  size += copyLast - copyFirst;
+  if (delSortedPos)
+    delete[] delSortedPos;
+  return arrayFirst + size;
+}
+inline double CoinDrand48(bool isSeed = false, unsigned int seed = 1)
+{
+  static unsigned int last = 123456;
+  if (isSeed) {
+    last = seed;
+  } else {
+    last = 1664525 * last + 1013904223;
+    return ((static_cast< double >(last)) / 4294967296.0);
+  }
+  return (0.0);
+}
+inline void CoinSeedRandom(int iseed)
+{
+  CoinDrand48(true, iseed);
+}
+inline char CoinFindDirSeparator()
+{
+  int size = 1000;
+  char *buf = 0;
+  while (true) {
+    buf = new char[size];
+    if (getcwd(buf, size))
+      break;
+    delete[] buf;
+    buf = 0;
+    size = 2 * size;
+  }
+  char dirsep = buf[0] == '/' ? '/' : '\\';
+  delete[] buf;
+  return dirsep;
+}
+inline int CoinStrNCaseCmp(const char *s0, const char *s1,
+  const size_t len)
+{
+  for (size_t i = 0; i < len; ++i) {
+    if (s0[i] == 0) {
+      return s1[i] == 0 ? 0 : -1;
+    }
+    if (s1[i] == 0) {
+      return 1;
+    }
+    const int c0 = std::tolower(s0[i]);
+    const int c1 = std::tolower(s1[i]);
+    if (c0 < c1)
+      return -1;
+    if (c0 > c1)
+      return 1;
+  }
+  return 0;
+}
+template < class T >
+inline void CoinSwap(T &x, T &y)
+{
+  T t = x;
+  x = y;
+  y = t;
+}
+template < class T >
+inline int
+CoinToFile(const T *array, CoinBigIndex size, FILE *fp)
+{
+  CoinBigIndex numberWritten;
+  if (array && size) {
+    numberWritten = static_cast< CoinBigIndex >(fwrite(&size, sizeof(int), 1, fp));
+    if (numberWritten != 1)
+      return 1;
+    numberWritten = static_cast< CoinBigIndex >(fwrite(array, sizeof(T), size_t(size), fp));
+    if (numberWritten != size)
+      return 1;
+  } else {
+    size = 0;
+    numberWritten = static_cast< CoinBigIndex >(fwrite(&size, sizeof(int), 1, fp));
+    if (numberWritten != 1)
+      return 1;
+  }
+  return 0;
+}
+template < class T >
+inline int
+CoinFromFile(T *&array, CoinBigIndex size, FILE *fp, CoinBigIndex &newSize)
+{
+  CoinBigIndex numberRead;
+  numberRead = static_cast< CoinBigIndex >(fread(&newSize, sizeof(int), 1, fp));
+  if (numberRead != 1)
+    return 1;
+  int returnCode = 0;
+  if (size != newSize && (newSize || array))
+    returnCode = 2;
+  if (newSize) {
+    array = new T[newSize];
+    numberRead = static_cast< CoinBigIndex >(fread(array, sizeof(T), newSize, fp));
+    if (numberRead != newSize)
+      returnCode = 1;
+  } else {
+    array = __null;
+  }
+  return returnCode;
+}
+inline int
+CoinStrlenAsInt(const char *string)
+{
+  return static_cast< int >(strlen(string));
+}
+class CoinThreadRandom {
+public:
+  CoinThreadRandom()
+  {
+    seed_ = 12345678;
+  }
+  CoinThreadRandom(int seed)
+  {
+    seed_ = seed;
+  }
+  ~CoinThreadRandom() {}
+  CoinThreadRandom(const CoinThreadRandom &rhs)
+  {
+    seed_ = rhs.seed_;
+  }
+  CoinThreadRandom &operator=(const CoinThreadRandom &rhs)
+  {
+    if (this != &rhs) {
+      seed_ = rhs.seed_;
+    }
+    return *this;
+  }
+  inline void setSeed(int seed)
+  {
+    seed_ = seed;
+  }
+  inline unsigned int getSeed() const
+  {
+    return seed_;
+  }
+  inline double randomDouble() const
+  {
+    double retVal;
+    seed_ = 1664525 * (seed_) + 1013904223;
+    retVal = ((static_cast< double >(seed_)) / 4294967296.0);
+    return retVal;
+  }
+  inline void randomize(int n = 0)
+  {
+    if (!n)
+      n = seed_ & 255;
+    for (int i = 0; i < n; i++)
+      randomDouble();
+  }
+protected:
+  mutable unsigned int seed_;
+};
+
+const double COIN_DBL_MIN = (std::numeric_limits< double >::min)();
+const double COIN_DBL_MAX = (std::numeric_limits< double >::max)();
+const int COIN_INT_MAX = (std::numeric_limits< int >::max)();
+const double COIN_INT_MAX_AS_DOUBLE = (std::numeric_limits< int >::max)();
+extern bool CoinFinite(double val);
+extern bool CoinIsnan(double val);
+enum ClpIntParam {
+  ClpMaxNumIteration = 0,
+  ClpMaxNumIterationHotStart,
+  ClpNameDiscipline,
+  ClpLastIntParam
+};
+enum ClpDblParam {
+  ClpDualObjectiveLimit,
+  ClpPrimalObjectiveLimit,
+  ClpDualTolerance,
+  ClpPrimalTolerance,
+  ClpObjOffset,
+  ClpMaxSeconds,
+  ClpMaxWallSeconds,
+  ClpPresolveTolerance,
+  ClpLastDblParam
+};
+enum ClpStrParam {
+  ClpProbName = 0,
+  ClpLastStrParam
+};
+template < class T >
+inline void
+ClpDisjointCopyN(const T *array, const CoinBigIndex size, T *newArray)
+{
+  memcpy(reinterpret_cast< void * >(newArray), array, size * sizeof(T));
+}
+template < class T >
+inline void
+ClpFillN(T *array, const CoinBigIndex size, T value)
+{
+  CoinBigIndex i;
+  for (i = 0; i < size; i++)
+    array[i] = value;
+}
+template < class T >
+inline T *
+ClpCopyOfArray(const T *array, const CoinBigIndex size, T value)
+{
+  T *arrayNew = new T[size];
+  if (array)
+    ClpDisjointCopyN(array, size, arrayNew);
+  else
+    ClpFillN(arrayNew, size, value);
+  return arrayNew;
+}
+template < class T >
+inline T *
+ClpCopyOfArray(const T *array, const CoinBigIndex size)
+{
+  if (array) {
+    T *arrayNew = new T[size];
+    ClpDisjointCopyN(array, size, arrayNew);
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+typedef struct {
+  int typeStruct;
+  int typeCall;
+  void *data;
+} ClpTrustedData;
+class ClpSimplex;
+class ClpModel;
+class ClpObjective {
+public:
+  virtual double *gradient(const ClpSimplex *model,
+    const double *solution,
+    double &offset, bool refresh,
+    int includeLinear = 2)
+    = 0;
+  virtual double reducedGradient(ClpSimplex *model, double *region,
+    bool useFeasibleCosts)
+    = 0;
+  virtual double stepLength(ClpSimplex *model,
+    const double *solution,
+    const double *change,
+    double maximumTheta,
+    double &currentObj,
+    double &predictedObj,
+    double &thetaObj)
+    = 0;
+  virtual double objectiveValue(const ClpSimplex *model, const double *solution) const = 0;
+  virtual void resize(int newNumberColumns) = 0;
+  virtual void deleteSome(int numberToDelete, const int *which) = 0;
+  virtual void reallyScale(const double *columnScale) = 0;
+  virtual int markNonlinear(char *which);
+  virtual void newXValues() {}
+  ClpObjective();
+  ClpObjective(const ClpObjective &);
+  ClpObjective &operator=(const ClpObjective &rhs);
+  virtual ~ClpObjective();
+  virtual ClpObjective *clone() const = 0;
+  virtual ClpObjective *subsetClone(int numberColumns,
+    const int *whichColumns) const;
+  inline int type() const
+  {
+    return type_;
+  }
+  inline void setType(int value)
+  {
+    type_ = value;
+  }
+  inline int activated() const
+  {
+    return activated_;
+  }
+  inline void setActivated(int value)
+  {
+    activated_ = value;
+  }
+  inline double nonlinearOffset() const
+  {
+    return offset_;
+  }
+protected:
+  double offset_;
+  int type_;
+  int activated_;
+};
+class ClpEventHandler;
+class CoinBuild;
+class CoinModel;
+class ClpModel {
+public:
+  ClpModel(bool emptyMessages = false);
+  ClpModel(const ClpModel &rhs, int scalingMode = -1);
+  ClpModel &operator=(const ClpModel &rhs);
+  ClpModel(const ClpModel *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true);
+  ~ClpModel();
+  void loadProblem(const ClpMatrixBase &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const CoinPackedMatrix &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  int loadProblem(CoinModel &modelObject, bool tryPlusMinusOne = false);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value, const int *length,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadQuadraticObjective(const int numberColumns,
+    const CoinBigIndex *start,
+    const int *column, const double *element);
+  void loadQuadraticObjective(const CoinPackedMatrix &matrix);
+  void deleteQuadraticObjective();
+  void setRowObjective(const double *rowObjective);
+  int readMps(const char *filename,
+    bool keepNames = false,
+    bool ignoreErrors = false);
+  int readGMPL(const char *filename, const char *dataName,
+    bool keepNames = false);
+  void copyInIntegerInformation(const char *information);
+  void deleteIntegerInformation();
+  void setContinuous(int index);
+  void setInteger(int index);
+  bool isInteger(int index) const;
+  void resize(int newNumberRows, int newNumberColumns);
+private:
+  void synchronizeMatrix();
+public:
+  void deleteRows(int number, const int *which);
+  void addRow(int numberInRow, const int *columns,
+    const double *elements, double rowLower = -COIN_DBL_MAX,
+    double rowUpper = COIN_DBL_MAX);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinBigIndex *rowStarts, const int *columns,
+    const double *elements);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinBigIndex *rowStarts, const int *rowLengths,
+    const int *columns,
+    const double *elements);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinPackedVectorBase *const *rows);
+  int addRows(const CoinBuild &buildObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  int addRows(CoinModel &modelObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  void deleteColumns(int number, const int *which);
+  void deleteRowsAndColumns(int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  void addColumn(int numberInColumn,
+    const int *rows,
+    const double *elements,
+    double columnLower = 0.0,
+    double columnUpper = COIN_DBL_MAX,
+    double objective = 0.0);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinBigIndex *columnStarts, const int *rows,
+    const double *elements);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinBigIndex *columnStarts, const int *columnLengths,
+    const int *rows,
+    const double *elements);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinPackedVectorBase *const *columns);
+  int addColumns(const CoinBuild &buildObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  int addColumns(CoinModel &modelObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  inline void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false)
+  {
+    matrix_->modifyCoefficient(row, column, newElement, keepZero);
+  }
+  void chgRowLower(const double *rowLower);
+  void chgRowUpper(const double *rowUpper);
+  void chgColumnLower(const double *columnLower);
+  void chgColumnUpper(const double *columnUpper);
+  void chgObjCoefficients(const double *objIn);
+  void borrowModel(ClpModel &otherModel);
+  void returnModel(ClpModel &otherModel);
+  void createEmptyMatrix();
+  CoinBigIndex cleanMatrix(double threshold = 1.0e-20);
+  void copy(const ClpMatrixBase *from, ClpMatrixBase *&to);
+  void dropNames();
+  void copyNames(const std::vector< std::string > &rowNames,
+    const std::vector< std::string > &columnNames);
+  void copyRowNames(const std::vector< std::string > &rowNames, int first, int last);
+  void copyColumnNames(const std::vector< std::string > &columnNames, int first, int last);
+  void copyRowNames(const char *const *rowNames, int first, int last);
+  void copyColumnNames(const char *const *columnNames, int first, int last);
+  void setRowName(int rowIndex, std::string &name);
+  void setColumnName(int colIndex, std::string &name);
+  int findNetwork(char *rotate, double fractionNeeded = 0.75);
+  CoinModel *createCoinModel() const;
+  int writeMps(const char *filename,
+    int formatType = 0, int numberAcross = 2,
+    double objSense = 0.0) const;
+  inline int numberRows() const
+  {
+    return numberRows_;
+  }
+  inline int getNumRows() const
+  {
+    return numberRows_;
+  }
+  inline int getNumCols() const
+  {
+    return numberColumns_;
+  }
+  inline int numberColumns() const
+  {
+    return numberColumns_;
+  }
+  inline double primalTolerance() const
+  {
+    return dblParam_[ClpPrimalTolerance];
+  }
+  void setPrimalTolerance(double value);
+  inline double dualTolerance() const
+  {
+    return dblParam_[ClpDualTolerance];
+  }
+  void setDualTolerance(double value);
+  inline double primalObjectiveLimit() const
+  {
+    return dblParam_[ClpPrimalObjectiveLimit];
+  }
+  void setPrimalObjectiveLimit(double value);
+  inline double dualObjectiveLimit() const
+  {
+    return dblParam_[ClpDualObjectiveLimit];
+  }
+  void setDualObjectiveLimit(double value);
+  inline double objectiveOffset() const
+  {
+    return dblParam_[ClpObjOffset];
+  }
+  void setObjectiveOffset(double value);
+  inline double presolveTolerance() const
+  {
+    return dblParam_[ClpPresolveTolerance];
+  }
+  inline const std::string &problemName() const
+  {
+    return strParam_[ClpProbName];
+  }
+  inline int numberIterations() const
+  {
+    return numberIterations_;
+  }
+  inline int getIterationCount() const
+  {
+    return numberIterations_;
+  }
+  inline void setNumberIterations(int numberIterationsNew)
+  {
+    numberIterations_ = numberIterationsNew;
+  }
+  inline int solveType() const
+  {
+    return solveType_;
+  }
+  inline void setSolveType(int type)
+  {
+    solveType_ = type;
+  }
+  inline int maximumIterations() const
+  {
+    return intParam_[ClpMaxNumIteration];
+  }
+  void setMaximumIterations(int value);
+  inline double maximumSeconds() const
+  {
+    return dblParam_[ClpMaxSeconds];
+  }
+  void setMaximumSeconds(double value);
+  void setMaximumWallSeconds(double value);
+  bool hitMaximumIterations() const;
+  inline int status() const
+  {
+    return problemStatus_;
+  }
+  inline int problemStatus() const
+  {
+    return problemStatus_;
+  }
+  inline void setProblemStatus(int problemStatusNew)
+  {
+    problemStatus_ = problemStatusNew;
+  }
+  inline int secondaryStatus() const
+  {
+    return secondaryStatus_;
+  }
+  inline void setSecondaryStatus(int newstatus)
+  {
+    secondaryStatus_ = newstatus;
+  }
+  inline bool isAbandoned() const
+  {
+    return problemStatus_ == 4;
+  }
+  inline bool isProvenOptimal() const
+  {
+    return problemStatus_ == 0;
+  }
+  inline bool isProvenPrimalInfeasible() const
+  {
+    return problemStatus_ == 1;
+  }
+  inline bool isProvenDualInfeasible() const
+  {
+    return problemStatus_ == 2;
+  }
+  bool isPrimalObjectiveLimitReached() const;
+  bool isDualObjectiveLimitReached() const;
+  inline bool isIterationLimitReached() const
+  {
+    return problemStatus_ == 3;
+  }
+  inline double optimizationDirection() const
+  {
+    return optimizationDirection_;
+  }
+  inline double getObjSense() const
+  {
+    return optimizationDirection_;
+  }
+  void setOptimizationDirection(double value);
+  inline double *primalRowSolution() const
+  {
+    return rowActivity_;
+  }
+  inline const double *getRowActivity() const
+  {
+    return rowActivity_;
+  }
+  inline double *primalColumnSolution() const
+  {
+    return columnActivity_;
+  }
+  inline const double *getColSolution() const
+  {
+    return columnActivity_;
+  }
+  inline void setColSolution(const double *input)
+  {
+    memcpy(columnActivity_, input, numberColumns_ * sizeof(double));
+  }
+  inline double *dualRowSolution() const
+  {
+    return dual_;
+  }
+  inline const double *getRowPrice() const
+  {
+    return dual_;
+  }
+  inline double *dualColumnSolution() const
+  {
+    return reducedCost_;
+  }
+  inline const double *getReducedCost() const
+  {
+    return reducedCost_;
+  }
+  inline double *rowLower() const
+  {
+    return rowLower_;
+  }
+  inline const double *getRowLower() const
+  {
+    return rowLower_;
+  }
+  inline double *rowUpper() const
+  {
+    return rowUpper_;
+  }
+  inline const double *getRowUpper() const
+  {
+    return rowUpper_;
+  }
+  void setObjectiveCoefficient(int elementIndex, double elementValue);
+  inline void setObjCoeff(int elementIndex, double elementValue)
+  {
+    setObjectiveCoefficient(elementIndex, elementValue);
+  }
+  void setColumnLower(int elementIndex, double elementValue);
+  void setColumnUpper(int elementIndex, double elementValue);
+  void setColumnBounds(int elementIndex,
+    double lower, double upper);
+  void setColumnSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline void setColLower(int elementIndex, double elementValue)
+  {
+    setColumnLower(elementIndex, elementValue);
+  }
+  inline void setColUpper(int elementIndex, double elementValue)
+  {
+    setColumnUpper(elementIndex, elementValue);
+  }
+  inline void setColBounds(int elementIndex,
+    double lower, double upper)
+  {
+    setColumnBounds(elementIndex, lower, upper);
+  }
+  inline void setColSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList)
+  {
+    setColumnSetBounds(indexFirst, indexLast, boundList);
+  }
+  void setRowLower(int elementIndex, double elementValue);
+  void setRowUpper(int elementIndex, double elementValue);
+  void setRowBounds(int elementIndex,
+    double lower, double upper);
+  void setRowSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline const double *rowScale() const
+  {
+    return rowScale_;
+  }
+  inline const double *columnScale() const
+  {
+    return columnScale_;
+  }
+  inline const double *inverseRowScale() const
+  {
+    return inverseRowScale_;
+  }
+  inline const double *inverseColumnScale() const
+  {
+    return inverseColumnScale_;
+  }
+  inline double *mutableRowScale() const
+  {
+    return rowScale_;
+  }
+  inline double *mutableColumnScale() const
+  {
+    return columnScale_;
+  }
+  inline double *mutableInverseRowScale() const
+  {
+    return inverseRowScale_;
+  }
+  inline double *mutableInverseColumnScale() const
+  {
+    return inverseColumnScale_;
+  }
+  inline double *swapRowScale(double *newScale)
+  {
+    double *oldScale = rowScale_;
+    rowScale_ = newScale;
+    return oldScale;
+  }
+  void setRowScale(double *scale);
+  void setColumnScale(double *scale);
+  inline double objectiveScale() const
+  {
+    return objectiveScale_;
+  }
+  inline void setObjectiveScale(double value)
+  {
+    objectiveScale_ = value;
+  }
+  inline double rhsScale() const
+  {
+    return rhsScale_;
+  }
+  inline void setRhsScale(double value)
+  {
+    rhsScale_ = value;
+  }
+  void scaling(int mode = 1);
+  void unscale();
+  inline int scalingFlag() const
+  {
+    return scalingFlag_;
+  }
+  inline double *objective() const
+  {
+    if (objective_) {
+      double offset;
+      return objective_->gradient(__null, __null, offset, false);
+    } else {
+      return __null;
+    }
+  }
+  inline double *objective(const double *solution, double &offset, bool refresh = true) const
+  {
+    offset = 0.0;
+    if (objective_) {
+      return objective_->gradient(__null, solution, offset, refresh);
+    } else {
+      return __null;
+    }
+  }
+  inline const double *getObjCoefficients() const
+  {
+    if (objective_) {
+      double offset;
+      return objective_->gradient(__null, __null, offset, false);
+    } else {
+      return __null;
+    }
+  }
+  inline double *rowObjective() const
+  {
+    return rowObjective_;
+  }
+  inline const double *getRowObjCoefficients() const
+  {
+    return rowObjective_;
+  }
+  inline double *columnLower() const
+  {
+    return columnLower_;
+  }
+  inline const double *getColLower() const
+  {
+    return columnLower_;
+  }
+  inline double *columnUpper() const
+  {
+    return columnUpper_;
+  }
+  inline const double *getColUpper() const
+  {
+    return columnUpper_;
+  }
+  inline CoinPackedMatrix *matrix() const
+  {
+    if (matrix_ == __null)
+      return __null;
+    else
+      return matrix_->getPackedMatrix();
+  }
+  inline CoinBigIndex getNumElements() const
+  {
+    return matrix_->getNumElements();
+  }
+  inline double getSmallElementValue() const
+  {
+    return smallElement_;
+  }
+  inline void setSmallElementValue(double value)
+  {
+    smallElement_ = value;
+  }
+  inline ClpMatrixBase *rowCopy() const
+  {
+    return rowCopy_;
+  }
+  void setNewRowCopy(ClpMatrixBase *newCopy);
+  inline ClpMatrixBase *clpMatrix() const
+  {
+    return matrix_;
+  }
+  inline ClpPackedMatrix *clpScaledMatrix() const
+  {
+    return scaledMatrix_;
+  }
+  inline void setClpScaledMatrix(ClpPackedMatrix *scaledMatrix)
+  {
+    delete scaledMatrix_;
+    scaledMatrix_ = scaledMatrix;
+  }
+  inline ClpPackedMatrix *swapScaledMatrix(ClpPackedMatrix *scaledMatrix)
+  {
+    ClpPackedMatrix *oldMatrix = scaledMatrix_;
+    scaledMatrix_ = scaledMatrix;
+    return oldMatrix;
+  }
+  void replaceMatrix(ClpMatrixBase *matrix, bool deleteCurrent = false);
+  inline void replaceMatrix(CoinPackedMatrix *newmatrix,
+    bool deleteCurrent = false)
+  {
+    replaceMatrix(new ClpPackedMatrix(newmatrix), deleteCurrent);
+  }
+  inline double objectiveValue() const
+  {
+    return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
+  }
+  inline void setObjectiveValue(double value)
+  {
+    objectiveValue_ = (value + dblParam_[ClpObjOffset]) / optimizationDirection_;
+  }
+  inline double getObjValue() const
+  {
+    return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
+  }
+  inline char *integerInformation() const
+  {
+    return integerType_;
+  }
+  double *infeasibilityRay(bool fullRay = false) const;
+  double *unboundedRay() const;
+  inline double *ray() const
+  {
+    return ray_;
+  }
+  inline bool rayExists() const
+  {
+    return (ray_ != __null);
+  }
+  inline void deleteRay()
+  {
+    delete[] ray_;
+    ray_ = __null;
+  }
+  inline const double *internalRay() const
+  {
+    return ray_;
+  }
+  inline bool statusExists() const
+  {
+    return (status_ != __null);
+  }
+  inline unsigned char *statusArray() const
+  {
+    return status_;
+  }
+  unsigned char *statusCopy() const;
+  void copyinStatus(const unsigned char *statusArray);
+  inline void setUserPointer(void *pointer)
+  {
+    userPointer_ = pointer;
+  }
+  inline void *getUserPointer() const
+  {
+    return userPointer_;
+  }
+  inline void setTrustedUserPointer(ClpTrustedData *pointer)
+  {
+    trustedUserPointer_ = pointer;
+  }
+  inline ClpTrustedData *getTrustedUserPointer() const
+  {
+    return trustedUserPointer_;
+  }
+  inline int whatsChanged() const
+  {
+    return whatsChanged_;
+  }
+  inline void setWhatsChanged(int value)
+  {
+    whatsChanged_ = value;
+  }
+  inline int numberThreads() const
+  {
+    return numberThreads_;
+  }
+  inline void setNumberThreads(int value)
+  {
+    numberThreads_ = value;
+  }
+  void passInMessageHandler(CoinMessageHandler *handler);
+  CoinMessageHandler *pushMessageHandler(CoinMessageHandler *handler,
+    bool &oldDefault);
+  void popMessageHandler(CoinMessageHandler *oldHandler, bool oldDefault);
+  void newLanguage(CoinMessages::Language language);
+  inline void setLanguage(CoinMessages::Language language)
+  {
+    newLanguage(language);
+  }
+  void setDefaultMessageHandler();
+  inline CoinMessageHandler *messageHandler() const
+  {
+    return handler_;
+  }
+  inline CoinMessages messages() const
+  {
+    return messages_;
+  }
+  inline CoinMessages *messagesPointer()
+  {
+    return &messages_;
+  }
+  inline CoinMessages coinMessages() const
+  {
+    return coinMessages_;
+  }
+  inline CoinMessages *coinMessagesPointer()
+  {
+    return &coinMessages_;
+  }
+  inline void setLogLevel(int value)
+  {
+    handler_->setLogLevel(value);
+  }
+  inline int logLevel() const
+  {
+    return handler_->logLevel();
+  }
+  inline bool defaultHandler() const
+  {
+    return defaultHandler_;
+  }
+  void passInEventHandler(const ClpEventHandler *eventHandler);
+  inline ClpEventHandler *eventHandler() const
+  {
+    return eventHandler_;
+  }
+  inline CoinThreadRandom *randomNumberGenerator()
+  {
+    return &randomNumberGenerator_;
+  }
+  inline CoinThreadRandom &mutableRandomNumberGenerator()
+  {
+    return randomNumberGenerator_;
+  }
+  inline void setRandomSeed(int value)
+  {
+    randomNumberGenerator_.setSeed(value);
+  }
+  inline int lengthNames() const
+  {
+    return lengthNames_;
+  }
+  inline void setLengthNames(int value)
+  {
+    lengthNames_ = value;
+  }
+  inline const std::vector< std::string > *rowNames() const
+  {
+    return &rowNames_;
+  }
+  inline const std::string &rowName(int iRow) const
+  {
+    return rowNames_[iRow];
+  }
+  std::string getRowName(int iRow) const;
+  inline const std::vector< std::string > *columnNames() const
+  {
+    return &columnNames_;
+  }
+  inline const std::string &columnName(int iColumn) const
+  {
+    return columnNames_[iColumn];
+  }
+  std::string getColumnName(int iColumn) const;
+  inline ClpObjective *objectiveAsObject() const
+  {
+    return objective_;
+  }
+  void setObjective(ClpObjective *objective);
+  inline void setObjectivePointer(ClpObjective *newobjective)
+  {
+    objective_ = newobjective;
+  }
+  int emptyProblem(int *infeasNumber = __null, double *infeasSum = __null, bool printMessage = true);
+  void times(double scalar,
+    const double *x, double *y) const;
+  void transposeTimes(double scalar,
+    const double *x, double *y) const;
+  bool setIntParam(ClpIntParam key, int value);
+  bool setDblParam(ClpDblParam key, double value);
+  bool setStrParam(ClpStrParam key, const std::string &value);
+  inline bool getIntParam(ClpIntParam key, int &value) const
+  {
+    if (key < ClpLastIntParam) {
+      value = intParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  inline bool getDblParam(ClpDblParam key, double &value) const
+  {
+    if (key < ClpLastDblParam) {
+      value = dblParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  inline bool getStrParam(ClpStrParam key, std::string &value) const
+  {
+    if (key < ClpLastStrParam) {
+      value = strParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  void generateCpp(FILE *fp);
+  inline unsigned int specialOptions() const
+  {
+    return specialOptions_;
+  }
+  void setSpecialOptions(unsigned int value);
+  inline bool inCbcBranchAndBound() const
+  {
+    return (specialOptions_ & 0x01000000) != 0;
+  }
+protected:
+  void gutsOfDelete(int type);
+  void gutsOfCopy(const ClpModel &rhs, int trueCopy = 1);
+  void getRowBound(int iRow, double &lower, double &upper) const;
+  void gutsOfLoadModel(int numberRows, int numberColumns,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void gutsOfScaling();
+  inline double rawObjectiveValue() const
+  {
+    return objectiveValue_;
+  }
+  inline bool permanentArrays() const
+  {
+    return (specialOptions_ & 65536) != 0;
+  }
+  void startPermanentArrays();
+  void stopPermanentArrays();
+  const char *const *rowNamesAsChar() const;
+  const char *const *columnNamesAsChar() const;
+  void deleteNamesAsChar(const char *const *names, int number) const;
+  void onStopped();
+protected:
+  double optimizationDirection_;
+  double dblParam_[ClpLastDblParam];
+  double objectiveValue_;
+  double smallElement_;
+  double objectiveScale_;
+  double rhsScale_;
+  int numberRows_;
+  int numberColumns_;
+  double *rowActivity_;
+  double *columnActivity_;
+  double *dual_;
+  double *reducedCost_;
+  double *rowLower_;
+  double *rowUpper_;
+  ClpObjective *objective_;
+  double *rowObjective_;
+  double *columnLower_;
+  double *columnUpper_;
+  ClpMatrixBase *matrix_;
+  ClpMatrixBase *rowCopy_;
+  ClpPackedMatrix *scaledMatrix_;
+  double *ray_;
+  double *rowScale_;
+  double *columnScale_;
+  double *inverseRowScale_;
+  double *inverseColumnScale_;
+  int scalingFlag_;
+  unsigned char *status_;
+  char *integerType_;
+  void *userPointer_;
+  ClpTrustedData *trustedUserPointer_;
+  int intParam_[ClpLastIntParam];
+  int numberIterations_;
+  int solveType_;
+  unsigned int whatsChanged_;
+  int problemStatus_;
+  int secondaryStatus_;
+  int lengthNames_;
+  int numberThreads_;
+  unsigned int specialOptions_;
+  CoinMessageHandler *handler_;
+  bool defaultHandler_;
+  CoinThreadRandom randomNumberGenerator_;
+  ClpEventHandler *eventHandler_;
+  std::vector< std::string > rowNames_;
+  std::vector< std::string > columnNames_;
+  CoinMessages messages_;
+  CoinMessages coinMessages_;
+  int maximumColumns_;
+  int maximumRows_;
+  int maximumInternalColumns_;
+  int maximumInternalRows_;
+  CoinPackedMatrix baseMatrix_;
+  CoinPackedMatrix baseRowCopy_;
+  double *savedRowScale_;
+  double *savedColumnScale_;
+  std::string strParam_[ClpLastStrParam];
+};
+class ClpDataSave {
+public:
+  ClpDataSave();
+  ClpDataSave(const ClpDataSave &);
+  ClpDataSave &operator=(const ClpDataSave &rhs);
+  ~ClpDataSave();
+public:
+  double dualBound_;
+  double infeasibilityCost_;
+  double pivotTolerance_;
+  double zeroFactorizationTolerance_;
+  double zeroSimplexTolerance_;
+  double acceptablePivot_;
+  double objectiveScale_;
+  int sparseThreshold_;
+  int perturbation_;
+  int forceFactorization_;
+  int scalingFlag_;
+  unsigned int specialOptions_;
+};
+
+class ClpSolve {
+public:
+  enum SolveType {
+    useDual = 0,
+    usePrimal,
+    usePrimalorSprint,
+    useBarrier,
+    useBarrierNoCross,
+    automatic,
+    tryDantzigWolfe,
+    tryBenders,
+    notImplemented
+  };
+  enum PresolveType {
+    presolveOn = 0,
+    presolveOff,
+    presolveNumber,
+    presolveNumberCost
+  };
+  ClpSolve();
+  ClpSolve(SolveType method, PresolveType presolveType,
+    int numberPasses, int options[6],
+    int extraInfo[6], int independentOptions[3]);
+  void generateCpp(FILE *fp);
+  ClpSolve(const ClpSolve &);
+  ClpSolve &operator=(const ClpSolve &rhs);
+  ~ClpSolve();
+  void setSpecialOption(int which, int value, int extraInfo = -1);
+  int getSpecialOption(int which) const;
+  void setSolveType(SolveType method, int extraInfo = -1);
+  SolveType getSolveType();
+  void setPresolveType(PresolveType amount, int extraInfo = -1);
+  PresolveType getPresolveType();
+  int getPresolvePasses() const;
+  int getExtraInfo(int which) const;
+  void setInfeasibleReturn(bool trueFalse);
+  inline bool infeasibleReturn() const
+  {
+    return independentOptions_[0] != 0;
+  }
+  inline bool doDual() const
+  {
+    return (independentOptions_[1] & 1) == 0;
+  }
+  inline void setDoDual(bool doDual_)
+  {
+    if (doDual_)
+      independentOptions_[1] &= ~1;
+    else
+      independentOptions_[1] |= 1;
+  }
+  inline bool doSingleton() const
+  {
+    return (independentOptions_[1] & 2) == 0;
+  }
+  inline void setDoSingleton(bool doSingleton_)
+  {
+    if (doSingleton_)
+      independentOptions_[1] &= ~2;
+    else
+      independentOptions_[1] |= 2;
+  }
+  inline bool doDoubleton() const
+  {
+    return (independentOptions_[1] & 4) == 0;
+  }
+  inline void setDoDoubleton(bool doDoubleton_)
+  {
+    if (doDoubleton_)
+      independentOptions_[1] &= ~4;
+    else
+      independentOptions_[1] |= 4;
+  }
+  inline bool doTripleton() const
+  {
+    return (independentOptions_[1] & 8) == 0;
+  }
+  inline void setDoTripleton(bool doTripleton_)
+  {
+    if (doTripleton_)
+      independentOptions_[1] &= ~8;
+    else
+      independentOptions_[1] |= 8;
+  }
+  inline bool doTighten() const
+  {
+    return (independentOptions_[1] & 16) == 0;
+  }
+  inline void setDoTighten(bool doTighten_)
+  {
+    if (doTighten_)
+      independentOptions_[1] &= ~16;
+    else
+      independentOptions_[1] |= 16;
+  }
+  inline bool doForcing() const
+  {
+    return (independentOptions_[1] & 32) == 0;
+  }
+  inline void setDoForcing(bool doForcing_)
+  {
+    if (doForcing_)
+      independentOptions_[1] &= ~32;
+    else
+      independentOptions_[1] |= 32;
+  }
+  inline bool doImpliedFree() const
+  {
+    return (independentOptions_[1] & 64) == 0;
+  }
+  inline void setDoImpliedFree(bool doImpliedfree)
+  {
+    if (doImpliedfree)
+      independentOptions_[1] &= ~64;
+    else
+      independentOptions_[1] |= 64;
+  }
+  inline bool doDupcol() const
+  {
+    return (independentOptions_[1] & 128) == 0;
+  }
+  inline void setDoDupcol(bool doDupcol_)
+  {
+    if (doDupcol_)
+      independentOptions_[1] &= ~128;
+    else
+      independentOptions_[1] |= 128;
+  }
+  inline bool doDuprow() const
+  {
+    return (independentOptions_[1] & 256) == 0;
+  }
+  inline void setDoDuprow(bool doDuprow_)
+  {
+    if (doDuprow_)
+      independentOptions_[1] &= ~256;
+    else
+      independentOptions_[1] |= 256;
+  }
+  inline bool doSingletonColumn() const
+  {
+    return (independentOptions_[1] & 512) == 0;
+  }
+  inline void setDoSingletonColumn(bool doSingleton_)
+  {
+    if (doSingleton_)
+      independentOptions_[1] &= ~512;
+    else
+      independentOptions_[1] |= 512;
+  }
+  inline bool doKillSmall() const
+  {
+    return (independentOptions_[1] & 8192) == 0;
+  }
+  inline void setDoKillSmall(bool doKill)
+  {
+    if (doKill)
+      independentOptions_[1] &= ~8192;
+    else
+      independentOptions_[1] |= 8192;
+  }
+  inline int presolveActions() const
+  {
+    return independentOptions_[1] & 0xffffff;
+  }
+  inline void setPresolveActions(int action)
+  {
+    independentOptions_[1] = (independentOptions_[1] & 0xff000000) | (action & 0xffffff);
+  }
+  inline int substitution() const
+  {
+    return independentOptions_[2];
+  }
+  inline void setSubstitution(int value)
+  {
+    independentOptions_[2] = value;
+  }
+  inline void setIndependentOption(int type, int value)
+  {
+    independentOptions_[type] = value;
+  }
+  inline int independentOption(int type) const
+  {
+    return independentOptions_[type];
+  }
+private:
+  SolveType method_;
+  PresolveType presolveType_;
+  int numberPasses_;
+  int options_[7];
+  int extraInfo_[7];
+  int independentOptions_[3];
+};
+class ClpSimplexProgress {
+public:
+  ClpSimplexProgress();
+  ClpSimplexProgress(ClpSimplex *model);
+  ClpSimplexProgress(const ClpSimplexProgress &);
+  ClpSimplexProgress &operator=(const ClpSimplexProgress &rhs);
+  ~ClpSimplexProgress();
+  void reset();
+  void fillFromModel(ClpSimplex *model);
+  int looping();
+  void startCheck();
+  int cycle(int in, int out, int wayIn, int wayOut);
+  double lastObjective(int back = 1) const;
+  void setInfeasibility(double value);
+  double lastInfeasibility(int back = 1) const;
+  int numberInfeasibilities(int back = 1) const;
+  void modifyObjective(double value);
+  int lastIterationNumber(int back = 1) const;
+  void clearIterationNumbers();
+  inline void newOddState()
+  {
+    oddState_ = -oddState_ - 1;
+  }
+  inline void endOddState()
+  {
+    oddState_ = abs(oddState_);
+  }
+  inline void clearOddState()
+  {
+    oddState_ = 0;
+  }
+  inline int oddState() const
+  {
+    return oddState_;
+  }
+  inline int badTimes() const
+  {
+    return numberBadTimes_;
+  }
+  inline void clearBadTimes()
+  {
+    numberBadTimes_ = 0;
+  }
+  inline int reallyBadTimes() const
+  {
+    return numberReallyBadTimes_;
+  }
+  inline void incrementReallyBadTimes()
+  {
+    numberReallyBadTimes_++;
+  }
+  inline int timesFlagged() const
+  {
+    return numberTimesFlagged_;
+  }
+  inline void clearTimesFlagged()
+  {
+    numberTimesFlagged_ = 0;
+  }
+  inline void incrementTimesFlagged()
+  {
+    numberTimesFlagged_++;
+  }
+  double objective_[5];
+  double infeasibility_[5];
+  double realInfeasibility_[5];
+  double initialWeight_;
+  int in_[12];
+  int out_[12];
+  char way_[12];
+  ClpSimplex *model_;
+  int numberInfeasibilities_[5];
+  int iterationNumber_[5];
+  int numberTimes_;
+  int numberBadTimes_;
+  int numberReallyBadTimes_;
+  int numberTimesFlagged_;
+  int oddState_;
+};
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+  template<typename _Tp, typename _CharT = char,
+           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
+    class istream_iterator
+    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
+    {
+    public:
+      typedef _CharT char_type;
+      typedef _Traits traits_type;
+      typedef basic_istream<_CharT, _Traits> istream_type;
+    private:
+      istream_type* _M_stream;
+      _Tp _M_value;
+      bool _M_ok;
+    public:
+      constexpr istream_iterator()
+      noexcept(is_nothrow_default_constructible<_Tp>::value)
+      : _M_stream(0), _M_value(), _M_ok(false) {}
+      istream_iterator(istream_type& __s)
+      : _M_stream(std::__addressof(__s)), _M_ok(true)
+      { _M_read(); }
+      istream_iterator(const istream_iterator& __obj)
+      noexcept(is_nothrow_copy_constructible<_Tp>::value)
+      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
+        _M_ok(__obj._M_ok)
+      { }
+      istream_iterator& operator=(const istream_iterator&) = default;
+      ~istream_iterator() = default;
+      const _Tp&
+      operator*() const noexcept
+      {
+                        ;
+ return _M_value;
+      }
+      const _Tp*
+      operator->() const noexcept
+      { return std::__addressof((operator*())); }
+      istream_iterator&
+      operator++()
+      {
+                        ;
+ _M_read();
+ return *this;
+      }
+      istream_iterator
+      operator++(int)
+      {
+                        ;
+ istream_iterator __tmp = *this;
+ _M_read();
+ return __tmp;
+      }
+    private:
+      bool
+      _M_equal(const istream_iterator& __x) const noexcept
+      {
+ return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
+      }
+      void
+      _M_read()
+      {
+        if (_M_stream && !(*_M_stream >> _M_value))
+          {
+            _M_stream = 0;
+            _M_ok = false;
+          }
+      }
+      friend bool
+      operator==(const istream_iterator& __x, const istream_iterator& __y)
+      noexcept
+      { return __x._M_equal(__y); }
+      friend bool
+      operator!=(const istream_iterator& __x, const istream_iterator& __y)
+      noexcept
+      { return !__x._M_equal(__y); }
+    };
+  template<typename _Tp, typename _CharT = char,
+           typename _Traits = char_traits<_CharT> >
+    class ostream_iterator
+    : public iterator<output_iterator_tag, void, void, void, void>
+    {
+    public:
+      typedef _CharT char_type;
+      typedef _Traits traits_type;
+      typedef basic_ostream<_CharT, _Traits> ostream_type;
+    private:
+      ostream_type* _M_stream;
+      const _CharT* _M_string;
+    public:
+      ostream_iterator(ostream_type& __s) noexcept
+      : _M_stream(std::__addressof(__s)), _M_string(0) {}
+      ostream_iterator(ostream_type& __s, const _CharT* __c) noexcept
+      : _M_stream(std::__addressof(__s)), _M_string(__c) { }
+      ostream_iterator(const ostream_iterator& __obj) noexcept
+      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }
+      ostream_iterator& operator=(const ostream_iterator&) = default;
+      ostream_iterator&
+      operator=(const _Tp& __value)
+      {
+                        ;
+ *_M_stream << __value;
+ if (_M_string)
+          *_M_stream << _M_string;
+ return *this;
+      }
+      ostream_iterator&
+      operator*() noexcept
+      { return *this; }
+      ostream_iterator&
+      operator++() noexcept
+      { return *this; }
+      ostream_iterator&
+      operator++(int) noexcept
+      { return *this; }
+    };
+#pragma GCC diagnostic pop
+}
+template < class ForwardIterator, class Distance >
+void coinDistance(ForwardIterator first, ForwardIterator last,
+  Distance &n)
+{
+  n = std::distance(first, last);
+}
+template < class ForwardIterator >
+size_t coinDistance(ForwardIterator first, ForwardIterator last)
+{
+  size_t retVal;
+  retVal = std::distance(first, last);
+  return retVal;
+}
+template < class S, class T >
+struct CoinPair {
+public:
+  S first;
+  T second;
+public:
+  CoinPair(const S &s, const T &t)
+    : first(s)
+    , second(t)
+  {
+  }
+};
+template < class S, class T >
+class CoinFirstLess_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return t1.first < t2.first;
+  }
+};
+template < class S, class T >
+class CoinFirstGreater_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return t1.first > t2.first;
+  }
+};
+template < class S, class T >
+class CoinFirstAbsLess_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs < t2Abs;
+  }
+};
+template < class S, class T >
+class CoinFirstAbsGreater_2 {
+public:
+  inline bool operator()(CoinPair< S, T > t1, CoinPair< S, T > t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs > t2Abs;
+  }
+};
+template < class S, class T, class V >
+class CoinExternalVectorFirstLess_2 {
+private:
+  CoinExternalVectorFirstLess_2();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return vec_[t1.first] < vec_[t2.first];
+  }
+  CoinExternalVectorFirstLess_2(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class V >
+class CoinExternalVectorFirstGreater_2 {
+private:
+  CoinExternalVectorFirstGreater_2();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return vec_[t1.first] > vec_[t2.first];
+  }
+  CoinExternalVectorFirstGreater_2(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class CoinCompare2 >
+void CoinSort_2(S *sfirst, S *slast, T *tfirst, const CoinCompare2 &pc)
+{
+  const size_t len = coinDistance(sfirst, slast);
+  if (len <= 1)
+    return;
+  typedef CoinPair< S, T > ST_pair;
+  ST_pair *x = static_cast< ST_pair * >(::operator new(len * sizeof(ST_pair)));
+  size_t i = 0;
+  S *scurrent = sfirst;
+  T *tcurrent = tfirst;
+  while (scurrent != slast) {
+    new (x + i++) ST_pair(*scurrent++, *tcurrent++);
+  }
+  std::sort(x, x + len, pc);
+  scurrent = sfirst;
+  tcurrent = tfirst;
+  for (i = 0; i < len; ++i) {
+    *scurrent++ = x[i].first;
+    *tcurrent++ = x[i].second;
+  }
+  ::operator delete(x);
+}
+template < class S, class T >
+void
+CoinSort_2Std(S *sfirst, S *slast, T *tfirst)
+{
+  CoinSort_2(sfirst, slast, tfirst, CoinFirstLess_2< S, T >());
+}
+template < class S, class T >
+void CoinSort_2(S *sfirst, S *slast, T *tfirst)
+{
+  CoinSort_2(sfirst, slast, tfirst, CoinFirstLess_2< S, T >());
+}
+template < class S, class T >
+void CoinShortSort_2(S *key, S *lastKey, T *array2)
+{
+  const size_t number = coinDistance(key, lastKey);
+  if (number <= 2) {
+    if (number == 2 && key[0] > key[1]) {
+      S tempS = key[0];
+      T tempT = array2[0];
+      key[0] = key[1];
+      array2[0] = array2[1];
+      key[1] = tempS;
+      array2[1] = tempT;
+    }
+    return;
+  } else if (number > 10000) {
+    CoinSort_2Std(key, lastKey, array2);
+    return;
+  }
+  int minsize = 10;
+  size_t n = number;
+  int sp;
+  S *v = key;
+  S *m, t;
+  S *ls[32], *rs[32];
+  S *l, *r, c;
+  T it;
+  size_t j;
+  S last = key[0];
+  for (j = 1; j < n; j++) {
+    if (key[j] >= last) {
+      last = key[j];
+    } else {
+      break;
+    }
+  }
+  if (j == n) {
+    return;
+  }
+  sp = 0;
+  ls[sp] = v;
+  rs[sp] = v + (n - 1);
+  while (sp >= 0) {
+    if (rs[sp] - ls[sp] > minsize) {
+      l = ls[sp];
+      r = rs[sp];
+      m = l + (r - l) / 2;
+      if (*l > *m) {
+        t = *l;
+        *l = *m;
+        *m = t;
+        it = array2[l - v];
+        array2[l - v] = array2[m - v];
+        array2[m - v] = it;
+      }
+      if (*m > *r) {
+        t = *m;
+        *m = *r;
+        *r = t;
+        it = array2[m - v];
+        array2[m - v] = array2[r - v];
+        array2[r - v] = it;
+        if (*l > *m) {
+          t = *l;
+          *l = *m;
+          *m = t;
+          it = array2[l - v];
+          array2[l - v] = array2[m - v];
+          array2[m - v] = it;
+        }
+      }
+      c = *m;
+      while (r - l > 1) {
+        while (*(++l) < c)
+          ;
+        while (*(--r) > c)
+          ;
+        t = *l;
+        *l = *r;
+        *r = t;
+        it = array2[l - v];
+        array2[l - v] = array2[r - v];
+        array2[r - v] = it;
+      }
+      l = r - 1;
+      if (l < m) {
+        ls[sp + 1] = ls[sp];
+        rs[sp + 1] = l;
+        ls[sp] = r;
+      } else {
+        ls[sp + 1] = r;
+        rs[sp + 1] = rs[sp];
+        rs[sp] = l;
+      }
+      sp++;
+    } else
+      sp--;
+  }
+  for (l = v, m = v + (n - 1); l < m; l++) {
+    if (*l > *(l + 1)) {
+      c = *(l + 1);
+      it = array2[(l - v) + 1];
+      for (r = l; r >= v && *r > c; r--) {
+        *(r + 1) = *r;
+        array2[(r - v) + 1] = array2[(r - v)];
+      }
+      *(r + 1) = c;
+      array2[(r - v) + 1] = it;
+    }
+  }
+}
+template < class S, class T, class U >
+class CoinTriple {
+public:
+  S first;
+  T second;
+  U third;
+public:
+  CoinTriple(const S &s, const T &t, const U &u)
+    : first(s)
+    , second(t)
+    , third(u)
+  {
+  }
+};
+template < class S, class T, class U >
+class CoinFirstLess_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return t1.first < t2.first;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstGreater_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return t1.first > t2.first;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstAbsLess_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs < t2Abs;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstAbsGreater_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs > t2Abs;
+  }
+};
+template < class S, class T, class U, class V >
+class CoinExternalVectorFirstLess_3 {
+private:
+  CoinExternalVectorFirstLess_3();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return vec_[t1.first] < vec_[t2.first];
+  }
+  CoinExternalVectorFirstLess_3(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class U, class V >
+class CoinExternalVectorFirstGreater_3 {
+private:
+  CoinExternalVectorFirstGreater_3();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return vec_[t1.first] > vec_[t2.first];
+  }
+  CoinExternalVectorFirstGreater_3(const V *v)
+    : vec_(v)
+  {
+  }
+};
+typedef CoinExternalVectorFirstLess_3< int, int, double, double >
+  CoinIncrSolutionOrdered;
+typedef CoinExternalVectorFirstGreater_3< int, int, double, double >
+  CoinDecrSolutionOrdered;
+template < class S, class T, class U, class CoinCompare3 >
+void CoinSort_3(S *sfirst, S *slast, T *tfirst, U *ufirst, const CoinCompare3 &tc)
+{
+  const size_t len = coinDistance(sfirst, slast);
+  if (len <= 1)
+    return;
+  typedef CoinTriple< S, T, U > STU_triple;
+  STU_triple *x = static_cast< STU_triple * >(::operator new(len * sizeof(STU_triple)));
+  size_t i = 0;
+  S *scurrent = sfirst;
+  T *tcurrent = tfirst;
+  U *ucurrent = ufirst;
+  while (scurrent != slast) {
+    new (x + i++) STU_triple(*scurrent++, *tcurrent++, *ucurrent++);
+  }
+  std::sort(x, x + len, tc);
+  scurrent = sfirst;
+  tcurrent = tfirst;
+  ucurrent = ufirst;
+  for (i = 0; i < len; ++i) {
+    *scurrent++ = x[i].first;
+    *tcurrent++ = x[i].second;
+    *ucurrent++ = x[i].third;
+  }
+  ::operator delete(x);
+}
+template < class S, class T, class U >
+void CoinSort_3(S *sfirst, S *slast, T *tfirst, U *ufirst)
+{
+  CoinSort_3(sfirst, slast, tfirst, ufirst, CoinFirstLess_3< S, T, U >());
+}
+
+class CoinIndexedVector {
+  friend void CoinIndexedVectorUnitTest();
+public:
+  inline int getNumElements() const { return nElements_; }
+  inline const int *getIndices() const { return indices_; }
+  inline int *getIndices() { return indices_; }
+  inline double *denseVector() const { return elements_; }
+  inline void setDenseVector(double *array)
+  {
+    elements_ = array;
+  }
+  inline void setIndexVector(int *array)
+  {
+    indices_ = array;
+  }
+  double &operator[](int i) const;
+  inline void setNumElements(int value)
+  {
+    nElements_ = value;
+    if (!nElements_)
+      packedMode_ = false;
+  }
+  void clear();
+  void empty();
+  void reallyClear();
+  CoinIndexedVector &operator=(const CoinIndexedVector &);
+  CoinIndexedVector &operator=(const CoinPackedVectorBase &rhs);
+  void copy(const CoinIndexedVector &rhs, double multiplier = 1.0);
+  void borrowVector(int size, int numberIndices, int *inds, double *elems);
+  void returnVector();
+  void setVector(int numberIndices, const int *inds, const double *elems);
+  void setVector(int size, int numberIndices, const int *inds, const double *elems);
+  void setConstant(int size, const int *inds, double elems);
+  void setFull(int size, const double *elems);
+  void setElement(int index, double element);
+  void insert(int index, double element);
+  inline void quickInsert(int index, double element)
+  {
+    (static_cast<void> (0));
+    indices_[nElements_++] = index;
+    (static_cast<void> (0));
+    elements_[index] = element;
+  }
+  void add(int index, double element);
+  inline void quickAdd(int index, double element)
+  {
+    if (elements_[index]) {
+      element += elements_[index];
+      if ((element > 0 ? element : -element) >= 1.0e-50) {
+        elements_[index] = element;
+      } else {
+        elements_[index] = 1.0e-100;
+      }
+    } else if ((element > 0 ? element : -element) >= 1.0e-50) {
+      indices_[nElements_++] = index;
+      (static_cast<void> (0));
+      elements_[index] = element;
+    }
+  }
+  inline void quickAddNonZero(int index, double element)
+  {
+    (static_cast<void> (0));
+    if (elements_[index]) {
+      element += elements_[index];
+      if ((element > 0 ? element : -element) >= 1.0e-50) {
+        elements_[index] = element;
+      } else {
+        elements_[index] = COIN_DBL_MIN;
+      }
+    } else {
+      indices_[nElements_++] = index;
+      (static_cast<void> (0));
+      elements_[index] = element;
+    }
+  }
+  inline void zero(int index)
+  {
+    if (elements_[index])
+      elements_[index] = COIN_DBL_MIN;
+  }
+  int clean(double tolerance);
+  int cleanAndPack(double tolerance);
+  int cleanAndPackSafe(double tolerance);
+  inline void setPacked()
+  {
+    packedMode_ = true;
+  }
+  inline void checkClear() {};
+  inline void checkClean() {};
+  int scan();
+  int scan(int start, int end);
+  int scan(double tolerance);
+  int scan(int start, int end, double tolerance);
+  int scanAndPack();
+  int scanAndPack(int start, int end);
+  int scanAndPack(double tolerance);
+  int scanAndPack(int start, int end, double tolerance);
+  void createPacked(int number, const int *indices,
+    const double *elements);
+  void createUnpacked(int number, const int *indices,
+    const double *elements);
+  void createOneUnpackedElement(int index, double element);
+  void expand();
+  void append(const CoinPackedVectorBase &caboose);
+  void append(const CoinIndexedVector &caboose);
+  void append(CoinIndexedVector &other, int adjustIndex, bool zapElements = false);
+  void swap(int i, int j);
+  void truncate(int newSize);
+  void print() const;
+  void operator+=(double value);
+  void operator-=(double value);
+  void operator*=(double value);
+  void operator/=(double value);
+  bool operator==(const CoinPackedVectorBase &rhs) const;
+  bool operator!=(const CoinPackedVectorBase &rhs) const;
+  bool operator==(const CoinIndexedVector &rhs) const;
+  bool operator!=(const CoinIndexedVector &rhs) const;
+  int isApproximatelyEqual(const CoinIndexedVector &rhs, double tolerance = 1.0e-8) const;
+  int getMaxIndex() const;
+  int getMinIndex() const;
+  void sort()
+  {
+    std::sort(indices_, indices_ + nElements_);
+  }
+  void sortIncrIndex()
+  {
+    std::sort(indices_, indices_ + nElements_);
+  }
+  void sortDecrIndex();
+  void sortIncrElement();
+  void sortDecrElement();
+  void sortPacked();
+  CoinIndexedVector operator+(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator-(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator*(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator/(
+    const CoinIndexedVector &op2);
+  void operator+=(const CoinIndexedVector &op2);
+  void operator-=(const CoinIndexedVector &op2);
+  void operator*=(const CoinIndexedVector &op2);
+  void operator/=(const CoinIndexedVector &op2);
+  void reserve(int n);
+  inline int capacity() const { return capacity_; }
+  inline void setCapacity(int value)
+  {
+    capacity_ = value;
+  }
+  inline void setPackedMode(bool yesNo)
+  {
+    packedMode_ = yesNo;
+  }
+  inline bool packedMode() const
+  {
+    return packedMode_;
+  }
+  CoinIndexedVector();
+  CoinIndexedVector(int size, const int *inds, const double *elems);
+  CoinIndexedVector(int size, const int *inds, double element);
+  CoinIndexedVector(int size, const double *elements);
+  CoinIndexedVector(int size);
+  CoinIndexedVector(const CoinIndexedVector &);
+  CoinIndexedVector(const CoinIndexedVector *);
+  CoinIndexedVector(const CoinPackedVectorBase &rhs);
+  ~CoinIndexedVector();
+private:
+  void gutsOfSetVector(int size,
+    const int *inds, const double *elems);
+  void gutsOfSetVector(int size, int numberIndices,
+    const int *inds, const double *elems);
+  void gutsOfSetPackedVector(int size, int numberIndices,
+    const int *inds, const double *elems);
+  void gutsOfSetConstant(int size,
+    const int *inds, double value);
+protected:
+  int *indices_;
+  double *elements_;
+  int nElements_;
+  int capacity_;
+  int offset_;
+  bool packedMode_;
+};
+void CoinIndexedVectorUnitTest();
+class CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return static_cast< CoinBigIndex >(size_);
+  }
+  inline CoinBigIndex rawSize() const
+  {
+    return static_cast< CoinBigIndex >(size_);
+  }
+  inline bool switchedOn() const
+  {
+    return size_ != -1;
+  }
+  inline CoinBigIndex capacity() const
+  {
+    return (size_ > -2) ? static_cast< CoinBigIndex >(size_) : static_cast< CoinBigIndex >((-size_) - 2);
+  }
+  inline void setCapacity()
+  {
+    if (size_ <= -2)
+      size_ = (-size_) - 2;
+  }
+  inline const char *array() const
+  {
+    return (size_ > -2) ? array_ : __null;
+  }
+  inline void setSize(int value)
+  {
+    size_ = value;
+  }
+  inline void switchOff()
+  {
+    size_ = -1;
+  }
+  inline void switchOn(int alignment = 3)
+  {
+    size_ = -2;
+    alignment_ = alignment;
+  }
+  void setPersistence(int flag, int currentLength);
+  void clear();
+  void swap(CoinArrayWithLength &other);
+  void extend(int newSize);
+  char *conditionalNew(CoinBigIndex sizeWanted);
+  void conditionalDelete();
+  inline CoinArrayWithLength()
+    : array_(__null)
+    , size_(-1)
+    , offset_(0)
+    , alignment_(0)
+  {
+  }
+  inline CoinArrayWithLength(CoinBigIndex size)
+    : size_(-1)
+    , offset_(0)
+    , alignment_(0)
+  {
+    array_ = new char[size];
+  }
+  CoinArrayWithLength(CoinBigIndex size, int mode);
+  CoinArrayWithLength(const CoinArrayWithLength &rhs);
+  CoinArrayWithLength(const CoinArrayWithLength *rhs);
+  CoinArrayWithLength &operator=(const CoinArrayWithLength &rhs);
+  void copy(const CoinArrayWithLength &rhs, int numberBytes = -1);
+  void allocate(const CoinArrayWithLength &rhs, CoinBigIndex numberBytes);
+  ~CoinArrayWithLength();
+  void getArray(CoinBigIndex size);
+  void reallyFreeArray();
+  void getCapacity(CoinBigIndex numberBytes, CoinBigIndex numberIfNeeded = -1);
+protected:
+  char *array_;
+  CoinBigIndex size_;
+  int offset_;
+  int alignment_;
+};
+class CoinDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(double)));
+  }
+  inline double *array() const
+  {
+    return reinterpret_cast< double * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(double)));
+  }
+  inline double *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< double * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(double)))) : -1));
+  }
+  inline CoinDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(double)))];
+    size_ = -1;
+  }
+  inline CoinDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(double))), mode)
+  {
+  }
+  inline CoinDoubleArrayWithLength(const CoinDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinDoubleArrayWithLength(const CoinDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinDoubleArrayWithLength &operator=(const CoinDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinFactorizationDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(CoinFactorizationDouble)));
+  }
+  inline CoinFactorizationDouble *array() const
+  {
+    return reinterpret_cast< CoinFactorizationDouble * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(CoinFactorizationDouble)));
+  }
+  inline CoinFactorizationDouble *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< CoinFactorizationDouble * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(CoinFactorizationDouble)))) : -1));
+  }
+  inline CoinFactorizationDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinFactorizationDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(CoinFactorizationDouble)))];
+    size_ = -1;
+  }
+  inline CoinFactorizationDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(CoinFactorizationDouble))), mode)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength(const CoinFactorizationDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength(const CoinFactorizationDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength &operator=(const CoinFactorizationDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinFactorizationLongDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(long double)));
+  }
+  inline long double *array() const
+  {
+    return reinterpret_cast< long double * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(long double)));
+  }
+  inline long double *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< long double * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(long double)))) : -1));
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(long double)))];
+    size_ = -1;
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(long double))), mode)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(const CoinFactorizationLongDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(const CoinFactorizationLongDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength &operator=(const CoinFactorizationLongDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinIntArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(int)));
+  }
+  inline int *array() const
+  {
+    return reinterpret_cast< int * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(int)));
+  }
+  inline int *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< int * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(int)))) : -1));
+  }
+  inline CoinIntArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinIntArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(int)))];
+    size_ = -1;
+  }
+  inline CoinIntArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(int))), mode)
+  {
+  }
+  inline CoinIntArrayWithLength(const CoinIntArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinIntArrayWithLength(const CoinIntArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinIntArrayWithLength &operator=(const CoinIntArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinBigIndexArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(CoinBigIndex)));
+  }
+  inline CoinBigIndex *array() const
+  {
+    return reinterpret_cast< CoinBigIndex * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(CoinBigIndex value)
+  {
+    size_ = value * (static_cast< int >(sizeof(CoinBigIndex)));
+  }
+  inline CoinBigIndex *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< CoinBigIndex * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(CoinBigIndex)))) : -1));
+  }
+  inline CoinBigIndexArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinBigIndexArrayWithLength(CoinBigIndex size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(CoinBigIndex)))];
+    size_ = -1;
+  }
+  inline CoinBigIndexArrayWithLength(CoinBigIndex size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(CoinBigIndex))), mode)
+  {
+  }
+  inline CoinBigIndexArrayWithLength(const CoinBigIndexArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinBigIndexArrayWithLength(const CoinBigIndexArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinBigIndexArrayWithLength &operator=(const CoinBigIndexArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinUnsignedIntArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(unsigned int)));
+  }
+  inline unsigned int *array() const
+  {
+    return reinterpret_cast< unsigned int * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(unsigned int)));
+  }
+  inline unsigned int *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< unsigned int * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(unsigned int)))) : -1));
+  }
+  inline CoinUnsignedIntArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinUnsignedIntArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(unsigned int)))];
+    size_ = -1;
+  }
+  inline CoinUnsignedIntArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(unsigned int))), mode)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength(const CoinUnsignedIntArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength(const CoinUnsignedIntArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength &operator=(const CoinUnsignedIntArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinVoidStarArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(void *)));
+  }
+  inline void **array() const
+  {
+    return reinterpret_cast< void ** >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(void *)));
+  }
+  inline void **conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< void ** >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(void *)))) : -1));
+  }
+  inline CoinVoidStarArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinVoidStarArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(void *)))];
+    size_ = -1;
+  }
+  inline CoinVoidStarArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(void *))), mode)
+  {
+  }
+  inline CoinVoidStarArrayWithLength(const CoinVoidStarArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinVoidStarArrayWithLength(const CoinVoidStarArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinVoidStarArrayWithLength &operator=(const CoinVoidStarArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinArbitraryArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / lengthInBytes_;
+  }
+  inline void **array() const
+  {
+    return reinterpret_cast< void ** >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * lengthInBytes_;
+  }
+  inline char *conditionalNew(CoinBigIndex length, CoinBigIndex sizeWanted)
+  {
+    lengthInBytes_ = length;
+    return reinterpret_cast< char * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*lengthInBytes_) : -1));
+  }
+  inline CoinArbitraryArrayWithLength(int length = 1)
+  {
+    array_ = __null;
+    size_ = -1;
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(int length, int size)
+  {
+    array_ = new char[size * length];
+    size_ = -1;
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(int length, int size, int mode)
+    : CoinArrayWithLength(size * length, mode)
+  {
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(const CoinArbitraryArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinArbitraryArrayWithLength(const CoinArbitraryArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinArbitraryArrayWithLength &operator=(const CoinArbitraryArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+protected:
+  CoinBigIndex lengthInBytes_;
+};
+class CoinPartitionedVector : public CoinIndexedVector {
+public:
+  inline int getNumElements(int partition) const
+  {
+    (static_cast<void> (0));
+    return numberElementsPartition_[partition];
+  }
+  inline int getNumPartitions() const
+  {
+    return numberPartitions_;
+  }
+  inline int getNumElements() const { return nElements_; }
+  inline int startPartition(int partition) const
+  {
+    (static_cast<void> (0));
+    return startPartition_[partition];
+  }
+  inline const int *startPartitions() const
+  {
+    return startPartition_;
+  }
+  inline void setNumElementsPartition(int partition, int value)
+  {
+    (static_cast<void> (0));
+    if (numberPartitions_)
+      numberElementsPartition_[partition] = value;
+  }
+  inline void setTempNumElementsPartition(int partition, int value)
+  {
+    (static_cast<void> (0));
+    numberElementsPartition_[partition] = value;
+  }
+  void computeNumberElements();
+  void compact();
+  void reserve(int n);
+  void setPartitions(int number, const int *starts);
+  void clearAndReset();
+  void clearAndKeep();
+  void clearPartition(int partition);
+  inline void checkClear() {};
+  inline void checkClean() {};
+  int scan(int partition, double tolerance = 0.0);
+  void print() const;
+  void sort();
+  CoinPartitionedVector();
+  CoinPartitionedVector(int size, const int *inds, const double *elems);
+  CoinPartitionedVector(int size, const int *inds, double element);
+  CoinPartitionedVector(int size, const double *elements);
+  CoinPartitionedVector(int size);
+  CoinPartitionedVector(const CoinPartitionedVector &);
+  CoinPartitionedVector(const CoinPartitionedVector *);
+  CoinPartitionedVector &operator=(const CoinPartitionedVector &);
+  ~CoinPartitionedVector();
+protected:
+  int startPartition_[8 + 1];
+  int numberElementsPartition_[8];
+  int numberPartitions_;
+};
+inline double *roundUpDouble(double *address)
+{
+  int64_t xx = reinterpret_cast< int64_t >(address);
+  int iBottom = static_cast< int >(xx & 63);
+  if (iBottom)
+    return address + ((64 - iBottom) >> 3);
+  else
+    return address;
+}
+class ClpDualRowPivot;
+class ClpPrimalColumnPivot;
+class ClpFactorization;
+class CoinFactorization;
+class CoinIndexedVector;
+class ClpNonLinearCost;
+class ClpNodeStuff;
+class CoinStructuredModel;
+class OsiClpSolverInterface;
+class CoinWarmStartBasis;
+class ClpDisasterHandler;
+class ClpConstraint;
+class ClpSimplex : public ClpModel {
+  friend void ClpSimplexUnitTest(const std::string &mpsDir);
+public:
+  enum Status {
+    isFree = 0x00,
+    basic = 0x01,
+    atUpperBound = 0x02,
+    atLowerBound = 0x03,
+    superBasic = 0x04,
+    isFixed = 0x05
+  };
+  enum FakeBound {
+    noFake = 0x00,
+    lowerFake = 0x01,
+    upperFake = 0x02,
+    bothFake = 0x03
+  };
+  ClpSimplex(bool emptyMessages = false);
+  ClpSimplex(const ClpSimplex &rhs, int scalingMode = -1);
+  ClpSimplex(const ClpModel &rhs, int scalingMode = -1);
+  ClpSimplex(const ClpModel *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true,
+    bool fixOthers = false);
+  ClpSimplex(const ClpSimplex *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true,
+    bool fixOthers = false);
+  ClpSimplex(ClpSimplex *wholeModel,
+    int numberColumns, const int *whichColumns);
+  void originalModel(ClpSimplex *miniModel);
+  void setPersistenceFlag(int value);
+  void makeBaseModel();
+  void deleteBaseModel();
+  inline ClpSimplex *baseModel() const
+  {
+    return baseModel_;
+  }
+  void setToBaseModel(ClpSimplex *model = __null);
+  ClpSimplex &operator=(const ClpSimplex &rhs);
+  ~ClpSimplex();
+  void loadProblem(const ClpMatrixBase &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const CoinPackedMatrix &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value, const int *length,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  int loadProblem(CoinModel &modelObject, bool keepSolution = false);
+  int readMps(const char *filename,
+    bool keepNames = false,
+    bool ignoreErrors = false);
+  int readGMPL(const char *filename, const char *dataName,
+    bool keepNames = false);
+  int readLp(const char *filename, const double epsilon = 1e-5);
+  void writeLp(const char *filename,
+    const char *extension = "lp",
+    double epsilon = 1e-5,
+    int numberAcross = 10,
+    int decimals = 5,
+    double objSense = 0.0,
+    bool useRowNames = true) const;
+  void borrowModel(ClpModel &otherModel);
+  void borrowModel(ClpSimplex &otherModel);
+  void passInEventHandler(const ClpEventHandler *eventHandler);
+  void getbackSolution(const ClpSimplex &smallModel, const int *whichRow, const int *whichColumn);
+  int loadNonLinear(void *info, int &numberConstraints,
+    ClpConstraint **&constraints);
+  int initialSolve(ClpSolve &options);
+  int initialSolve();
+  int initialDualSolve();
+  int initialPrimalSolve();
+  int initialBarrierSolve();
+  int initialBarrierNoCrossSolve();
+  int dual(int ifValuesPass = 0, int startFinishOptions = 0);
+  int dualDebug(int ifValuesPass = 0, int startFinishOptions = 0);
+  int primal(int ifValuesPass = 0, int startFinishOptions = 0);
+  int nonlinearSLP(int numberPasses, double deltaTolerance);
+  int nonlinearSLP(int numberConstraints, ClpConstraint **constraints,
+    int numberPasses, double deltaTolerance);
+  int barrier(bool crossover = true);
+  int reducedGradient(int phase = 0);
+  int solve(CoinStructuredModel *model);
+  int loadProblem(CoinStructuredModel &modelObject,
+    bool originalOrder = true, bool keepSolution = false);
+  int cleanup(int cleanupScaling);
+  int cleanPrimalSolution(double exactMultiple);
+  int dualRanging(int numberCheck, const int *which,
+    double *costIncrease, int *sequenceIncrease,
+    double *costDecrease, int *sequenceDecrease,
+    double *valueIncrease = __null, double *valueDecrease = __null);
+  int primalRanging(int numberCheck, const int *which,
+    double *valueIncrease, int *sequenceIncrease,
+    double *valueDecrease, int *sequenceDecrease);
+  int modifyCoefficientsAndPivot(int number,
+    const int *which,
+    const CoinBigIndex *start,
+    const int *row,
+    const double *newCoefficient,
+    const unsigned char *newStatus = __null,
+    const double *newLower = __null,
+    const double *newUpper = __null,
+    const double *newObjective = __null);
+  int outDuplicateRows(int numberLook, int *whichRows, bool noOverlaps = false, double tolerance = -1.0,
+    double cleanUp = 0.0);
+  double moveTowardsPrimalFeasible();
+  void removeSuperBasicSlacks(int threshold = 0);
+  ClpSimplex *miniPresolve(char *rowType, char *columnType, void **info);
+  void miniPostsolve(const ClpSimplex *presolvedModel, void *info);
+  void miniSolve(char *rowType, char *columnType, int algorithm, int startUp);
+  int writeBasis(const char *filename,
+    bool writeValues = false,
+    int formatType = 0) const;
+  int readBasis(const char *filename);
+  CoinWarmStartBasis *getBasis() const;
+  void setFactorization(ClpFactorization &factorization);
+  ClpFactorization *swapFactorization(ClpFactorization *factorization);
+  void copyFactorization(ClpFactorization &factorization);
+  int tightenPrimalBounds(double factor = 0.0, int doTight = 0, bool tightIntegers = false);
+  int crash(double gap, int pivot);
+  void setDualRowPivotAlgorithm(ClpDualRowPivot &choice);
+  void setPrimalColumnPivotAlgorithm(ClpPrimalColumnPivot &choice);
+  void markHotStart(void *&saveStuff);
+  void solveFromHotStart(void *saveStuff);
+  void unmarkHotStart(void *saveStuff);
+  int strongBranching(int numberVariables, const int *variables,
+    double *newLower, double *newUpper,
+    double **outputSolution,
+    int *outputStatus, int *outputIterations,
+    bool stopOnFirstInfeasible = true,
+    bool alwaysFinish = false,
+    int startFinishOptions = 0);
+  int fathom(void *stuff);
+  int fathomMany(void *stuff);
+  double doubleCheck();
+  int startFastDual2(ClpNodeStuff *stuff);
+  int fastDual2(ClpNodeStuff *stuff);
+  void stopFastDual2(ClpNodeStuff *stuff);
+  ClpSimplex *fastCrunch(ClpNodeStuff *stuff, int mode);
+  int pivot();
+  int primalPivotResult();
+  int dualPivotResultPart1();
+  int pivotResultPart2(int algorithm, int state);
+  int startup(int ifValuesPass, int startFinishOptions = 0);
+  void finish(int startFinishOptions = 0);
+  bool statusOfProblem(bool initial = false);
+  void defaultFactorizationFrequency();
+  void copyEnabledStuff(const ClpSimplex *rhs);
+  inline bool primalFeasible() const
+  {
+    return (numberPrimalInfeasibilities_ == 0);
+  }
+  inline bool dualFeasible() const
+  {
+    return (numberDualInfeasibilities_ == 0);
+  }
+  inline ClpFactorization *factorization() const
+  {
+    return factorization_;
+  }
+  bool sparseFactorization() const;
+  void setSparseFactorization(bool value);
+  int factorizationFrequency() const;
+  void setFactorizationFrequency(int value);
+  inline double dualBound() const
+  {
+    return dualBound_;
+  }
+  void setDualBound(double value);
+  inline double infeasibilityCost() const
+  {
+    return infeasibilityCost_;
+  }
+  void setInfeasibilityCost(double value);
+  inline int perturbation() const
+  {
+    return perturbation_;
+  }
+  void setPerturbation(int value);
+  inline int algorithm() const
+  {
+    return algorithm_;
+  }
+  inline void setAlgorithm(int value)
+  {
+    algorithm_ = value;
+  }
+  bool isObjectiveLimitTestValid() const;
+  inline double sumDualInfeasibilities() const
+  {
+    return sumDualInfeasibilities_;
+  }
+  inline void setSumDualInfeasibilities(double value)
+  {
+    sumDualInfeasibilities_ = value;
+  }
+  inline double sumOfRelaxedDualInfeasibilities() const
+  {
+    return sumOfRelaxedDualInfeasibilities_;
+  }
+  inline void setSumOfRelaxedDualInfeasibilities(double value)
+  {
+    sumOfRelaxedDualInfeasibilities_ = value;
+  }
+  inline int numberDualInfeasibilities() const
+  {
+    return numberDualInfeasibilities_;
+  }
+  inline void setNumberDualInfeasibilities(int value)
+  {
+    numberDualInfeasibilities_ = value;
+  }
+  inline int numberDualInfeasibilitiesWithoutFree() const
+  {
+    return numberDualInfeasibilitiesWithoutFree_;
+  }
+  inline double sumPrimalInfeasibilities() const
+  {
+    return sumPrimalInfeasibilities_;
+  }
+  inline void setSumPrimalInfeasibilities(double value)
+  {
+    sumPrimalInfeasibilities_ = value;
+  }
+  inline double sumOfRelaxedPrimalInfeasibilities() const
+  {
+    return sumOfRelaxedPrimalInfeasibilities_;
+  }
+  inline void setSumOfRelaxedPrimalInfeasibilities(double value)
+  {
+    sumOfRelaxedPrimalInfeasibilities_ = value;
+  }
+  inline int numberPrimalInfeasibilities() const
+  {
+    return numberPrimalInfeasibilities_;
+  }
+  inline void setNumberPrimalInfeasibilities(int value)
+  {
+    numberPrimalInfeasibilities_ = value;
+  }
+  int saveModel(const char *fileName);
+  int restoreModel(const char *fileName);
+  void checkSolution(int setToBounds = 0);
+  void checkSolutionInternal();
+  void checkUnscaledSolution();
+  inline CoinIndexedVector *rowArray(int index) const
+  {
+    return rowArray_[index];
+  }
+  inline CoinIndexedVector *columnArray(int index) const
+  {
+    return columnArray_[index];
+  }
+  int getSolution(const double *rowActivities,
+    const double *columnActivities);
+  int getSolution();
+  int createPiecewiseLinearCosts(const int *starts,
+    const double *lower, const double *gradient);
+  inline ClpDualRowPivot *dualRowPivot() const
+  {
+    return dualRowPivot_;
+  }
+  inline ClpPrimalColumnPivot *primalColumnPivot() const
+  {
+    return primalColumnPivot_;
+  }
+  inline bool goodAccuracy() const
+  {
+    return (largestPrimalError_ < 1.0e-7 && largestDualError_ < 1.0e-7);
+  }
+  void returnModel(ClpSimplex &otherModel);
+  int internalFactorize(int solveType);
+  ClpDataSave saveData();
+  void restoreData(ClpDataSave saved);
+  void cleanStatus();
+  int factorize();
+  void computeDuals(double *givenDjs);
+  void computePrimals(const double *rowActivities,
+    const double *columnActivities);
+  void add(double *array,
+    int column, double multiplier) const;
+  void unpack(CoinIndexedVector *rowArray) const;
+  void unpack(CoinIndexedVector *rowArray, int sequence) const;
+  void unpackPacked(CoinIndexedVector *rowArray);
+  void unpackPacked(CoinIndexedVector *rowArray, int sequence);
+protected:
+  int housekeeping(double objectiveChange);
+  void checkPrimalSolution(const double *rowActivities = __null,
+    const double *columnActivies = __null);
+  void checkDualSolution();
+  void checkBothSolutions();
+  double scaleObjective(double value);
+  int solveDW(CoinStructuredModel *model, ClpSolve &options);
+  int solveBenders(CoinStructuredModel *model, ClpSolve &options);
+public:
+  void setValuesPassAction(double incomingInfeasibility,
+    double allowedInfeasibility);
+  int cleanFactorization(int ifValuesPass);
+public:
+  inline double alphaAccuracy() const
+  {
+    return alphaAccuracy_;
+  }
+  inline void setAlphaAccuracy(double value)
+  {
+    alphaAccuracy_ = value;
+  }
+public:
+  inline void setDisasterHandler(ClpDisasterHandler *handler)
+  {
+    disasterArea_ = handler;
+  }
+  inline ClpDisasterHandler *disasterHandler() const
+  {
+    return disasterArea_;
+  }
+  inline double largeValue() const
+  {
+    return largeValue_;
+  }
+  void setLargeValue(double value);
+  inline double largestPrimalError() const
+  {
+    return largestPrimalError_;
+  }
+  inline double largestDualError() const
+  {
+    return largestDualError_;
+  }
+  inline void setLargestPrimalError(double value)
+  {
+    largestPrimalError_ = value;
+  }
+  inline void setLargestDualError(double value)
+  {
+    largestDualError_ = value;
+  }
+  inline double zeroTolerance() const
+  {
+    return zeroTolerance_;
+  }
+  inline void setZeroTolerance(double value)
+  {
+    zeroTolerance_ = value;
+  }
+  inline int *pivotVariable() const
+  {
+    return pivotVariable_;
+  }
+  inline bool automaticScaling() const
+  {
+    return automaticScale_ != 0;
+  }
+  inline void setAutomaticScaling(bool onOff)
+  {
+    automaticScale_ = onOff ? 1 : 0;
+  }
+  inline double currentDualTolerance() const
+  {
+    return dualTolerance_;
+  }
+  inline void setCurrentDualTolerance(double value)
+  {
+    dualTolerance_ = value;
+  }
+  inline double currentPrimalTolerance() const
+  {
+    return primalTolerance_;
+  }
+  inline void setCurrentPrimalTolerance(double value)
+  {
+    primalTolerance_ = value;
+  }
+  inline int numberRefinements() const
+  {
+    return numberRefinements_;
+  }
+  void setNumberRefinements(int value);
+  inline double alpha() const
+  {
+    return alpha_;
+  }
+  inline void setAlpha(double value)
+  {
+    alpha_ = value;
+  }
+  inline double dualIn() const
+  {
+    return dualIn_;
+  }
+  inline void setDualIn(double value)
+  {
+    dualIn_ = value;
+  }
+  inline int pivotRow() const
+  {
+    return pivotRow_;
+  }
+  inline void setPivotRow(int value)
+  {
+    pivotRow_ = value;
+  }
+  double valueIncomingDual() const;
+protected:
+  int gutsOfSolution(double *givenDuals,
+    const double *givenPrimals,
+    bool valuesPass = false);
+  void gutsOfDelete(int type);
+  void gutsOfCopy(const ClpSimplex &rhs);
+  bool createRim(int what, bool makeRowCopy = false, int startFinishOptions = 0);
+  void createRim1(bool initial);
+  void createRim4(bool initial);
+  void createRim5(bool initial);
+  void deleteRim(int getRidOfFactorizationData = 2);
+  bool sanityCheck();
+public:
+  inline double *solutionRegion(int section) const
+  {
+    if (!section)
+      return rowActivityWork_;
+    else
+      return columnActivityWork_;
+  }
+  inline double *djRegion(int section) const
+  {
+    if (!section)
+      return rowReducedCost_;
+    else
+      return reducedCostWork_;
+  }
+  inline double *lowerRegion(int section) const
+  {
+    if (!section)
+      return rowLowerWork_;
+    else
+      return columnLowerWork_;
+  }
+  inline double *upperRegion(int section) const
+  {
+    if (!section)
+      return rowUpperWork_;
+    else
+      return columnUpperWork_;
+  }
+  inline double *costRegion(int section) const
+  {
+    if (!section)
+      return rowObjectiveWork_;
+    else
+      return objectiveWork_;
+  }
+  inline double *solutionRegion() const
+  {
+    return solution_;
+  }
+  inline double *djRegion() const
+  {
+    return dj_;
+  }
+  inline double *lowerRegion() const
+  {
+    return lower_;
+  }
+  inline double *upperRegion() const
+  {
+    return upper_;
+  }
+  inline double *costRegion() const
+  {
+    return cost_;
+  }
+  inline Status getStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence] & 7);
+  }
+  inline void setStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  bool startPermanentArrays();
+  void setInitialDenseFactorization(bool onOff);
+  bool initialDenseFactorization() const;
+  inline int sequenceIn() const
+  {
+    return sequenceIn_;
+  }
+  inline int sequenceOut() const
+  {
+    return sequenceOut_;
+  }
+  inline void setSequenceIn(int sequence)
+  {
+    sequenceIn_ = sequence;
+  }
+  inline void setSequenceOut(int sequence)
+  {
+    sequenceOut_ = sequence;
+  }
+  inline int directionIn() const
+  {
+    return directionIn_;
+  }
+  inline int directionOut() const
+  {
+    return directionOut_;
+  }
+  inline void setDirectionIn(int direction)
+  {
+    directionIn_ = direction;
+  }
+  inline void setDirectionOut(int direction)
+  {
+    directionOut_ = direction;
+  }
+  inline double valueOut() const
+  {
+    return valueOut_;
+  }
+  inline double lowerOut() const
+  {
+    return lowerOut_;
+  }
+  inline double upperOut() const
+  {
+    return upperOut_;
+  }
+  inline void setValueOut(double value)
+  {
+    valueOut_ = value;
+  }
+  inline double dualOut() const
+  {
+    return dualOut_;
+  }
+  inline void setDualOut(double value)
+  {
+    dualOut_ = value;
+  }
+  inline void setLowerOut(double value)
+  {
+    lowerOut_ = value;
+  }
+  inline void setUpperOut(double value)
+  {
+    upperOut_ = value;
+  }
+  inline void setTheta(double value)
+  {
+    theta_ = value;
+  }
+  inline int isColumn(int sequence) const
+  {
+    return sequence < numberColumns_ ? 1 : 0;
+  }
+  inline int sequenceWithin(int sequence) const
+  {
+    return sequence < numberColumns_ ? sequence : sequence - numberColumns_;
+  }
+  inline double solution(int sequence)
+  {
+    return solution_[sequence];
+  }
+  inline double &solutionAddress(int sequence)
+  {
+    return solution_[sequence];
+  }
+  inline double reducedCost(int sequence)
+  {
+    return dj_[sequence];
+  }
+  inline double &reducedCostAddress(int sequence)
+  {
+    return dj_[sequence];
+  }
+  inline double lower(int sequence)
+  {
+    return lower_[sequence];
+  }
+  inline double &lowerAddress(int sequence)
+  {
+    return lower_[sequence];
+  }
+  inline double upper(int sequence)
+  {
+    return upper_[sequence];
+  }
+  inline double &upperAddress(int sequence)
+  {
+    return upper_[sequence];
+  }
+  inline double cost(int sequence)
+  {
+    return cost_[sequence];
+  }
+  inline double &costAddress(int sequence)
+  {
+    return cost_[sequence];
+  }
+  inline double originalLower(int iSequence) const
+  {
+    if (iSequence < numberColumns_)
+      return columnLower_[iSequence];
+    else
+      return rowLower_[iSequence - numberColumns_];
+  }
+  inline double originalUpper(int iSequence) const
+  {
+    if (iSequence < numberColumns_)
+      return columnUpper_[iSequence];
+    else
+      return rowUpper_[iSequence - numberColumns_];
+  }
+  inline double theta() const
+  {
+    return theta_;
+  }
+  inline double lowerIn() const
+  {
+    return lowerIn_;
+  }
+  inline double valueIn() const
+  {
+    return valueIn_;
+  }
+  inline double upperIn() const
+  {
+    return upperIn_;
+  }
+  inline double bestPossibleImprovement() const
+  {
+    return bestPossibleImprovement_;
+  }
+  inline ClpNonLinearCost *nonLinearCost() const
+  {
+    return nonLinearCost_;
+  }
+  void setNonLinearCost(ClpNonLinearCost &nonLinearCost);
+  inline int moreSpecialOptions() const
+  {
+    return moreSpecialOptions_;
+  }
+  inline int vectorMode() const
+  {
+    return vectorMode_;
+  }
+  inline void setMoreSpecialOptions(int value)
+  {
+    moreSpecialOptions_ = value;
+  }
+  inline void setVectorMode(int value)
+  {
+    vectorMode_ = value;
+  }
+  inline void setFakeBound(int sequence, FakeBound fakeBound)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~24);
+    st_byte = static_cast< unsigned char >(st_byte | (fakeBound << 3));
+  }
+  inline FakeBound getFakeBound(int sequence) const
+  {
+    return static_cast< FakeBound >((status_[sequence] >> 3) & 3);
+  }
+  inline void setRowStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence + numberColumns_];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  inline Status getRowStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence + numberColumns_] & 7);
+  }
+  inline void setColumnStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  inline Status getColumnStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence] & 7);
+  }
+  inline void setPivoted(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] | 32);
+  }
+  inline void clearPivoted(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] & ~32);
+  }
+  inline bool pivoted(int sequence) const
+  {
+    return (((status_[sequence] >> 5) & 1) != 0);
+  }
+  void setFlagged(int sequence);
+  inline void clearFlagged(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] & ~64);
+  }
+  inline bool flagged(int sequence) const
+  {
+    return ((status_[sequence] & 64) != 0);
+  }
+  inline void setActive(int iRow)
+  {
+    status_[iRow] = static_cast< unsigned char >(status_[iRow] | 128);
+  }
+  inline void clearActive(int iRow)
+  {
+    status_[iRow] = static_cast< unsigned char >(status_[iRow] & ~128);
+  }
+  inline bool active(int iRow) const
+  {
+    return ((status_[iRow] & 128) != 0);
+  }
+  inline void setPerturbed(int iSequence)
+  {
+    status_[iSequence] = static_cast< unsigned char >(status_[iSequence] | 128);
+  }
+  inline void clearPerturbed(int iSequence)
+  {
+    status_[iSequence] = static_cast< unsigned char >(status_[iSequence] & ~128);
+  }
+  inline bool perturbed(int iSequence) const
+  {
+    return ((status_[iSequence] & 128) != 0);
+  }
+  void createStatus();
+  void allSlackBasis(bool resetSolution = false);
+  inline int lastBadIteration() const
+  {
+    return lastBadIteration_;
+  }
+  inline void setLastBadIteration(int value)
+  {
+    lastBadIteration_ = value;
+  }
+  inline int progressFlag() const
+  {
+    return (progressFlag_ & 3);
+  }
+  inline ClpSimplexProgress *progress()
+  {
+    return &progress_;
+  }
+  inline int forceFactorization() const
+  {
+    return forceFactorization_;
+  }
+  inline void forceFactorization(int value)
+  {
+    forceFactorization_ = value;
+  }
+  inline double rawObjectiveValue() const
+  {
+    return objectiveValue_;
+  }
+  void computeObjectiveValue(bool useWorkingSolution = false);
+  double computeInternalObjectiveValue();
+  double *infeasibilityRay(bool fullRay = false) const;
+  inline int numberExtraRows() const
+  {
+    return numberExtraRows_;
+  }
+  inline int maximumBasic() const
+  {
+    return maximumBasic_;
+  }
+  inline int baseIteration() const
+  {
+    return baseIteration_;
+  }
+  void generateCpp(FILE *fp, bool defaultFactor = false);
+  ClpFactorization *getEmptyFactorization();
+  void setEmptyFactorization();
+  void moveInfo(const ClpSimplex &rhs, bool justStatus = false);
+  void getBInvARow(int row, double *z, double *slack = __null);
+  void getBInvRow(int row, double *z);
+  void getBInvACol(int col, double *vec);
+  void getBInvCol(int col, double *vec);
+  void getBasics(int *index);
+  void setObjectiveCoefficient(int elementIndex, double elementValue);
+  inline void setObjCoeff(int elementIndex, double elementValue)
+  {
+    setObjectiveCoefficient(elementIndex, elementValue);
+  }
+  void setColumnLower(int elementIndex, double elementValue);
+  void setColumnUpper(int elementIndex, double elementValue);
+  void setColumnBounds(int elementIndex,
+    double lower, double upper);
+  void setColumnSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline void setColLower(int elementIndex, double elementValue)
+  {
+    setColumnLower(elementIndex, elementValue);
+  }
+  inline void setColUpper(int elementIndex, double elementValue)
+  {
+    setColumnUpper(elementIndex, elementValue);
+  }
+  inline void setColBounds(int elementIndex,
+    double newlower, double newupper)
+  {
+    setColumnBounds(elementIndex, newlower, newupper);
+  }
+  inline void setColSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList)
+  {
+    setColumnSetBounds(indexFirst, indexLast, boundList);
+  }
+  void setRowLower(int elementIndex, double elementValue);
+  void setRowUpper(int elementIndex, double elementValue);
+  void setRowBounds(int elementIndex,
+    double lower, double upper);
+  void setRowSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  void resize(int newNumberRows, int newNumberColumns);
+protected:
+  double bestPossibleImprovement_;
+  double zeroTolerance_;
+  int columnPrimalSequence_;
+  int rowPrimalSequence_;
+  double bestObjectiveValue_;
+  int moreSpecialOptions_;
+  int baseIteration_;
+  int vectorMode_;
+  double primalToleranceToGetOptimal_;
+  double largeValue_;
+  double largestPrimalError_;
+  double largestDualError_;
+  double alphaAccuracy_;
+  double dualBound_;
+  double alpha_;
+  double theta_;
+  double lowerIn_;
+  double valueIn_;
+  double upperIn_;
+  double dualIn_;
+  double lowerOut_;
+  double valueOut_;
+  double upperOut_;
+  double dualOut_;
+  double dualTolerance_;
+  double primalTolerance_;
+  double sumDualInfeasibilities_;
+  double sumPrimalInfeasibilities_;
+  double infeasibilityCost_;
+  double sumOfRelaxedDualInfeasibilities_;
+  double sumOfRelaxedPrimalInfeasibilities_;
+  double acceptablePivot_;
+  double minimumPrimalTolerance_;
+  double averageInfeasibility_[5];
+  double *lower_;
+  double *rowLowerWork_;
+  double *columnLowerWork_;
+  double *upper_;
+  double *rowUpperWork_;
+  double *columnUpperWork_;
+  double *cost_;
+  double *rowObjectiveWork_;
+  double *objectiveWork_;
+  CoinIndexedVector *rowArray_[6];
+  CoinIndexedVector *columnArray_[6];
+  int sequenceIn_;
+  int directionIn_;
+  int sequenceOut_;
+  int directionOut_;
+  int pivotRow_;
+  int lastGoodIteration_;
+  double *dj_;
+  double *rowReducedCost_;
+  double *reducedCostWork_;
+  double *solution_;
+  double *rowActivityWork_;
+  double *columnActivityWork_;
+  int numberDualInfeasibilities_;
+  int numberDualInfeasibilitiesWithoutFree_;
+  int numberPrimalInfeasibilities_;
+  int numberRefinements_;
+  ClpDualRowPivot *dualRowPivot_;
+  ClpPrimalColumnPivot *primalColumnPivot_;
+  int *pivotVariable_;
+  ClpFactorization *factorization_;
+  double *savedSolution_;
+  int numberTimesOptimal_;
+  ClpDisasterHandler *disasterArea_;
+  int changeMade_;
+  int algorithm_;
+  int forceFactorization_;
+  int perturbation_;
+  unsigned char *saveStatus_;
+  ClpNonLinearCost *nonLinearCost_;
+  int lastBadIteration_;
+  int lastFlaggedIteration_;
+  int numberFake_;
+  int numberChanged_;
+  int progressFlag_;
+  int firstFree_;
+  int numberExtraRows_;
+  int maximumBasic_;
+  int dontFactorizePivots_;
+  double incomingInfeasibility_;
+  double allowedInfeasibility_;
+  int automaticScale_;
+  int maximumPerturbationSize_;
+  double *perturbationArray_;
+  ClpSimplex *baseModel_;
+  ClpSimplexProgress progress_;
+  int numberDegeneratePivots_;
+public:
+  mutable int spareIntArray_[4];
+  mutable double spareDoubleArray_[4];
+protected:
+  friend class OsiClpSolverInterface;
+  friend class OsiCLPSolverInterface;
+};
+void ClpSimplexUnitTest(const std::string &mpsDir);
+typedef struct {
+  double upperTheta;
+  double bestPossible;
+  double acceptablePivot;
+  double tolerance;
+  double dualTolerance;
+  double theta;
+  double primalRatio;
+  double changeObj;
+  const double * cost;
+  double * solution;
+  double * reducedCost;
+  const double * lower;
+  const double * upper;
+  double * work;
+  int * index;
+  double * spare;
+  const unsigned char * status;
+  int * which;
+  double * infeas;
+  const int * pivotVariable;
+  const double * element;
+  const CoinBigIndex * start;
+  const int * row;
+  int numberAdded;
+  int numberInfeasibilities;
+  int numberRemaining;
+  int startColumn;
+  int numberToDo;
+  int numberColumns;
+} clpTempInfo;
+class CoinPresolveAction;
+enum COIN_Message {
+  COIN_MPS_LINE = 0,
+  COIN_MPS_STATS,
+  COIN_MPS_ILLEGAL,
+  COIN_MPS_BADIMAGE,
+  COIN_MPS_DUPOBJ,
+  COIN_MPS_DUPROW,
+  COIN_MPS_NOMATCHROW,
+  COIN_MPS_NOMATCHCOL,
+  COIN_MPS_FILE,
+  COIN_MPS_BADFILE1,
+  COIN_MPS_BADFILE2,
+  COIN_MPS_EOF,
+  COIN_MPS_RETURNING,
+  COIN_MPS_CHANGED,
+  COIN_SOLVER_MPS,
+  COIN_PRESOLVE_COLINFEAS,
+  COIN_PRESOLVE_ROWINFEAS,
+  COIN_PRESOLVE_COLUMNBOUNDA,
+  COIN_PRESOLVE_COLUMNBOUNDB,
+  COIN_PRESOLVE_NONOPTIMAL,
+  COIN_PRESOLVE_STATS,
+  COIN_PRESOLVE_INFEAS,
+  COIN_PRESOLVE_UNBOUND,
+  COIN_PRESOLVE_INFEASUNBOUND,
+  COIN_PRESOLVE_INTEGERMODS,
+  COIN_PRESOLVE_POSTSOLVE,
+  COIN_PRESOLVE_NEEDS_CLEANING,
+  COIN_PRESOLVE_PASS,
+  COIN_GENERAL_INFO,
+  COIN_GENERAL_INFO2,
+  COIN_GENERAL_WARNING,
+  COIN_DUMMY_END
+};
+class CoinMessage : public CoinMessages {
+public:
+  CoinMessage(Language language = us_en);
+};
+enum __rlimit_resource
+{
+  RLIMIT_CPU = 0,
+  RLIMIT_FSIZE = 1,
+  RLIMIT_DATA = 2,
+  RLIMIT_STACK = 3,
+  RLIMIT_CORE = 4,
+  __RLIMIT_RSS = 5,
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE,
+  RLIMIT_AS = 9,
+  __RLIMIT_NPROC = 6,
+  __RLIMIT_MEMLOCK = 8,
+  __RLIMIT_LOCKS = 10,
+  __RLIMIT_SIGPENDING = 11,
+  __RLIMIT_MSGQUEUE = 12,
+  __RLIMIT_NICE = 13,
+  __RLIMIT_RTPRIO = 14,
+  __RLIMIT_RTTIME = 15,
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+};
+typedef __rlim_t rlim_t;
+typedef __rlim64_t rlim64_t;
+struct rlimit
+  {
+    rlim_t rlim_cur;
+    rlim_t rlim_max;
+  };
+struct rlimit64
+  {
+    rlim64_t rlim_cur;
+    rlim64_t rlim_max;
+ };
+enum __rusage_who
+{
+  RUSAGE_SELF = 0,
+  RUSAGE_CHILDREN = -1
+  ,
+  RUSAGE_THREAD = 1
+};
+struct rusage
+  {
+    struct timeval ru_utime;
+    struct timeval ru_stime;
+    __extension__ union
+      {
+ long int ru_maxrss;
+ __syscall_slong_t __ru_maxrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_ixrss;
+ __syscall_slong_t __ru_ixrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_idrss;
+ __syscall_slong_t __ru_idrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_isrss;
+  __syscall_slong_t __ru_isrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_minflt;
+ __syscall_slong_t __ru_minflt_word;
+      };
+    __extension__ union
+      {
+ long int ru_majflt;
+ __syscall_slong_t __ru_majflt_word;
+      };
+    __extension__ union
+      {
+ long int ru_nswap;
+ __syscall_slong_t __ru_nswap_word;
+      };
+    __extension__ union
+      {
+ long int ru_inblock;
+ __syscall_slong_t __ru_inblock_word;
+      };
+    __extension__ union
+      {
+ long int ru_oublock;
+ __syscall_slong_t __ru_oublock_word;
+      };
+    __extension__ union
+      {
+ long int ru_msgsnd;
+ __syscall_slong_t __ru_msgsnd_word;
+      };
+    __extension__ union
+      {
+ long int ru_msgrcv;
+ __syscall_slong_t __ru_msgrcv_word;
+      };
+    __extension__ union
+      {
+ long int ru_nsignals;
+ __syscall_slong_t __ru_nsignals_word;
+      };
+    __extension__ union
+      {
+ long int ru_nvcsw;
+ __syscall_slong_t __ru_nvcsw_word;
+      };
+    __extension__ union
+      {
+ long int ru_nivcsw;
+ __syscall_slong_t __ru_nivcsw_word;
+      };
+  };
+enum __priority_which
+{
+  PRIO_PROCESS = 0,
+  PRIO_PGRP = 1,
+  PRIO_USER = 2
+};
+extern "C" {
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+      const struct rlimit *__new_limit,
+      struct rlimit *__old_limit) noexcept (true);
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+        const struct rlimit64 *__new_limit,
+        struct rlimit64 *__old_limit) noexcept (true);
+}
+extern "C" {
+typedef int __rlimit_resource_t;
+typedef int __rusage_who_t;
+typedef int __priority_which_t;
+extern int getrlimit (__rlimit_resource_t __resource,
+        struct rlimit *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int getrlimit64 (__rlimit_resource_t __resource,
+   struct rlimit64 *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int setrlimit (__rlimit_resource_t __resource,
+        const struct rlimit *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int setrlimit64 (__rlimit_resource_t __resource,
+   const struct rlimit64 *__rlimits) noexcept (true)
+   __attribute__ ((__nonnull__ (2)));
+extern int getrusage (__rusage_who_t __who, struct rusage *__usage) noexcept (true);
+extern int getpriority (__priority_which_t __which, id_t __who) noexcept (true);
+extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
+     noexcept (true);
+}
+extern "C" {
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+extern int gettimeofday (struct timeval *__restrict __tv,
+    void *__restrict __tz) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int settimeofday (const struct timeval *__tv,
+    const struct timezone *__tz)
+     noexcept (true);
+extern int adjtime (const struct timeval *__delta,
+      struct timeval *__olddelta) noexcept (true);
+enum __itimer_which
+  {
+    ITIMER_REAL = 0,
+    ITIMER_VIRTUAL = 1,
+    ITIMER_PROF = 2
+  };
+struct itimerval
+  {
+    struct timeval it_interval;
+    struct timeval it_value;
+  };
+typedef int __itimer_which_t;
+extern int getitimer (__itimer_which_t __which,
+        struct itimerval *__value) noexcept (true);
+extern int setitimer (__itimer_which_t __which,
+        const struct itimerval *__restrict __new,
+        struct itimerval *__restrict __old) noexcept (true);
+extern int utimes (const char *__file, const struct timeval __tvp[2])
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int lutimes (const char *__file, const struct timeval __tvp[2])
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int futimes (int __fd, const struct timeval __tvp[2]) noexcept (true);
+extern int futimesat (int __fd, const char *__file,
+        const struct timeval __tvp[2]) noexcept (true);
+}
+
+inline double CoinGetTimeOfDay()
+{
+  struct timeval tv;
+  gettimeofday(&tv, __null);
+  return static_cast< double >(tv.tv_sec) + static_cast< int >(tv.tv_usec) / 1000000.0;
+}
+inline double CoinWallclockTime(double callType = 0)
+{
+  double callTime = CoinGetTimeOfDay();
+  static const double firstCall = callType > 0 ? callType : callTime;
+  return callType < 0 ? firstCall : callTime - firstCall;
+}
+static inline double CoinCpuTime()
+{
+  double cpu_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_SELF, &usage);
+  cpu_temp = static_cast< double >(usage.ru_utime.tv_sec);
+  cpu_temp += 1.0e-6 * (static_cast< double >(usage.ru_utime.tv_usec));
+  return cpu_temp;
+}
+static inline double CoinSysTime()
+{
+  double sys_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_SELF, &usage);
+  sys_temp = static_cast< double >(usage.ru_stime.tv_sec);
+  sys_temp += 1.0e-6 * (static_cast< double >(usage.ru_stime.tv_usec));
+  return sys_temp;
+}
+static inline double CoinCpuTimeJustChildren()
+{
+  double cpu_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_CHILDREN, &usage);
+  cpu_temp = static_cast< double >(usage.ru_utime.tv_sec);
+  cpu_temp += 1.0e-6 * (static_cast< double >(usage.ru_utime.tv_usec));
+  return cpu_temp;
+}
+class CoinTimer {
+private:
+  double start;
+  double limit;
+  double end;
+private:
+  inline bool evaluate(const bool b_tmp) const
+  {
+    return b_tmp;
+  }
+  inline double evaluate(const double d_tmp) const
+  {
+    return d_tmp;
+  }
+public:
+  CoinTimer()
+    : start(0)
+    , limit(1e100)
+    , end(1e100)
+  {
+  }
+  CoinTimer(double lim)
+    : start(CoinCpuTime())
+    , limit(lim)
+    , end(start + lim)
+  {
+  }
+  inline void restart()
+  {
+    start = CoinCpuTime();
+    end = start + limit;
+  }
+  inline void reset() { restart(); }
+  inline void reset(double lim)
+  {
+    limit = lim;
+    restart();
+  }
+  inline bool isPastPercent(double pct) const
+  {
+    return evaluate(start + limit * pct < CoinCpuTime());
+  }
+  inline bool isPast(double lim) const
+  {
+    return evaluate(start + lim < CoinCpuTime());
+  }
+  inline bool isExpired() const
+  {
+    return evaluate(end < CoinCpuTime());
+  }
+  inline double timeLeft() const
+  {
+    return evaluate(end - CoinCpuTime());
+  }
+  inline double timeElapsed() const
+  {
+    return evaluate(CoinCpuTime() - start);
+  }
+  inline void setLimit(double l)
+  {
+    limit = l;
+    return;
+  }
+};
+
+inline void DIE(const char *) {}
+const double ZTOLDP = 1e-12;
+const double ZTOLDP2 = 1e-10;
+class CoinPostsolveMatrix;
+class CoinPresolveAction {
+public:
+  static void throwCoinError(const char *error, const char *ps_routine)
+  {
+    throw CoinError(error, ps_routine, "CoinPresolve");
+  }
+  const CoinPresolveAction *next;
+  CoinPresolveAction(const CoinPresolveAction *next)
+    : next(next)
+  {
+  }
+  inline void setNext(const CoinPresolveAction *nextAction)
+  {
+    next = nextAction;
+  }
+  virtual const char *name() const = 0;
+  virtual void postsolve(CoinPostsolveMatrix *prob) const = 0;
+  virtual ~CoinPresolveAction() {}
+};
+class ClpSimplex;
+class OsiSolverInterface;
+class CoinWarmStartBasis;
+class CoinPrePostsolveMatrix {
+public:
+  CoinPrePostsolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPrePostsolveMatrix(const OsiSolverInterface *si,
+    int ncols_,
+    int nrows_,
+    CoinBigIndex nelems_);
+  CoinPrePostsolveMatrix(const ClpSimplex *si,
+    int ncols_,
+    int nrows_,
+    CoinBigIndex nelems_,
+    double bulkRatio);
+  ~CoinPrePostsolveMatrix();
+  enum Status {
+    isFree = 0x00,
+    basic = 0x01,
+    atUpperBound = 0x02,
+    atLowerBound = 0x03,
+    superBasic = 0x04
+  };
+  inline void setRowStatus(int sequence, Status status)
+  {
+    unsigned char &st_byte = rowstat_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & (~7));
+    st_byte = static_cast< unsigned char >(st_byte | status);
+  }
+  inline Status getRowStatus(int sequence) const
+  {
+    return static_cast< Status >(rowstat_[sequence] & 7);
+  }
+  inline bool rowIsBasic(int sequence) const
+  {
+    return (static_cast< Status >(rowstat_[sequence] & 7) == basic);
+  }
+  inline void setColumnStatus(int sequence, Status status)
+  {
+    unsigned char &st_byte = colstat_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & (~7));
+    st_byte = static_cast< unsigned char >(st_byte | status);
+    switch (status) {
+    case isFree: {
+      if (clo_[sequence] > -COIN_DBL_MAX || cup_[sequence] < COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " isFree, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case basic: {
+      break;
+    }
+    case atUpperBound: {
+      if (cup_[sequence] >= COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " atUpperBound, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case atLowerBound: {
+      if (clo_[sequence] <= -COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " atLowerBound, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case superBasic: {
+      if (clo_[sequence] <= -COIN_DBL_MAX && cup_[sequence] >= COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " superBasic, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    default: {
+      (static_cast<void> (0));
+      break;
+    }
+    }
+  }
+  inline Status getColumnStatus(int sequence) const
+  {
+    return static_cast< Status >(colstat_[sequence] & 7);
+  }
+  inline bool columnIsBasic(int sequence) const
+  {
+    return (static_cast< Status >(colstat_[sequence] & 7) == basic);
+  }
+  void setRowStatusUsingValue(int iRow);
+  void setColumnStatusUsingValue(int iColumn);
+  void setStructuralStatus(const char *strucStatus, int lenParam);
+  void setArtificialStatus(const char *artifStatus, int lenParam);
+  void setStatus(const CoinWarmStartBasis *basis);
+  CoinWarmStartBasis *getStatus();
+  const char *columnStatusString(int j) const;
+  const char *rowStatusString(int i) const;
+  void setObjOffset(double offset);
+  void setObjSense(double objSense);
+  void setPrimalTolerance(double primTol);
+  void setDualTolerance(double dualTol);
+  void setColLower(const double *colLower, int lenParam);
+  void setColUpper(const double *colUpper, int lenParam);
+  void setColSolution(const double *colSol, int lenParam);
+  void setCost(const double *cost, int lenParam);
+  void setReducedCost(const double *redCost, int lenParam);
+  void setRowLower(const double *rowLower, int lenParam);
+  void setRowUpper(const double *rowUpper, int lenParam);
+  void setRowPrice(const double *rowSol, int lenParam);
+  void setRowActivity(const double *rowAct, int lenParam);
+  inline int getNumCols() const
+  {
+    return (ncols_);
+  }
+  inline int getNumRows() const
+  {
+    return (nrows_);
+  }
+  inline CoinBigIndex getNumElems() const
+  {
+    return (nelems_);
+  }
+  inline const CoinBigIndex *getColStarts() const
+  {
+    return (mcstrt_);
+  }
+  inline const int *getColLengths() const
+  {
+    return (hincol_);
+  }
+  inline const int *getRowIndicesByCol() const
+  {
+    return (hrow_);
+  }
+  inline const double *getElementsByCol() const
+  {
+    return (colels_);
+  }
+  inline const double *getColLower() const
+  {
+    return (clo_);
+  }
+  inline const double *getColUpper() const
+  {
+    return (cup_);
+  }
+  inline const double *getCost() const
+  {
+    return (cost_);
+  }
+  inline const double *getRowLower() const
+  {
+    return (rlo_);
+  }
+  inline const double *getRowUpper() const
+  {
+    return (rup_);
+  }
+  inline const double *getColSolution() const
+  {
+    return (sol_);
+  }
+  inline const double *getRowActivity() const
+  {
+    return (acts_);
+  }
+  inline const double *getRowPrice() const
+  {
+    return (rowduals_);
+  }
+  inline const double *getReducedCost() const
+  {
+    return (rcosts_);
+  }
+  inline int countEmptyCols()
+  {
+    int empty = 0;
+    for (int i = 0; i < ncols_; i++)
+      if (hincol_[i] == 0)
+        empty++;
+    return (empty);
+  }
+  inline CoinMessageHandler *messageHandler() const
+  {
+    return handler_;
+  }
+  inline void setMessageHandler(CoinMessageHandler *handler)
+  {
+    if (defaultHandler_ == true) {
+      delete handler_;
+      defaultHandler_ = false;
+    }
+    handler_ = handler;
+  }
+  inline CoinMessages messages() const
+  {
+    return messages_;
+  }
+  int ncols_;
+  int nrows_;
+  CoinBigIndex nelems_;
+  int ncols0_;
+  int nrows0_;
+  CoinBigIndex nelems0_;
+  CoinBigIndex bulk0_;
+  double bulkRatio_;
+  CoinBigIndex *mcstrt_;
+  int *hincol_;
+  int *hrow_;
+  double *colels_;
+  double *cost_;
+  double originalOffset_;
+  double *clo_;
+  double *cup_;
+  double *rlo_;
+  double *rup_;
+  int *originalColumn_;
+  int *originalRow_;
+  double ztolzb_;
+  double ztoldj_;
+  double maxmin_;
+  double *sol_;
+  double *rowduals_;
+  double *acts_;
+  double *rcosts_;
+  unsigned char *colstat_;
+  unsigned char *rowstat_;
+  CoinMessageHandler *handler_;
+  bool defaultHandler_;
+  CoinMessage messages_;
+};
+const char *statusName(CoinPrePostsolveMatrix::Status status);
+class presolvehlink {
+public:
+  int pre, suc;
+};
+inline void PRESOLVE_REMOVE_LINK(presolvehlink *link, int i)
+{
+  int ipre = link[i].pre;
+  int isuc = link[i].suc;
+  if (ipre >= 0) {
+    link[ipre].suc = isuc;
+  }
+  if (isuc >= 0) {
+    link[isuc].pre = ipre;
+  }
+  link[i].pre = -66666666, link[i].suc = -66666666;
+}
+inline void PRESOLVE_INSERT_LINK(presolvehlink *link, int i, int j)
+{
+  int isuc = link[j].suc;
+  link[j].suc = i;
+  link[i].pre = j;
+  if (isuc >= 0) {
+    link[isuc].pre = i;
+  }
+  link[i].suc = isuc;
+}
+inline void PRESOLVE_MOVE_LINK(presolvehlink *link, int i, int j)
+{
+  int ipre = link[i].pre;
+  int isuc = link[i].suc;
+  if (ipre >= 0) {
+    link[ipre].suc = j;
+  }
+  if (isuc >= 0) {
+    link[isuc].pre = j;
+  }
+  link[i].pre = -66666666, link[i].suc = -66666666;
+}
+class CoinPresolveMatrix : public CoinPrePostsolveMatrix {
+public:
+  CoinPresolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPresolveMatrix(int ncols0,
+    double maxmin,
+    ClpSimplex *si,
+    int nrows,
+    CoinBigIndex nelems,
+    bool doStatus,
+    double nonLinearVariable,
+    double bulkRatio);
+  void update_model(ClpSimplex *si,
+    int nrows0,
+    int ncols0,
+    CoinBigIndex nelems0);
+  CoinPresolveMatrix(int ncols0,
+    double maxmin,
+    OsiSolverInterface *si,
+    int nrows,
+    CoinBigIndex nelems,
+    bool doStatus,
+    double nonLinearVariable,
+    const char *prohibited,
+    const char *rowProhibited = __null);
+  void update_model(OsiSolverInterface *si,
+    int nrows0,
+    int ncols0,
+    CoinBigIndex nelems0);
+  ~CoinPresolveMatrix();
+  friend void assignPresolveToPostsolve(CoinPresolveMatrix *&preObj);
+  void setMatrix(const CoinPackedMatrix *mtx);
+  inline int countEmptyRows()
+  {
+    int empty = 0;
+    for (int i = 0; i < nrows_; i++)
+      if (hinrow_[i] == 0)
+        empty++;
+    return (empty);
+  }
+  inline void setVariableType(int i, int variableType)
+  {
+    if (integerType_ == 0)
+      integerType_ = new unsigned char[ncols0_];
+    integerType_[i] = static_cast< unsigned char >(variableType);
+  }
+  void setVariableType(const unsigned char *variableType, int lenParam);
+  void setVariableType(bool allIntegers, int lenParam);
+  inline void setAnyInteger(bool anyInteger = true)
+  {
+    anyInteger_ = anyInteger;
+  }
+  inline const CoinBigIndex *getRowStarts() const
+  {
+    return (mrstrt_);
+  }
+  inline const int *getColIndicesByRow() const
+  {
+    return (hcol_);
+  }
+  inline const double *getElementsByRow() const
+  {
+    return (rowels_);
+  }
+  inline bool isInteger(int i) const
+  {
+    if (integerType_ == 0) {
+      return (anyInteger_);
+    } else if (integerType_[i] == 1) {
+      return (true);
+    } else {
+      return (false);
+    }
+  }
+  inline bool anyInteger() const
+  {
+    return (anyInteger_);
+  }
+  inline int presolveOptions() const
+  {
+    return presolveOptions_;
+  }
+  inline void setPresolveOptions(int value)
+  {
+    presolveOptions_ = value;
+  }
+  presolvehlink *clink_;
+  presolvehlink *rlink_;
+  double dobias_;
+  inline void change_bias(double change_amount)
+  {
+    dobias_ += change_amount;
+  }
+  CoinBigIndex *mrstrt_;
+  int *hinrow_;
+  double *rowels_;
+  int *hcol_;
+  unsigned char *integerType_;
+  bool anyInteger_;
+  bool tuning_;
+  void statistics();
+  double startTime_;
+  double feasibilityTolerance_;
+  inline double feasibilityTolerance()
+  {
+    return (feasibilityTolerance_);
+  }
+  inline void setFeasibilityTolerance(double val)
+  {
+    feasibilityTolerance_ = val;
+  }
+  int status_;
+  inline int status()
+  {
+    return (status_);
+  }
+  inline void setStatus(int status)
+  {
+    status_ = (status & 0x3);
+  }
+  int pass_;
+  inline void setPass(int pass = 0)
+  {
+    pass_ = pass;
+  }
+  int maxSubstLevel_;
+  inline void setMaximumSubstitutionLevel(int level)
+  {
+    maxSubstLevel_ = level;
+  }
+  unsigned char *colChanged_;
+  int *colsToDo_;
+  int numberColsToDo_;
+  int *nextColsToDo_;
+  int numberNextColsToDo_;
+  unsigned char *rowChanged_;
+  int *rowsToDo_;
+  int numberRowsToDo_;
+  int *nextRowsToDo_;
+  int numberNextRowsToDo_;
+  int presolveOptions_;
+  bool anyProhibited_;
+  int *usefulRowInt_;
+  double *usefulRowDouble_;
+  int *usefulColumnInt_;
+  double *usefulColumnDouble_;
+  double *randomNumber_;
+  int *infiniteUp_;
+  double *sumUp_;
+  int *infiniteDown_;
+  double *sumDown_;
+  int recomputeSums(int whichRow);
+  void initializeStuff();
+  void deleteStuff();
+  void initColsToDo();
+  int stepColsToDo();
+  inline int numberColsToDo()
+  {
+    return (numberColsToDo_);
+  }
+  inline bool colChanged(int i) const
+  {
+    return (colChanged_[i] & 1) != 0;
+  }
+  inline void unsetColChanged(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~1));
+  }
+  inline void setColChanged(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (1));
+  }
+  inline void addCol(int i)
+  {
+    if ((colChanged_[i] & 1) == 0) {
+      colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (1));
+      nextColsToDo_[numberNextColsToDo_++] = i;
+    }
+  }
+  inline bool colProhibited(int i) const
+  {
+    return (colChanged_[i] & 2) != 0;
+  }
+  inline bool colProhibited2(int i) const
+  {
+    if (!anyProhibited_)
+      return false;
+    else
+      return (colChanged_[i] & 2) != 0;
+  }
+  inline void setColProhibited(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (2));
+  }
+  inline bool colUsed(int i) const
+  {
+    return (colChanged_[i] & 4) != 0;
+  }
+  inline void setColUsed(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (4));
+  }
+  inline void unsetColUsed(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~4));
+  }
+  inline bool colInfinite(int i) const
+  {
+    return (colChanged_[i] & 8) != 0;
+  }
+  inline void unsetColInfinite(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~8));
+  }
+  inline void setColInfinite(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (8));
+  }
+  void initRowsToDo();
+  int stepRowsToDo();
+  inline int numberRowsToDo()
+  {
+    return (numberRowsToDo_);
+  }
+  inline bool rowChanged(int i) const
+  {
+    return (rowChanged_[i] & 1) != 0;
+  }
+  inline void unsetRowChanged(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] & (~1));
+  }
+  inline void setRowChanged(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (1));
+  }
+  inline void addRow(int i)
+  {
+    if ((rowChanged_[i] & 1) == 0) {
+      rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (1));
+      nextRowsToDo_[numberNextRowsToDo_++] = i;
+    }
+  }
+  inline bool rowProhibited(int i) const
+  {
+    return (rowChanged_[i] & 2) != 0;
+  }
+  inline bool rowProhibited2(int i) const
+  {
+    if (!anyProhibited_)
+      return false;
+    else
+      return (rowChanged_[i] & 2) != 0;
+  }
+  inline void setRowProhibited(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (2));
+  }
+  inline bool rowUsed(int i) const
+  {
+    return (rowChanged_[i] & 4) != 0;
+  }
+  inline void setRowUsed(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (4));
+  }
+  inline void unsetRowUsed(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] & (~4));
+  }
+  inline bool anyProhibited() const
+  {
+    return anyProhibited_;
+  }
+  inline void setAnyProhibited(bool val = true)
+  {
+    anyProhibited_ = val;
+  }
+};
+class CoinPostsolveMatrix : public CoinPrePostsolveMatrix {
+public:
+  CoinPostsolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPostsolveMatrix(ClpSimplex *si,
+    int ncols0,
+    int nrows0,
+    CoinBigIndex nelems0,
+    double maxmin_,
+    double *sol,
+    double *acts,
+    unsigned char *colstat,
+    unsigned char *rowstat);
+  CoinPostsolveMatrix(OsiSolverInterface *si,
+    int ncols0,
+    int nrows0,
+    CoinBigIndex nelems0,
+    double maxmin_,
+    double *sol,
+    double *acts,
+    unsigned char *colstat,
+    unsigned char *rowstat);
+  void assignPresolveToPostsolve(CoinPresolveMatrix *&preObj);
+  ~CoinPostsolveMatrix();
+  CoinBigIndex free_list_;
+  CoinBigIndex maxlink_;
+  CoinBigIndex *link_;
+  char *cdone_;
+  char *rdone_;
+  void check_nbasic();
+};
+void presolve_make_memlists( int *lengths,
+  presolvehlink *link, int n);
+bool presolve_expand_major(CoinBigIndex *majstrts, double *majels,
+  int *minndxs, int *majlens,
+  presolvehlink *majlinks, int nmaj, int k);
+inline bool presolve_expand_col(CoinBigIndex *mcstrt, double *colels,
+  int *hrow, int *hincol,
+  presolvehlink *clink, int ncols, int colx)
+{
+  return presolve_expand_major(mcstrt, colels,
+    hrow, hincol, clink, ncols, colx);
+}
+inline bool presolve_expand_row(CoinBigIndex *mrstrt, double *rowels,
+  int *hcol, int *hinrow,
+  presolvehlink *rlink, int nrows, int rowx)
+{
+  return presolve_expand_major(mrstrt, rowels,
+    hcol, hinrow, rlink, nrows, rowx);
+}
+inline CoinBigIndex presolve_find_minor(int tgt,
+  CoinBigIndex ks, CoinBigIndex ke,
+  const int *minndxs)
+{
+  CoinBigIndex k;
+  for (k = ks; k < ke; k++)
+  {
+    if (minndxs[k] == tgt)
+      break;
+  }
+  return (k);
+}
+inline CoinBigIndex presolve_find_row(int row, CoinBigIndex kcs,
+  CoinBigIndex kce, const int *hrow)
+{
+  return presolve_find_minor(row, kcs, kce, hrow);
+}
+inline CoinBigIndex presolve_find_col(int col, CoinBigIndex krs,
+  CoinBigIndex kre, const int *hcol)
+{
+  return presolve_find_minor(col, krs, kre, hcol);
+}
+CoinBigIndex presolve_find_minor1(int tgt, CoinBigIndex ks, CoinBigIndex ke,
+  const int *minndxs);
+inline CoinBigIndex presolve_find_row1(int row, CoinBigIndex kcs,
+  CoinBigIndex kce, const int *hrow)
+{
+  return presolve_find_minor1(row, kcs, kce, hrow);
+}
+inline CoinBigIndex presolve_find_col1(int col, CoinBigIndex krs,
+  CoinBigIndex kre, const int *hcol)
+{
+  return presolve_find_minor1(col, krs, kre, hcol);
+}
+CoinBigIndex presolve_find_minor2(int tgt, CoinBigIndex ks, int majlen,
+  const int *minndxs,
+  const CoinBigIndex *majlinks);
+inline CoinBigIndex presolve_find_row2(int row, CoinBigIndex kcs, int collen,
+  const int *hrow,
+  const CoinBigIndex *clinks)
+{
+  return presolve_find_minor2(row, kcs, collen, hrow, clinks);
+}
+CoinBigIndex presolve_find_minor3(int tgt, CoinBigIndex ks, int majlen,
+  const int *minndxs,
+  const CoinBigIndex *majlinks);
+inline CoinBigIndex presolve_find_row3(int row, CoinBigIndex kcs, int collen,
+  const int *hrow,
+  const CoinBigIndex *clinks)
+{
+  return presolve_find_minor3(row, kcs, collen, hrow, clinks);
+}
+inline void presolve_delete_from_major(int majndx, int minndx,
+  const CoinBigIndex *majstrts,
+  int *majlens, int *minndxs, double *els)
+{
+  const CoinBigIndex ks = majstrts[majndx];
+  const CoinBigIndex ke = ks + majlens[majndx];
+  const CoinBigIndex kmi = presolve_find_minor(minndx, ks, ke, minndxs);
+  minndxs[kmi] = minndxs[ke - 1];
+  els[kmi] = els[ke - 1];
+  majlens[majndx]--;
+  return;
+}
+inline void presolve_delete_many_from_major(int majndx, char *marked,
+  const CoinBigIndex *majstrts,
+  int *majlens, int *minndxs, double *els)
+{
+  const CoinBigIndex ks = majstrts[majndx];
+  const CoinBigIndex ke = ks + majlens[majndx];
+  CoinBigIndex put = ks;
+  for (CoinBigIndex k = ks; k < ke; k++) {
+    int iMinor = minndxs[k];
+    if (!marked[iMinor]) {
+      minndxs[put] = iMinor;
+      els[put++] = els[k];
+    } else {
+      marked[iMinor] = 0;
+    }
+  }
+  majlens[majndx] = static_cast< int >(put - ks);
+  return;
+}
+inline void presolve_delete_from_col(int row, int col,
+  const CoinBigIndex *mcstrt,
+  int *hincol, int *hrow, double *colels)
+{
+  presolve_delete_from_major(col, row, mcstrt, hincol, hrow, colels);
+}
+inline void presolve_delete_from_row(int row, int col,
+  const CoinBigIndex *mrstrt,
+  int *hinrow, int *hcol, double *rowels)
+{
+  presolve_delete_from_major(row, col, mrstrt, hinrow, hcol, rowels);
+}
+void presolve_delete_from_major2(int majndx, int minndx,
+  CoinBigIndex *majstrts, int *majlens,
+  int *minndxs, CoinBigIndex *majlinks,
+  CoinBigIndex *free_listp);
+inline void presolve_delete_from_col2(int row, int col, CoinBigIndex *mcstrt,
+  int *hincol, int *hrow,
+  CoinBigIndex *clinks, CoinBigIndex *free_listp)
+{
+  presolve_delete_from_major2(col, row, mcstrt, hincol, hrow, clinks, free_listp);
+}
+double *presolve_dupmajor(const double *elems, const int *indices,
+  int length, CoinBigIndex offset, int tgt = -1);
+void coin_init_random_vec(double *work, int n);
+class ClpPresolve {
+public:
+  ClpPresolve();
+  virtual ~ClpPresolve();
+  ClpSimplex *presolvedModel(ClpSimplex &si,
+    double feasibilityTolerance = 0.0,
+    bool keepIntegers = true,
+    int numberPasses = 5,
+    bool dropNames = false,
+    bool doRowObjective = false,
+    const char *prohibitedRows = __null,
+    const char *prohibitedColumns = __null);
+  int presolvedModelToFile(ClpSimplex &si, std::string fileName,
+    double feasibilityTolerance = 0.0,
+    bool keepIntegers = true,
+    int numberPasses = 5,
+    bool dropNames = false,
+    bool doRowObjective = false);
+  ClpSimplex *model() const;
+  ClpSimplex *originalModel() const;
+  void setOriginalModel(ClpSimplex *model);
+  const int *originalColumns() const;
+  const int *originalRows() const;
+  inline void setNonLinearValue(double value)
+  {
+    nonLinearValue_ = value;
+  }
+  inline double nonLinearValue() const
+  {
+    return nonLinearValue_;
+  }
+  inline bool doDual() const
+  {
+    return (presolveActions_ & 1) == 0;
+  }
+  inline void setDoDual(bool doDual)
+  {
+    if (doDual)
+      presolveActions_ &= ~1;
+    else
+      presolveActions_ |= 1;
+  }
+  inline bool doSingleton() const
+  {
+    return (presolveActions_ & 2) == 0;
+  }
+  inline void setDoSingleton(bool doSingleton)
+  {
+    if (doSingleton)
+      presolveActions_ &= ~2;
+    else
+      presolveActions_ |= 2;
+  }
+  inline bool doDoubleton() const
+  {
+    return (presolveActions_ & 4) == 0;
+  }
+  inline void setDoDoubleton(bool doDoubleton)
+  {
+    if (doDoubleton)
+      presolveActions_ &= ~4;
+    else
+      presolveActions_ |= 4;
+  }
+  inline bool doTripleton() const
+  {
+    return (presolveActions_ & 8) == 0;
+  }
+  inline void setDoTripleton(bool doTripleton)
+  {
+    if (doTripleton)
+      presolveActions_ &= ~8;
+    else
+      presolveActions_ |= 8;
+  }
+  inline bool doTighten() const
+  {
+    return (presolveActions_ & 16) == 0;
+  }
+  inline void setDoTighten(bool doTighten)
+  {
+    if (doTighten)
+      presolveActions_ &= ~16;
+    else
+      presolveActions_ |= 16;
+  }
+  inline bool doForcing() const
+  {
+    return (presolveActions_ & 32) == 0;
+  }
+  inline void setDoForcing(bool doForcing)
+  {
+    if (doForcing)
+      presolveActions_ &= ~32;
+    else
+      presolveActions_ |= 32;
+  }
+  inline bool doImpliedFree() const
+  {
+    return (presolveActions_ & 64) == 0;
+  }
+  inline void setDoImpliedFree(bool doImpliedfree)
+  {
+    if (doImpliedfree)
+      presolveActions_ &= ~64;
+    else
+      presolveActions_ |= 64;
+  }
+  inline bool doDupcol() const
+  {
+    return (presolveActions_ & 128) == 0;
+  }
+  inline void setDoDupcol(bool doDupcol)
+  {
+    if (doDupcol)
+      presolveActions_ &= ~128;
+    else
+      presolveActions_ |= 128;
+  }
+  inline bool doDuprow() const
+  {
+    return (presolveActions_ & 256) == 0;
+  }
+  inline void setDoDuprow(bool doDuprow)
+  {
+    if (doDuprow)
+      presolveActions_ &= ~256;
+    else
+      presolveActions_ |= 256;
+  }
+  inline bool doDependency() const
+  {
+    return (presolveActions_ & 32768) != 0;
+  }
+  inline void setDoDependency(bool doDependency)
+  {
+    if (doDependency)
+      presolveActions_ |= 32768;
+    else
+      presolveActions_ &= ~32768;
+  }
+  inline bool doTransfer() const
+  {
+    return (presolveActions_ & 65536) != 0;
+  }
+  inline void setDoTransfer(bool doTransfer)
+  {
+    if (doTransfer)
+      presolveActions_ |= 65536;
+    else
+      presolveActions_ &= ~65536;
+  }
+  inline bool doSingletonColumn() const
+  {
+    return (presolveActions_ & 512) == 0;
+  }
+  inline void setDoSingletonColumn(bool doSingleton)
+  {
+    if (doSingleton)
+      presolveActions_ &= ~512;
+    else
+      presolveActions_ |= 512;
+  }
+  inline bool doGubrow() const
+  {
+    return (presolveActions_ & 1024) == 0;
+  }
+  inline void setDoGubrow(bool doGubrow)
+  {
+    if (doGubrow)
+      presolveActions_ &= ~1024;
+    else
+      presolveActions_ |= 1024;
+  }
+  inline bool doTwoxTwo() const
+  {
+    return (presolveActions_ & 2048) != 0;
+  }
+  inline void setDoTwoxtwo(bool doTwoxTwo)
+  {
+    if (!doTwoxTwo)
+      presolveActions_ &= ~2048;
+    else
+      presolveActions_ |= 2048;
+  }
+  inline bool doIntersection() const
+  {
+    return (presolveActions_ & 4096) != 0;
+  }
+  inline void setDoIntersection(bool doIntersection)
+  {
+    if (doIntersection)
+      presolveActions_ &= ~4096;
+    else
+      presolveActions_ |= 4096;
+  }
+  inline int zeroSmall() const
+  {
+    return (presolveActions_ & (8192 | 16384)) >> 13;
+  }
+  inline void setZeroSmall(int value)
+  {
+    presolveActions_ &= ~(8192 | 16384);
+    presolveActions_ |= value << 13;
+  }
+  inline int presolveActions() const
+  {
+    return presolveActions_ & 0xffffff;
+  }
+  inline void setPresolveActions(int action)
+  {
+    presolveActions_ = (presolveActions_ & 0xff000000) | (action & 0xffffff);
+  }
+  inline void setSubstitution(int value)
+  {
+    substitution_ = value;
+  }
+  inline void statistics()
+  {
+    presolveActions_ |= 0x80000000;
+  }
+  int presolveStatus() const;
+  virtual void postsolve(bool updateStatus = true);
+  void destroyPresolve();
+private:
+  ClpSimplex *originalModel_;
+  ClpSimplex *presolvedModel_;
+  double nonLinearValue_;
+  int *originalColumn_;
+  int *originalRow_;
+  double *rowObjective_;
+  const CoinPresolveAction *paction_;
+  int ncols_;
+  int nrows_;
+  CoinBigIndex nelems_;
+  int numberPasses_;
+  int substitution_;
+  std::string saveFile_;
+  int presolveActions_;
+protected:
+  virtual const CoinPresolveAction *presolve(CoinPresolveMatrix *prob);
+  virtual void postsolve(CoinPostsolveMatrix &prob);
+  virtual ClpSimplex *gutsOfPresolvedModel(ClpSimplex *originalModel,
+    double feasibilityTolerance,
+    bool keepIntegers,
+    int numberPasses,
+    bool dropNames,
+    bool doRowObjective,
+    const char *prohibitedRows = __null,
+    const char *prohibitedColumns = __null);
+};
+
+class ClpSimplex;
+class CoinIndexedVector;
+class ClpDualRowPivot {
+public:
+  virtual int pivotRow() = 0;
+  virtual double updateWeights(CoinIndexedVector *input,
+    CoinIndexedVector *spare,
+    CoinIndexedVector *spare2,
+    CoinIndexedVector *updatedColumn)
+    = 0;
+  virtual void updatePrimalSolution(CoinIndexedVector *input,
+    double theta,
+    double &changeInObjective)
+    = 0;
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  virtual void checkAccuracy();
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const
+  {
+    return false;
+  }
+  virtual void maximumPivotsChanged() {}
+  ClpDualRowPivot();
+  ClpDualRowPivot(const ClpDualRowPivot &);
+  ClpDualRowPivot &operator=(const ClpDualRowPivot &rhs);
+  virtual ~ClpDualRowPivot();
+  virtual ClpDualRowPivot *clone(bool copyData = true) const = 0;
+  inline ClpSimplex *model()
+  {
+    return model_;
+  }
+  inline void setModel(ClpSimplex *newmodel)
+  {
+    model_ = newmodel;
+  }
+  inline int type()
+  {
+    return type_;
+  }
+protected:
+  ClpSimplex *model_;
+  int type_;
+};
+class CoinIndexedVector;
+class ClpDualRowSteepest : public ClpDualRowPivot {
+public:
+  virtual int pivotRow();
+  virtual double updateWeights(CoinIndexedVector *input,
+    CoinIndexedVector *spare,
+    CoinIndexedVector *spare2,
+    CoinIndexedVector *updatedColumn);
+  virtual void updatePrimalSolution(CoinIndexedVector *input,
+    double theta,
+    double &changeInObjective);
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  void passInSavedWeights(const CoinIndexedVector *saved);
+  inline CoinIndexedVector *savedWeights()
+  {
+    return savedWeights_;
+  }
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const;
+  virtual void maximumPivotsChanged();
+  enum Persistence {
+    normal = 0x00,
+    keep = 0x01
+  };
+  ClpDualRowSteepest(int mode = 3);
+  ClpDualRowSteepest(const ClpDualRowSteepest &);
+  ClpDualRowSteepest &operator=(const ClpDualRowSteepest &rhs);
+  void fill(const ClpDualRowSteepest &rhs);
+  virtual ~ClpDualRowSteepest();
+  virtual ClpDualRowPivot *clone(bool copyData = true) const;
+  inline int mode() const
+  {
+    return mode_;
+  }
+  inline void setMode(int mode)
+  {
+    mode_ = mode;
+  }
+  inline void setPersistence(Persistence life)
+  {
+    persistence_ = life;
+  }
+  inline Persistence persistence() const
+  {
+    return persistence_;
+  }
+protected:
+  int state_;
+  int mode_;
+  Persistence persistence_;
+  double *weights_;
+  CoinIndexedVector *infeasible_;
+  CoinIndexedVector *alternateWeights_;
+  CoinIndexedVector *savedWeights_;
+  int *dubiousWeights_;
+};
+
@@ -59981,2 +71510,81 @@
-    (void)ok;
-    cv::errorNoReturn( Error::StsError, "The library is built without Clp support", __func__, "/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp", 550 );
+    do { if(!!(motionModel() <= MM_AFFINE && motionModel() != MM_RIGID)) ; else cv::errorNoReturn( cv::Error::StsAssert, "motionModel() <= MM_AFFINE && motionModel() != MM_RIGID", __func__, "/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/global_motion.cpp", 554 ); } while(0);
+    if(npoints <= 0)
+        return Mat::eye(3, 3, 5);
+    const Point2f *points0_ = points0.getMat().ptr<Point2f>();
+    const Point2f *points1_ = points1.getMat().ptr<Point2f>();
+    int ncols = 6 + 2*npoints;
+    int nrows = 4*npoints;
+    if (motionModel() == MM_SIMILARITY)
+        nrows += 2;
+    else if (motionModel() == MM_TRANSLATION_AND_SCALE)
+        nrows += 3;
+    else if (motionModel() == MM_TRANSLATION)
+        nrows += 4;
+    rows_.clear();
+    cols_.clear();
+    elems_.clear();
+    obj_.assign(ncols, 0);
+    collb_.assign(ncols, -1e10);
+    colub_.assign(ncols, 1e10);
+    int c = 6;
+    for (int i = 0; i < npoints; ++i, c += 2)
+    {
+        obj_[c] = 1;
+        collb_[c] = 0;
+        obj_[c+1] = 1;
+        collb_[c+1] = 0;
+    }
+    elems_.clear();
+    rowlb_.assign(nrows, -1e10);
+    rowub_.assign(nrows, 1e10);
+    int r = 0;
+    Point2f p0, p1;
+    for (int i = 0; i < npoints; ++i, r += 4)
+    {
+        p0 = points0_[i];
+        p1 = points1_[i];
+        set(r, 0, p0.x); set(r, 1, p0.y); set(r, 2, 1); set(r, 6+2*i, -1);
+        rowub_[r] = p1.x;
+        set(r+1, 3, p0.x); set(r+1, 4, p0.y); set(r+1, 5, 1); set(r+1, 6+2*i+1, -1);
+        rowub_[r+1] = p1.y;
+        set(r+2, 0, p0.x); set(r+2, 1, p0.y); set(r+2, 2, 1); set(r+2, 6+2*i, 1);
+        rowlb_[r+2] = p1.x;
+        set(r+3, 3, p0.x); set(r+3, 4, p0.y); set(r+3, 5, 1); set(r+3, 6+2*i+1, 1);
+        rowlb_[r+3] = p1.y;
+    }
+    if (motionModel() == MM_SIMILARITY)
+    {
+        set(r, 0, 1); set(r, 4, -1); rowlb_[r] = rowub_[r] = 0;
+        set(r+1, 1, 1); set(r+1, 3, 1); rowlb_[r+1] = rowub_[r+1] = 0;
+    }
+    else if (motionModel() == MM_TRANSLATION_AND_SCALE)
+    {
+        set(r, 0, 1); set(r, 4, -1); rowlb_[r] = rowub_[r] = 0;
+        set(r+1, 1, 1); rowlb_[r+1] = rowub_[r+1] = 0;
+        set(r+2, 3, 1); rowlb_[r+2] = rowub_[r+2] = 0;
+    }
+    else if (motionModel() == MM_TRANSLATION)
+    {
+        set(r, 0, 1); rowlb_[r] = rowub_[r] = 1;
+        set(r+1, 1, 1); rowlb_[r+1] = rowub_[r+1] = 0;
+        set(r+2, 3, 1); rowlb_[r+2] = rowub_[r+2] = 0;
+        set(r+3, 4, 1); rowlb_[r+3] = rowub_[r+3] = 1;
+    }
+    CoinPackedMatrix A(true, &rows_[0], &cols_[0], &elems_[0], elems_.size());
+    A.setDimensions(nrows, ncols);
+    ClpSimplex model(false);
+    model.loadProblem(A, &collb_[0], &colub_[0], &obj_[0], &rowlb_[0], &rowub_[0]);
+    ClpDualRowSteepest dualSteep(1);
+    model.setDualRowPivotAlgorithm(dualSteep);
+    model.scaling(1);
+    model.dual();
+    const double *sol = model.getColSolution();
+    Mat_<float> M = Mat::eye(3, 3, 5);
+    M(0,0) = sol[0];
+    M(0,1) = sol[1];
+    M(0,2) = sol[2];
+    M(1,0) = sol[3];
+    M(1,1) = sol[4];
+    M(1,2) = sol[5];
+    if (ok) *ok = true;
+    return M;
diff -r -u0 /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp.ii /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp.ii
--- /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp.ii	2024-07-24 11:49:25.924942536 +0800
+++ /home/xiaoyu/cmake-analyzer/cmake-projects/opencv/build_0/workspace_for_cdb/preprocess/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp.ii	2024-07-24 11:49:45.844959783 +0800
@@ -58866,0 +58867,11529 @@
+typedef int CoinBigIndex;
+typedef double CoinWorkDouble;
+typedef double CoinFactorizationDouble;
+
+void WindowsErrorPopupBlocker();
+class CoinError {
+  friend void CoinErrorUnitTest();
+private:
+  CoinError()
+    : message_()
+    , method_()
+    , class_()
+    , file_()
+    , lineNumber_()
+  {
+  }
+public:
+  inline const std::string &message() const
+  {
+    return message_;
+  }
+  inline const std::string &methodName() const
+  {
+    return method_;
+  }
+  inline const std::string &className() const
+  {
+    return class_;
+  }
+  inline const std::string &fileName() const
+  {
+    return file_;
+  }
+  inline int lineNumber() const
+  {
+    return lineNumber_;
+  }
+  inline void print(bool doPrint = true) const
+  {
+    if (!doPrint)
+      return;
+    if (lineNumber_ < 0) {
+      std::cout << message_ << " in " << class_ << "::" << method_ << std::endl;
+    } else {
+      std::cout << file_ << ":" << lineNumber_ << " method " << method_
+                << " : assertion \'" << message_ << "\' failed." << std::endl;
+      if (class_ != "")
+        std::cout << "Possible reason: " << class_ << std::endl;
+    }
+  }
+  CoinError(
+    std::string message__,
+    std::string methodName__,
+    std::string className__,
+    std::string fileName_ = std::string(),
+    int line = -1)
+    : message_(message__)
+    , method_(methodName__)
+    , class_(className__)
+    , file_(fileName_)
+    , lineNumber_(line)
+  {
+    print(printErrors_);
+  }
+  CoinError(const CoinError &source)
+    : message_(source.message_)
+    , method_(source.method_)
+    , class_(source.class_)
+    , file_(source.file_)
+    , lineNumber_(source.lineNumber_)
+  {
+  }
+  CoinError &operator=(const CoinError &rhs)
+  {
+    if (this != &rhs) {
+      message_ = rhs.message_;
+      method_ = rhs.method_;
+      class_ = rhs.class_;
+      file_ = rhs.file_;
+      lineNumber_ = rhs.lineNumber_;
+    }
+    return *this;
+  }
+  virtual ~CoinError()
+  {
+  }
+private:
+  std::string message_;
+  std::string method_;
+  std::string class_;
+  std::string file_;
+  int lineNumber_;
+public:
+  static bool printErrors_;
+};
+void CoinErrorUnitTest();
+
+namespace __gnu_cxx
+{
+  template<typename _Tp>
+    struct __aligned_membuf
+    {
+      struct _Tp2 { _Tp _M_t; };
+      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
+      __aligned_membuf() = default;
+      __aligned_membuf(std::nullptr_t) { }
+      void*
+      _M_addr() noexcept
+      { return static_cast<void*>(&_M_storage); }
+      const void*
+      _M_addr() const noexcept
+      { return static_cast<const void*>(&_M_storage); }
+      _Tp*
+      _M_ptr() noexcept
+      { return static_cast<_Tp*>(_M_addr()); }
+      const _Tp*
+      _M_ptr() const noexcept
+      { return static_cast<const _Tp*>(_M_addr()); }
+    };
+  template<typename _Tp>
+    struct __aligned_buffer
+    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
+    {
+      typename
+ std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
+      __aligned_buffer() = default;
+      __aligned_buffer(std::nullptr_t) { }
+      void*
+      _M_addr() noexcept
+      {
+        return static_cast<void*>(&_M_storage);
+      }
+      const void*
+      _M_addr() const noexcept
+      {
+        return static_cast<const void*>(&_M_storage);
+      }
+      _Tp*
+      _M_ptr() noexcept
+      { return static_cast<_Tp*>(_M_addr()); }
+      const _Tp*
+      _M_ptr() const noexcept
+      { return static_cast<const _Tp*>(_M_addr()); }
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  enum _Rb_tree_color { _S_red = false, _S_black = true };
+  struct _Rb_tree_node_base
+  {
+    typedef _Rb_tree_node_base* _Base_ptr;
+    typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    _Rb_tree_color _M_color;
+    _Base_ptr _M_parent;
+    _Base_ptr _M_left;
+    _Base_ptr _M_right;
+    static _Base_ptr
+    _S_minimum(_Base_ptr __x) noexcept
+    {
+      while (__x->_M_left != 0) __x = __x->_M_left;
+      return __x;
+    }
+    static _Const_Base_ptr
+    _S_minimum(_Const_Base_ptr __x) noexcept
+    {
+      while (__x->_M_left != 0) __x = __x->_M_left;
+      return __x;
+    }
+    static _Base_ptr
+    _S_maximum(_Base_ptr __x) noexcept
+    {
+      while (__x->_M_right != 0) __x = __x->_M_right;
+      return __x;
+    }
+    static _Const_Base_ptr
+    _S_maximum(_Const_Base_ptr __x) noexcept
+    {
+      while (__x->_M_right != 0) __x = __x->_M_right;
+      return __x;
+    }
+  };
+  template<typename _Key_compare>
+    struct _Rb_tree_key_compare
+    {
+      _Key_compare _M_key_compare;
+      _Rb_tree_key_compare()
+      noexcept(is_nothrow_default_constructible<_Key_compare>::value)
+      : _M_key_compare()
+      { }
+      _Rb_tree_key_compare(const _Key_compare& __comp)
+      : _M_key_compare(__comp)
+      { }
+      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;
+      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
+ noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
+      : _M_key_compare(__x._M_key_compare)
+      { }
+    };
+  struct _Rb_tree_header
+  {
+    _Rb_tree_node_base _M_header;
+    size_t _M_node_count;
+    _Rb_tree_header() noexcept
+    {
+      _M_header._M_color = _S_red;
+      _M_reset();
+    }
+    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
+    {
+      if (__x._M_header._M_parent != nullptr)
+ _M_move_data(__x);
+      else
+ {
+   _M_header._M_color = _S_red;
+   _M_reset();
+ }
+    }
+    void
+    _M_move_data(_Rb_tree_header& __from)
+    {
+      _M_header._M_color = __from._M_header._M_color;
+      _M_header._M_parent = __from._M_header._M_parent;
+      _M_header._M_left = __from._M_header._M_left;
+      _M_header._M_right = __from._M_header._M_right;
+      _M_header._M_parent->_M_parent = &_M_header;
+      _M_node_count = __from._M_node_count;
+      __from._M_reset();
+    }
+    void
+    _M_reset()
+    {
+      _M_header._M_parent = 0;
+      _M_header._M_left = &_M_header;
+      _M_header._M_right = &_M_header;
+      _M_node_count = 0;
+    }
+  };
+  template<typename _Val>
+    struct _Rb_tree_node : public _Rb_tree_node_base
+    {
+      typedef _Rb_tree_node<_Val>* _Link_type;
+      __gnu_cxx::__aligned_membuf<_Val> _M_storage;
+      _Val*
+      _M_valptr()
+      { return _M_storage._M_ptr(); }
+      const _Val*
+      _M_valptr() const
+      { return _M_storage._M_ptr(); }
+    };
+  __attribute__ ((__pure__)) _Rb_tree_node_base*
+  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) const _Rb_tree_node_base*
+  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) _Rb_tree_node_base*
+  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
+  __attribute__ ((__pure__)) const _Rb_tree_node_base*
+  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
+  template<typename _Tp>
+    struct _Rb_tree_iterator
+    {
+      typedef _Tp value_type;
+      typedef _Tp& reference;
+      typedef _Tp* pointer;
+      typedef bidirectional_iterator_tag iterator_category;
+      typedef ptrdiff_t difference_type;
+      typedef _Rb_tree_iterator<_Tp> _Self;
+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
+      typedef _Rb_tree_node<_Tp>* _Link_type;
+      _Rb_tree_iterator() noexcept
+      : _M_node() { }
+      explicit
+      _Rb_tree_iterator(_Base_ptr __x) noexcept
+      : _M_node(__x) { }
+      reference
+      operator*() const noexcept
+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      pointer
+      operator->() const noexcept
+      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
+      _Self&
+      operator++() noexcept
+      {
+ _M_node = _Rb_tree_increment(_M_node);
+ return *this;
+      }
+      _Self
+      operator++(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_increment(_M_node);
+ return __tmp;
+      }
+      _Self&
+      operator--() noexcept
+      {
+ _M_node = _Rb_tree_decrement(_M_node);
+ return *this;
+      }
+      _Self
+      operator--(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_decrement(_M_node);
+ return __tmp;
+      }
+      friend bool
+      operator==(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node == __y._M_node; }
+      friend bool
+      operator!=(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node != __y._M_node; }
+      _Base_ptr _M_node;
+    };
+  template<typename _Tp>
+    struct _Rb_tree_const_iterator
+    {
+      typedef _Tp value_type;
+      typedef const _Tp& reference;
+      typedef const _Tp* pointer;
+      typedef _Rb_tree_iterator<_Tp> iterator;
+      typedef bidirectional_iterator_tag iterator_category;
+      typedef ptrdiff_t difference_type;
+      typedef _Rb_tree_const_iterator<_Tp> _Self;
+      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
+      typedef const _Rb_tree_node<_Tp>* _Link_type;
+      _Rb_tree_const_iterator() noexcept
+      : _M_node() { }
+      explicit
+      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
+      : _M_node(__x) { }
+      _Rb_tree_const_iterator(const iterator& __it) noexcept
+      : _M_node(__it._M_node) { }
+      iterator
+      _M_const_cast() const noexcept
+      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }
+      reference
+      operator*() const noexcept
+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      pointer
+      operator->() const noexcept
+      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
+      _Self&
+      operator++() noexcept
+      {
+ _M_node = _Rb_tree_increment(_M_node);
+ return *this;
+      }
+      _Self
+      operator++(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_increment(_M_node);
+ return __tmp;
+      }
+      _Self&
+      operator--() noexcept
+      {
+ _M_node = _Rb_tree_decrement(_M_node);
+ return *this;
+      }
+      _Self
+      operator--(int) noexcept
+      {
+ _Self __tmp = *this;
+ _M_node = _Rb_tree_decrement(_M_node);
+ return __tmp;
+      }
+      friend bool
+      operator==(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node == __y._M_node; }
+      friend bool
+      operator!=(const _Self& __x, const _Self& __y) noexcept
+      { return __x._M_node != __y._M_node; }
+      _Base_ptr _M_node;
+    };
+  __attribute__((__nonnull__))
+  void
+  _Rb_tree_insert_and_rebalance(const bool __insert_left,
+    _Rb_tree_node_base* __x,
+    _Rb_tree_node_base* __p,
+    _Rb_tree_node_base& __header) throw ();
+  __attribute__((__nonnull__,__returns_nonnull__))
+  _Rb_tree_node_base*
+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
+          _Rb_tree_node_base& __header) throw ();
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc = allocator<_Val> >
+    class _Rb_tree
+    {
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
+      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
+    protected:
+      typedef _Rb_tree_node_base* _Base_ptr;
+      typedef const _Rb_tree_node_base* _Const_Base_ptr;
+      typedef _Rb_tree_node<_Val>* _Link_type;
+      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
+    private:
+      struct _Reuse_or_alloc_node
+      {
+ _Reuse_or_alloc_node(_Rb_tree& __t)
+ : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
+ {
+   if (_M_root)
+     {
+       _M_root->_M_parent = 0;
+       if (_M_nodes->_M_left)
+  _M_nodes = _M_nodes->_M_left;
+     }
+   else
+     _M_nodes = 0;
+ }
+ _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
+ ~_Reuse_or_alloc_node()
+ { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }
+ template<typename _Arg>
+   _Link_type
+   operator()(_Arg&& __arg)
+   {
+     _Link_type __node = static_cast<_Link_type>(_M_extract());
+     if (__node)
+       {
+  _M_t._M_destroy_node(__node);
+  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
+  return __node;
+       }
+     return _M_t._M_create_node(std::forward<_Arg>(__arg));
+   }
+      private:
+ _Base_ptr
+ _M_extract()
+ {
+   if (!_M_nodes)
+     return _M_nodes;
+   _Base_ptr __node = _M_nodes;
+   _M_nodes = _M_nodes->_M_parent;
+   if (_M_nodes)
+     {
+       if (_M_nodes->_M_right == __node)
+  {
+    _M_nodes->_M_right = 0;
+    if (_M_nodes->_M_left)
+      {
+        _M_nodes = _M_nodes->_M_left;
+        while (_M_nodes->_M_right)
+   _M_nodes = _M_nodes->_M_right;
+        if (_M_nodes->_M_left)
+   _M_nodes = _M_nodes->_M_left;
+      }
+  }
+       else
+  _M_nodes->_M_left = 0;
+     }
+   else
+     _M_root = 0;
+   return __node;
+ }
+ _Base_ptr _M_root;
+ _Base_ptr _M_nodes;
+ _Rb_tree& _M_t;
+      };
+      struct _Alloc_node
+      {
+ _Alloc_node(_Rb_tree& __t)
+ : _M_t(__t) { }
+ template<typename _Arg>
+   _Link_type
+   operator()(_Arg&& __arg) const
+   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }
+      private:
+ _Rb_tree& _M_t;
+      };
+    public:
+      typedef _Key key_type;
+      typedef _Val value_type;
+      typedef value_type* pointer;
+      typedef const value_type* const_pointer;
+      typedef value_type& reference;
+      typedef const value_type& const_reference;
+      typedef size_t size_type;
+      typedef ptrdiff_t difference_type;
+      typedef _Alloc allocator_type;
+      _Node_allocator&
+      _M_get_Node_allocator() noexcept
+      { return this->_M_impl; }
+      const _Node_allocator&
+      _M_get_Node_allocator() const noexcept
+      { return this->_M_impl; }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_get_Node_allocator()); }
+    protected:
+      _Link_type
+      _M_get_node()
+      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
+      void
+      _M_put_node(_Link_type __p) noexcept
+      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
+      template<typename... _Args>
+ void
+ _M_construct_node(_Link_type __node, _Args&&... __args)
+ {
+   try
+     {
+       ::new(__node) _Rb_tree_node<_Val>;
+       _Alloc_traits::construct(_M_get_Node_allocator(),
+           __node->_M_valptr(),
+           std::forward<_Args>(__args)...);
+     }
+   catch(...)
+     {
+       __node->~_Rb_tree_node<_Val>();
+       _M_put_node(__node);
+       throw;
+     }
+ }
+      template<typename... _Args>
+ _Link_type
+ _M_create_node(_Args&&... __args)
+ {
+   _Link_type __tmp = _M_get_node();
+   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
+   return __tmp;
+ }
+      void
+      _M_destroy_node(_Link_type __p) noexcept
+      {
+ _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
+ __p->~_Rb_tree_node<_Val>();
+      }
+      void
+      _M_drop_node(_Link_type __p) noexcept
+      {
+ _M_destroy_node(__p);
+ _M_put_node(__p);
+      }
+      template<bool _MoveValue, typename _NodeGen>
+ _Link_type
+ _M_clone_node(_Link_type __x, _NodeGen& __node_gen)
+ {
+   using _Vp = __conditional_t<_MoveValue,
+          value_type&&,
+          const value_type&>;
+   _Link_type __tmp
+     = __node_gen(std::forward<_Vp>(*__x->_M_valptr()));
+   __tmp->_M_color = __x->_M_color;
+   __tmp->_M_left = 0;
+   __tmp->_M_right = 0;
+   return __tmp;
+ }
+    protected:
+      template<typename _Key_compare,
+        bool = __is_pod(_Key_compare)>
+ struct _Rb_tree_impl
+ : public _Node_allocator
+ , public _Rb_tree_key_compare<_Key_compare>
+ , public _Rb_tree_header
+ {
+   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;
+   _Rb_tree_impl()
+     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)
+   : _Node_allocator()
+   { }
+   _Rb_tree_impl(const _Rb_tree_impl& __x)
+   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
+   , _Base_key_compare(__x._M_key_compare)
+   , _Rb_tree_header()
+   { }
+   _Rb_tree_impl(_Rb_tree_impl&&)
+     noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+   = default;
+   explicit
+   _Rb_tree_impl(_Node_allocator&& __a)
+   : _Node_allocator(std::move(__a))
+   { }
+   _Rb_tree_impl(_Rb_tree_impl&& __x, _Node_allocator&& __a)
+   : _Node_allocator(std::move(__a)),
+     _Base_key_compare(std::move(__x)),
+     _Rb_tree_header(std::move(__x))
+   { }
+   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
+   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
+   { }
+ };
+      _Rb_tree_impl<_Compare> _M_impl;
+    protected:
+      _Base_ptr&
+      _M_root() noexcept
+      { return this->_M_impl._M_header._M_parent; }
+      _Const_Base_ptr
+      _M_root() const noexcept
+      { return this->_M_impl._M_header._M_parent; }
+      _Base_ptr&
+      _M_leftmost() noexcept
+      { return this->_M_impl._M_header._M_left; }
+      _Const_Base_ptr
+      _M_leftmost() const noexcept
+      { return this->_M_impl._M_header._M_left; }
+      _Base_ptr&
+      _M_rightmost() noexcept
+      { return this->_M_impl._M_header._M_right; }
+      _Const_Base_ptr
+      _M_rightmost() const noexcept
+      { return this->_M_impl._M_header._M_right; }
+      _Link_type
+      _M_mbegin() const noexcept
+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
+      _Link_type
+      _M_begin() noexcept
+      { return _M_mbegin(); }
+      _Const_Link_type
+      _M_begin() const noexcept
+      {
+ return static_cast<_Const_Link_type>
+   (this->_M_impl._M_header._M_parent);
+      }
+      _Base_ptr
+      _M_end() noexcept
+      { return &this->_M_impl._M_header; }
+      _Const_Base_ptr
+      _M_end() const noexcept
+      { return &this->_M_impl._M_header; }
+      static const _Key&
+      _S_key(_Const_Link_type __x)
+      {
+ static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
+        "comparison object must be invocable "
+        "with two arguments of key type");
+ return _KeyOfValue()(*__x->_M_valptr());
+      }
+      static _Link_type
+      _S_left(_Base_ptr __x) noexcept
+      { return static_cast<_Link_type>(__x->_M_left); }
+      static _Const_Link_type
+      _S_left(_Const_Base_ptr __x) noexcept
+      { return static_cast<_Const_Link_type>(__x->_M_left); }
+      static _Link_type
+      _S_right(_Base_ptr __x) noexcept
+      { return static_cast<_Link_type>(__x->_M_right); }
+      static _Const_Link_type
+      _S_right(_Const_Base_ptr __x) noexcept
+      { return static_cast<_Const_Link_type>(__x->_M_right); }
+      static const _Key&
+      _S_key(_Const_Base_ptr __x)
+      { return _S_key(static_cast<_Const_Link_type>(__x)); }
+      static _Base_ptr
+      _S_minimum(_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_minimum(__x); }
+      static _Const_Base_ptr
+      _S_minimum(_Const_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_minimum(__x); }
+      static _Base_ptr
+      _S_maximum(_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_maximum(__x); }
+      static _Const_Base_ptr
+      _S_maximum(_Const_Base_ptr __x) noexcept
+      { return _Rb_tree_node_base::_S_maximum(__x); }
+    public:
+      typedef _Rb_tree_iterator<value_type> iterator;
+      typedef _Rb_tree_const_iterator<value_type> const_iterator;
+      typedef std::reverse_iterator<iterator> reverse_iterator;
+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_unique_pos(const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_equal_pos(const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_hint_unique_pos(const_iterator __pos,
+        const key_type& __k);
+      pair<_Base_ptr, _Base_ptr>
+      _M_get_insert_hint_equal_pos(const_iterator __pos,
+       const key_type& __k);
+    private:
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);
+      iterator
+      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
+      template<typename _Arg>
+ iterator
+ _M_insert_lower(_Base_ptr __y, _Arg&& __v);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal_lower(_Arg&& __x);
+      iterator
+      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
+      iterator
+      _M_insert_equal_lower_node(_Link_type __z);
+      enum { __as_lvalue, __as_rvalue };
+      template<bool _MoveValues, typename _NodeGen>
+ _Link_type
+ _M_copy(_Link_type, _Base_ptr, _NodeGen&);
+      template<bool _MoveValues, typename _NodeGen>
+ _Link_type
+ _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
+ {
+   _Link_type __root =
+     _M_copy<_MoveValues>(__x._M_mbegin(), _M_end(), __gen);
+   _M_leftmost() = _S_minimum(__root);
+   _M_rightmost() = _S_maximum(__root);
+   _M_impl._M_node_count = __x._M_impl._M_node_count;
+   return __root;
+ }
+      _Link_type
+      _M_copy(const _Rb_tree& __x)
+      {
+ _Alloc_node __an(*this);
+ return _M_copy<__as_lvalue>(__x, __an);
+      }
+      void
+      _M_erase(_Link_type __x);
+      iterator
+      _M_lower_bound(_Link_type __x, _Base_ptr __y,
+       const _Key& __k);
+      const_iterator
+      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+       const _Key& __k) const;
+      iterator
+      _M_upper_bound(_Link_type __x, _Base_ptr __y,
+       const _Key& __k);
+      const_iterator
+      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+       const _Key& __k) const;
+    public:
+      _Rb_tree() = default;
+      _Rb_tree(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_impl(__comp, _Node_allocator(__a)) { }
+      _Rb_tree(const _Rb_tree& __x)
+      : _M_impl(__x._M_impl)
+      {
+ if (__x._M_root() != 0)
+   _M_root() = _M_copy(__x);
+      }
+      _Rb_tree(const allocator_type& __a)
+      : _M_impl(_Node_allocator(__a))
+      { }
+      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
+      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
+      {
+ if (__x._M_root() != nullptr)
+   _M_root() = _M_copy(__x);
+      }
+      _Rb_tree(_Rb_tree&&) = default;
+      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
+      : _Rb_tree(std::move(__x), _Node_allocator(__a))
+      { }
+    private:
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, true_type)
+      noexcept(is_nothrow_default_constructible<_Compare>::value)
+      : _M_impl(std::move(__x._M_impl), std::move(__a))
+      { }
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, false_type)
+      : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
+      {
+ if (__x._M_root() != nullptr)
+   _M_move_data(__x, false_type{});
+      }
+    public:
+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
+      noexcept( noexcept(
+ _Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
+   std::declval<typename _Alloc_traits::is_always_equal>())) )
+      : _Rb_tree(std::move(__x), std::move(__a),
+   typename _Alloc_traits::is_always_equal{})
+      { }
+      ~_Rb_tree() noexcept
+      { _M_erase(_M_begin()); }
+      _Rb_tree&
+      operator=(const _Rb_tree& __x);
+      _Compare
+      key_comp() const
+      { return _M_impl._M_key_compare; }
+      iterator
+      begin() noexcept
+      { return iterator(this->_M_impl._M_header._M_left); }
+      const_iterator
+      begin() const noexcept
+      { return const_iterator(this->_M_impl._M_header._M_left); }
+      iterator
+      end() noexcept
+      { return iterator(&this->_M_impl._M_header); }
+      const_iterator
+      end() const noexcept
+      { return const_iterator(&this->_M_impl._M_header); }
+      reverse_iterator
+      rbegin() noexcept
+      { return reverse_iterator(end()); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return const_reverse_iterator(end()); }
+      reverse_iterator
+      rend() noexcept
+      { return reverse_iterator(begin()); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return const_reverse_iterator(begin()); }
+                         bool
+      empty() const noexcept
+      { return _M_impl._M_node_count == 0; }
+      size_type
+      size() const noexcept
+      { return _M_impl._M_node_count; }
+      size_type
+      max_size() const noexcept
+      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
+      void
+      swap(_Rb_tree& __t)
+      noexcept(__is_nothrow_swappable<_Compare>::value);
+      template<typename _Arg>
+ pair<iterator, bool>
+ _M_insert_unique(_Arg&& __x);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal(_Arg&& __x);
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);
+      template<typename _Arg>
+ iterator
+ _M_insert_unique_(const_iterator __pos, _Arg&& __x)
+ {
+   _Alloc_node __an(*this);
+   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
+ }
+      template<typename _Arg, typename _NodeGen>
+ iterator
+ _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);
+      template<typename _Arg>
+ iterator
+ _M_insert_equal_(const_iterator __pos, _Arg&& __x)
+ {
+   _Alloc_node __an(*this);
+   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
+ }
+      template<typename... _Args>
+ pair<iterator, bool>
+ _M_emplace_unique(_Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_equal(_Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
+      template<typename... _Args>
+ iterator
+ _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
+      template<typename _Iter>
+ using __same_value_type
+   = is_same<value_type, typename iterator_traits<_Iter>::value_type>;
+      template<typename _InputIterator>
+ __enable_if_t<__same_value_type<_InputIterator>::value>
+ _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_insert_unique_(end(), *__first, __an);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<!__same_value_type<_InputIterator>::value>
+ _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
+ {
+   for (; __first != __last; ++__first)
+     _M_emplace_unique(*__first);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<__same_value_type<_InputIterator>::value>
+ _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_insert_equal_(end(), *__first, __an);
+ }
+      template<typename _InputIterator>
+ __enable_if_t<!__same_value_type<_InputIterator>::value>
+ _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
+ {
+   _Alloc_node __an(*this);
+   for (; __first != __last; ++__first)
+     _M_emplace_equal(*__first);
+ }
+    private:
+      void
+      _M_erase_aux(const_iterator __position);
+      void
+      _M_erase_aux(const_iterator __first, const_iterator __last);
+    public:
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      {
+ do { if (std::__is_constant_evaluated() && !bool(__position != end())) __builtin_unreachable(); } while (false);
+ const_iterator __result = __position;
+ ++__result;
+ _M_erase_aux(__position);
+ return __result._M_const_cast();
+      }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      {
+ do { if (std::__is_constant_evaluated() && !bool(__position != end())) __builtin_unreachable(); } while (false);
+ iterator __result = __position;
+ ++__result;
+ _M_erase_aux(__position);
+ return __result;
+      }
+      size_type
+      erase(const key_type& __x);
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      {
+ _M_erase_aux(__first, __last);
+ return __last._M_const_cast();
+      }
+      void
+      clear() noexcept
+      {
+ _M_erase(_M_begin());
+ _M_impl._M_reset();
+      }
+      iterator
+      find(const key_type& __k);
+      const_iterator
+      find(const key_type& __k) const;
+      size_type
+      count(const key_type& __k) const;
+      iterator
+      lower_bound(const key_type& __k)
+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
+      const_iterator
+      lower_bound(const key_type& __k) const
+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
+      iterator
+      upper_bound(const key_type& __k)
+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
+      const_iterator
+      upper_bound(const key_type& __k) const
+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
+      pair<iterator, iterator>
+      equal_range(const key_type& __k);
+      pair<const_iterator, const_iterator>
+      equal_range(const key_type& __k) const;
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_find_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_find_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_find_tr(const _Kt& __k) const
+ {
+   auto __j = _M_lower_bound_tr(__k);
+   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
+     __j = end();
+   return __j;
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ size_type
+ _M_count_tr(const _Kt& __k) const
+ {
+   auto __p = _M_equal_range_tr(__k);
+   return std::distance(__p.first, __p.second);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_lower_bound_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_lower_bound_tr(const _Kt& __k) const
+ {
+   auto __x = _M_begin();
+   auto __y = _M_end();
+   while (__x != 0)
+     if (!_M_impl._M_key_compare(_S_key(__x), __k))
+       {
+  __y = __x;
+  __x = _S_left(__x);
+       }
+     else
+       __x = _S_right(__x);
+   return const_iterator(__y);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ iterator
+ _M_upper_bound_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ const_iterator
+ _M_upper_bound_tr(const _Kt& __k) const
+ {
+   auto __x = _M_begin();
+   auto __y = _M_end();
+   while (__x != 0)
+     if (_M_impl._M_key_compare(__k, _S_key(__x)))
+       {
+  __y = __x;
+  __x = _S_left(__x);
+       }
+     else
+       __x = _S_right(__x);
+   return const_iterator(__y);
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ pair<iterator, iterator>
+ _M_equal_range_tr(const _Kt& __k)
+ {
+   const _Rb_tree* __const_this = this;
+   auto __ret = __const_this->_M_equal_range_tr(__k);
+   return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
+ }
+      template<typename _Kt,
+        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
+ pair<const_iterator, const_iterator>
+ _M_equal_range_tr(const _Kt& __k) const
+ {
+   auto __low = _M_lower_bound_tr(__k);
+   auto __high = __low;
+   auto& __cmp = _M_impl._M_key_compare;
+   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
+     ++__high;
+   return { __low, __high };
+ }
+      bool
+      __rb_verify() const;
+      _Rb_tree&
+      operator=(_Rb_tree&&)
+      noexcept(_Alloc_traits::_S_nothrow_move()
+        && is_nothrow_move_assignable<_Compare>::value);
+      template<typename _Iterator>
+ void
+ _M_assign_unique(_Iterator, _Iterator);
+      template<typename _Iterator>
+ void
+ _M_assign_equal(_Iterator, _Iterator);
+    private:
+      void
+      _M_move_data(_Rb_tree& __x, true_type)
+      { _M_impl._M_move_data(__x._M_impl); }
+      void
+      _M_move_data(_Rb_tree&, false_type);
+      void
+      _M_move_assign(_Rb_tree&, true_type);
+      void
+      _M_move_assign(_Rb_tree&, false_type);
+      friend bool
+      operator==(const _Rb_tree& __x, const _Rb_tree& __y)
+      {
+ return __x.size() == __y.size()
+   && std::equal(__x.begin(), __x.end(), __y.begin());
+      }
+      friend bool
+      operator<(const _Rb_tree& __x, const _Rb_tree& __y)
+      {
+ return std::lexicographical_compare(__x.begin(), __x.end(),
+         __y.begin(), __y.end());
+      }
+    private:
+      struct _Auto_node
+      {
+ template<typename... _Args>
+   _Auto_node(_Rb_tree& __t, _Args&&... __args)
+   : _M_t(__t),
+     _M_node(__t._M_create_node(std::forward<_Args>(__args)...))
+   { }
+ ~_Auto_node()
+ {
+   if (_M_node)
+     _M_t._M_drop_node(_M_node);
+ }
+ _Auto_node(_Auto_node&& __n)
+ : _M_t(__n._M_t), _M_node(__n._M_node)
+ { __n._M_node = nullptr; }
+ const _Key&
+ _M_key() const
+ { return _S_key(_M_node); }
+ iterator
+ _M_insert(pair<_Base_ptr, _Base_ptr> __p)
+ {
+   auto __it = _M_t._M_insert_node(__p.first, __p.second, _M_node);
+   _M_node = nullptr;
+   return __it;
+ }
+ iterator
+ _M_insert_equal_lower()
+ {
+   auto __it = _M_t._M_insert_equal_lower_node(_M_node);
+   _M_node = nullptr;
+   return __it;
+ }
+ _Rb_tree& _M_t;
+ _Link_type _M_node;
+      };
+    };
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline void
+    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
+  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
+    { __x.swap(__y); }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_data(_Rb_tree& __x, false_type)
+    {
+      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
+ _M_move_data(__x, true_type());
+      else
+ {
+   constexpr bool __move = !__move_if_noexcept_cond<value_type>::value;
+   _Alloc_node __an(*this);
+   _M_root() = _M_copy<__move>(__x, __an);
+   if (__move)
+     __x.clear();
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_assign(_Rb_tree& __x, true_type)
+    {
+      clear();
+      if (__x._M_root() != nullptr)
+ _M_move_data(__x, true_type());
+      std::__alloc_on_move(_M_get_Node_allocator(),
+      __x._M_get_Node_allocator());
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_move_assign(_Rb_tree& __x, false_type)
+    {
+      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
+ return _M_move_assign(__x, true_type{});
+      _Reuse_or_alloc_node __roan(*this);
+      _M_impl._M_reset();
+      if (__x._M_root() != nullptr)
+ {
+   _M_root() = _M_copy<__as_rvalue>(__x, __roan);
+   __x.clear();
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    operator=(_Rb_tree&& __x)
+    noexcept(_Alloc_traits::_S_nothrow_move()
+      && is_nothrow_move_assignable<_Compare>::value)
+    {
+      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
+      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
+      return *this;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Iterator>
+      void
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_assign_unique(_Iterator __first, _Iterator __last)
+      {
+ _Reuse_or_alloc_node __roan(*this);
+ _M_impl._M_reset();
+ for (; __first != __last; ++__first)
+   _M_insert_unique_(end(), *__first, __roan);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Iterator>
+      void
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_assign_equal(_Iterator __first, _Iterator __last)
+      {
+ _Reuse_or_alloc_node __roan(*this);
+ _M_impl._M_reset();
+ for (; __first != __last; ++__first)
+   _M_insert_equal_(end(), *__first, __roan);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    operator=(const _Rb_tree& __x)
+    {
+      if (this != std::__addressof(__x))
+ {
+   if (_Alloc_traits::_S_propagate_on_copy_assign())
+     {
+       auto& __this_alloc = this->_M_get_Node_allocator();
+       auto& __that_alloc = __x._M_get_Node_allocator();
+       if (!_Alloc_traits::_S_always_equal()
+    && __this_alloc != __that_alloc)
+  {
+    clear();
+    std::__alloc_on_copy(__this_alloc, __that_alloc);
+  }
+     }
+   _Reuse_or_alloc_node __roan(*this);
+   _M_impl._M_reset();
+   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
+   if (__x._M_root() != 0)
+     _M_root() = _M_copy<__as_lvalue>(__x, __roan);
+ }
+      return *this;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_(_Base_ptr __x, _Base_ptr __p,
+   _Arg&& __v,
+   _NodeGen& __node_gen)
+      {
+ bool __insert_left = (__x != 0 || __p == _M_end()
+         || _M_impl._M_key_compare(_KeyOfValue()(__v),
+       _S_key(__p)));
+ _Link_type __z = __node_gen(std::forward<_Arg>(__v));
+ _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+          this->_M_impl._M_header);
+ ++_M_impl._M_node_count;
+ return iterator(__z);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
+    {
+      bool __insert_left = (__p == _M_end()
+       || !_M_impl._M_key_compare(_S_key(__p),
+             _KeyOfValue()(__v)));
+      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal_lower(_Arg&& __v)
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _M_insert_lower(__y, std::forward<_Arg>(__v));
+    }
+  template<typename _Key, typename _Val, typename _KoV,
+    typename _Compare, typename _Alloc>
+    template<bool _MoveValues, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
+      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
+      _M_copy(_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
+      {
+ _Link_type __top = _M_clone_node<_MoveValues>(__x, __node_gen);
+ __top->_M_parent = __p;
+ try
+   {
+     if (__x->_M_right)
+       __top->_M_right =
+  _M_copy<_MoveValues>(_S_right(__x), __top, __node_gen);
+     __p = __top;
+     __x = _S_left(__x);
+     while (__x != 0)
+       {
+  _Link_type __y = _M_clone_node<_MoveValues>(__x, __node_gen);
+  __p->_M_left = __y;
+  __y->_M_parent = __p;
+  if (__x->_M_right)
+    __y->_M_right = _M_copy<_MoveValues>(_S_right(__x),
+             __y, __node_gen);
+  __p = __y;
+  __x = _S_left(__x);
+       }
+   }
+ catch(...)
+   {
+     _M_erase(__top);
+     throw;
+   }
+ return __top;
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase(_Link_type __x)
+    {
+      while (__x != 0)
+ {
+   _M_erase(_S_right(__x));
+   _Link_type __y = _S_left(__x);
+   _M_drop_node(__x);
+   __x = __y;
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_lower_bound(_Link_type __x, _Base_ptr __y,
+     const _Key& __k)
+    {
+      while (__x != 0)
+ if (!_M_impl._M_key_compare(_S_key(__x), __k))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+     const _Key& __k) const
+    {
+      while (__x != 0)
+ if (!_M_impl._M_key_compare(_S_key(__x), __k))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return const_iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_upper_bound(_Link_type __x, _Base_ptr __y,
+     const _Key& __k)
+    {
+      while (__x != 0)
+ if (_M_impl._M_key_compare(__k, _S_key(__x)))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
+     const _Key& __k) const
+    {
+      while (__x != 0)
+ if (_M_impl._M_key_compare(__k, _S_key(__x)))
+   __y = __x, __x = _S_left(__x);
+ else
+   __x = _S_right(__x);
+      return const_iterator(__y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    equal_range(const _Key& __k)
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   if (_M_impl._M_key_compare(_S_key(__x), __k))
+     __x = _S_right(__x);
+   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
+     __y = __x, __x = _S_left(__x);
+   else
+     {
+       _Link_type __xu(__x);
+       _Base_ptr __yu(__y);
+       __y = __x, __x = _S_left(__x);
+       __xu = _S_right(__xu);
+       return pair<iterator,
+     iterator>(_M_lower_bound(__x, __y, __k),
+        _M_upper_bound(__xu, __yu, __k));
+     }
+ }
+      return pair<iterator, iterator>(iterator(__y),
+          iterator(__y));
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::const_iterator,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::const_iterator>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    equal_range(const _Key& __k) const
+    {
+      _Const_Link_type __x = _M_begin();
+      _Const_Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   if (_M_impl._M_key_compare(_S_key(__x), __k))
+     __x = _S_right(__x);
+   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
+     __y = __x, __x = _S_left(__x);
+   else
+     {
+       _Const_Link_type __xu(__x);
+       _Const_Base_ptr __yu(__y);
+       __y = __x, __x = _S_left(__x);
+       __xu = _S_right(__xu);
+       return pair<const_iterator,
+     const_iterator>(_M_lower_bound(__x, __y, __k),
+       _M_upper_bound(__xu, __yu, __k));
+     }
+ }
+      return pair<const_iterator, const_iterator>(const_iterator(__y),
+        const_iterator(__y));
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    swap(_Rb_tree& __t)
+    noexcept(__is_nothrow_swappable<_Compare>::value)
+    {
+      if (_M_root() == 0)
+ {
+   if (__t._M_root() != 0)
+     _M_impl._M_move_data(__t._M_impl);
+ }
+      else if (__t._M_root() == 0)
+ __t._M_impl._M_move_data(_M_impl);
+      else
+ {
+   std::swap(_M_root(),__t._M_root());
+   std::swap(_M_leftmost(),__t._M_leftmost());
+   std::swap(_M_rightmost(),__t._M_rightmost());
+   _M_root()->_M_parent = _M_end();
+   __t._M_root()->_M_parent = __t._M_end();
+   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
+ }
+      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
+      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
+    __t._M_get_Node_allocator());
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_unique_pos(const key_type& __k)
+    {
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      bool __comp = true;
+      while (__x != 0)
+ {
+   __y = __x;
+   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
+   __x = __comp ? _S_left(__x) : _S_right(__x);
+ }
+      iterator __j = iterator(__y);
+      if (__comp)
+ {
+   if (__j == begin())
+     return _Res(__x, __y);
+   else
+     --__j;
+ }
+      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
+ return _Res(__x, __y);
+      return _Res(__j._M_node, 0);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_equal_pos(const key_type& __k)
+    {
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _Res(__x, __y);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::iterator, bool>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_unique(_Arg&& __v)
+    {
+      typedef pair<iterator, bool> _Res;
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_unique_pos(_KeyOfValue()(__v));
+      if (__res.second)
+ {
+   _Alloc_node __an(*this);
+   return _Res(_M_insert_(__res.first, __res.second,
+     std::forward<_Arg>(__v), __an),
+        true);
+ }
+      return _Res(iterator(__res.first), false);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal(_Arg&& __v)
+    {
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_equal_pos(_KeyOfValue()(__v));
+      _Alloc_node __an(*this);
+      return _M_insert_(__res.first, __res.second,
+   std::forward<_Arg>(__v), __an);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_hint_unique_pos(const_iterator __position,
+      const key_type& __k)
+    {
+      iterator __pos = __position._M_const_cast();
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      if (__pos._M_node == _M_end())
+ {
+   if (size() > 0
+       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
+     return _Res(0, _M_rightmost());
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
+ {
+   iterator __before = __pos;
+   if (__pos._M_node == _M_leftmost())
+     return _Res(_M_leftmost(), _M_leftmost());
+   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
+     {
+       if (_S_right(__before._M_node) == 0)
+  return _Res(0, __before._M_node);
+       else
+  return _Res(__pos._M_node, __pos._M_node);
+     }
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
+ {
+   iterator __after = __pos;
+   if (__pos._M_node == _M_rightmost())
+     return _Res(0, _M_rightmost());
+   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
+     {
+       if (_S_right(__pos._M_node) == 0)
+  return _Res(0, __pos._M_node);
+       else
+  return _Res(__after._M_node, __after._M_node);
+     }
+   else
+     return _M_get_insert_unique_pos(__k);
+ }
+      else
+ return _Res(__pos._M_node, 0);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_unique_(const_iterator __position,
+   _Arg&& __v,
+   _NodeGen& __node_gen)
+    {
+      pair<_Base_ptr, _Base_ptr> __res
+ = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
+      if (__res.second)
+ return _M_insert_(__res.first, __res.second,
+     std::forward<_Arg>(__v),
+     __node_gen);
+      return iterator(__res.first);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr,
+  typename _Rb_tree<_Key, _Val, _KeyOfValue,
+      _Compare, _Alloc>::_Base_ptr>
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
+    {
+      iterator __pos = __position._M_const_cast();
+      typedef pair<_Base_ptr, _Base_ptr> _Res;
+      if (__pos._M_node == _M_end())
+ {
+   if (size() > 0
+       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
+     return _Res(0, _M_rightmost());
+   else
+     return _M_get_insert_equal_pos(__k);
+ }
+      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
+ {
+   iterator __before = __pos;
+   if (__pos._M_node == _M_leftmost())
+     return _Res(_M_leftmost(), _M_leftmost());
+   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
+     {
+       if (_S_right(__before._M_node) == 0)
+  return _Res(0, __before._M_node);
+       else
+  return _Res(__pos._M_node, __pos._M_node);
+     }
+   else
+     return _M_get_insert_equal_pos(__k);
+ }
+      else
+ {
+   iterator __after = __pos;
+   if (__pos._M_node == _M_rightmost())
+     return _Res(0, _M_rightmost());
+   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
+     {
+       if (_S_right(__pos._M_node) == 0)
+  return _Res(0, __pos._M_node);
+       else
+  return _Res(__after._M_node, __after._M_node);
+     }
+   else
+     return _Res(0, 0);
+ }
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename _Arg, typename _NodeGen>
+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_insert_equal_(const_iterator __position,
+         _Arg&& __v,
+         _NodeGen& __node_gen)
+      {
+ pair<_Base_ptr, _Base_ptr> __res
+   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
+ if (__res.second)
+   return _M_insert_(__res.first, __res.second,
+       std::forward<_Arg>(__v),
+       __node_gen);
+ return _M_insert_equal_lower(std::forward<_Arg>(__v));
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
+    -> iterator
+    {
+      bool __insert_left = (__x != 0 || __p == _M_end()
+       || _M_impl._M_key_compare(_S_key(__z),
+            _S_key(__p)));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
+    -> iterator
+    {
+      bool __insert_left = (__p == _M_end()
+       || !_M_impl._M_key_compare(_S_key(__p),
+             _S_key(__z)));
+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
+        this->_M_impl._M_header);
+      ++_M_impl._M_node_count;
+      return iterator(__z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    auto
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_insert_equal_lower_node(_Link_type __z)
+    -> iterator
+    {
+      _Link_type __x = _M_begin();
+      _Base_ptr __y = _M_end();
+      while (__x != 0)
+ {
+   __y = __x;
+   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
+  _S_left(__x) : _S_right(__x);
+ }
+      return _M_insert_lower_node(__y, __z);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_unique(_Args&&... __args)
+      -> pair<iterator, bool>
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_unique_pos(__z._M_key());
+ if (__res.second)
+   return {__z._M_insert(__res), true};
+ return {iterator(__res.first), false};
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_equal(_Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_equal_pos(__z._M_key());
+ return __z._M_insert(__res);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_hint_unique_pos(__pos, __z._M_key());
+ if (__res.second)
+   return __z._M_insert(__res);
+ return iterator(__res.first);
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    template<typename... _Args>
+      auto
+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
+      -> iterator
+      {
+ _Auto_node __z(*this, std::forward<_Args>(__args)...);
+ auto __res = _M_get_insert_hint_equal_pos(__pos, __z._M_key());
+ if (__res.second)
+   return __z._M_insert(__res);
+ return __z._M_insert_equal_lower();
+      }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase_aux(const_iterator __position)
+    {
+      _Link_type __y =
+ static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
+    (const_cast<_Base_ptr>(__position._M_node),
+     this->_M_impl._M_header));
+      _M_drop_node(__y);
+      --_M_impl._M_node_count;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    void
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    _M_erase_aux(const_iterator __first, const_iterator __last)
+    {
+      if (__first == begin() && __last == end())
+ clear();
+      else
+ while (__first != __last)
+   _M_erase_aux(__first++);
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    erase(const _Key& __x)
+    {
+      pair<iterator, iterator> __p = equal_range(__x);
+      const size_type __old_size = size();
+      _M_erase_aux(__p.first, __p.second);
+      return __old_size - size();
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    find(const _Key& __k)
+    {
+      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
+      return (__j == end()
+       || _M_impl._M_key_compare(__k,
+     _S_key(__j._M_node))) ? end() : __j;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue,
+        _Compare, _Alloc>::const_iterator
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    find(const _Key& __k) const
+    {
+      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
+      return (__j == end()
+       || _M_impl._M_key_compare(__k,
+     _S_key(__j._M_node))) ? end() : __j;
+    }
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
+    count(const _Key& __k) const
+    {
+      pair<const_iterator, const_iterator> __p = equal_range(__k);
+      const size_type __n = std::distance(__p.first, __p.second);
+      return __n;
+    }
+  __attribute__ ((__pure__)) unsigned int
+  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
+         const _Rb_tree_node_base* __root) throw ();
+  template<typename _Key, typename _Val, typename _KeyOfValue,
+    typename _Compare, typename _Alloc>
+    bool
+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
+    {
+      if (_M_impl._M_node_count == 0 || begin() == end())
+ return _M_impl._M_node_count == 0 && begin() == end()
+        && this->_M_impl._M_header._M_left == _M_end()
+        && this->_M_impl._M_header._M_right == _M_end();
+      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
+      for (const_iterator __it = begin(); __it != end(); ++__it)
+ {
+   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
+   _Const_Link_type __L = _S_left(__x);
+   _Const_Link_type __R = _S_right(__x);
+   if (__x->_M_color == _S_red)
+     if ((__L && __L->_M_color == _S_red)
+  || (__R && __R->_M_color == _S_red))
+       return false;
+   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
+     return false;
+   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
+     return false;
+   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
+     return false;
+ }
+      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
+ return false;
+      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
+ return false;
+      return true;
+    }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<typename _Key, typename _Compare, typename _Alloc>
+    class multiset;
+  template<typename _Key, typename _Compare = std::less<_Key>,
+    typename _Alloc = std::allocator<_Key> >
+    class set
+    {
+      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
+   "std::set must have a non-const, non-volatile value_type");
+    public:
+      typedef _Key key_type;
+      typedef _Key value_type;
+      typedef _Compare key_compare;
+      typedef _Compare value_compare;
+      typedef _Alloc allocator_type;
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Key>::other _Key_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
+         key_compare, _Key_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::const_iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      set() = default;
+      explicit
+      set(const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a)) { }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last,
+     const _Compare& __comp,
+     const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Key_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      set(const set&) = default;
+      set(set&&) = default;
+      set(initializer_list<value_type> __l,
+   const _Compare& __comp = _Compare(),
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      explicit
+      set(const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a)) { }
+      set(const set& __x, const __type_identity_t<allocator_type>& __a)
+      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }
+      set(set&& __x, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }
+      set(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ set(_InputIterator __first, _InputIterator __last,
+     const allocator_type& __a)
+ : _M_t(_Key_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      ~set() = default;
+      set&
+      operator=(const set&) = default;
+      set&
+      operator=(set&&) = default;
+      set&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_unique(__l.begin(), __l.end());
+ return *this;
+      }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return _M_t.key_comp(); }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      void
+      swap(set& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      template<typename... _Args>
+ std::pair<iterator, bool>
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_unique(__pos,
+          std::forward<_Args>(__args)...);
+ }
+      std::pair<iterator, bool>
+      insert(const value_type& __x)
+      {
+ std::pair<typename _Rep_type::iterator, bool> __p =
+   _M_t._M_insert_unique(__x);
+ return std::pair<iterator, bool>(__p.first, __p.second);
+      }
+      std::pair<iterator, bool>
+      insert(value_type&& __x)
+      {
+ std::pair<typename _Rep_type::iterator, bool> __p =
+   _M_t._M_insert_unique(std::move(__x));
+ return std::pair<iterator, bool>(__p.first, __p.second);
+      }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_unique_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_unique(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const
+ -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x)
+ -> decltype(iterator{_M_t._M_find_tr(__x)})
+ { return iterator{_M_t._M_find_tr(__x)}; }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const
+ -> decltype(const_iterator{_M_t._M_find_tr(__x)})
+ { return const_iterator{_M_t._M_find_tr(__x)}; }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const set<_Key, _Compare, _Alloc>& __x,
+       const set<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const set<_Key, _Compare, _Alloc>& __x,
+       const set<_Key, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const set<_Key, _Compare, _Alloc>& __x,
+        const set<_Key, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline void
+    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<typename _Key, typename _Compare, typename _Alloc>
+    class set;
+  template <typename _Key, typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<_Key> >
+    class multiset
+    {
+      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
+   "std::multiset must have a non-const, non-volatile value_type");
+    public:
+      typedef _Key key_type;
+      typedef _Key value_type;
+      typedef _Compare key_compare;
+      typedef _Compare value_compare;
+      typedef _Alloc allocator_type;
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<_Key>::other _Key_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
+         key_compare, _Key_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::const_iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      multiset() = default;
+      explicit
+      multiset(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a)) { }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last,
+   const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Key_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      multiset(const multiset&) = default;
+      multiset(multiset&&) = default;
+      multiset(initializer_list<value_type> __l,
+        const _Compare& __comp = _Compare(),
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Key_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      explicit
+      multiset(const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a)) { }
+      multiset(const multiset& __m,
+        const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }
+      multiset(multiset&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }
+      multiset(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Key_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ multiset(_InputIterator __first, _InputIterator __last,
+   const allocator_type& __a)
+ : _M_t(_Key_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      ~multiset() = default;
+      multiset&
+      operator=(const multiset&) = default;
+      multiset&
+      operator=(multiset&&) = default;
+      multiset&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_equal(__l.begin(), __l.end());
+ return *this;
+      }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return _M_t.key_comp(); }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      void
+      swap(multiset& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      template<typename... _Args>
+ iterator
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_equal(__pos,
+         std::forward<_Args>(__args)...);
+ }
+      iterator
+      insert(const value_type& __x)
+      { return _M_t._M_insert_equal(__x); }
+      iterator
+      insert(value_type&& __x)
+      { return _M_t._M_insert_equal(std::move(__x)); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_equal_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_equal(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.count(__x); }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x)
+ -> decltype(iterator{_M_t._M_find_tr(__x)})
+ { return iterator{_M_t._M_find_tr(__x)}; }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const
+ -> decltype(const_iterator{_M_t._M_find_tr(__x)})
+ { return const_iterator{_M_t._M_find_tr(__x)}; }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator==(const multiset<_K1, _C1, _A1>&,
+     const multiset<_K1, _C1, _A1>&);
+      template<typename _K1, typename _C1, typename _A1>
+ friend bool
+ operator< (const multiset<_K1, _C1, _A1>&,
+     const multiset<_K1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
+       const multiset<_Key, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
+       const multiset<_Key,_Compare,_Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
+        const multiset<_Key, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Compare, typename _Alloc>
+    inline void
+    swap(multiset<_Key, _Compare, _Alloc>& __x,
+  multiset<_Key, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+
+namespace std
+{
+  namespace __detail
+  {
+    template<typename _Container, typename _UnsafeContainer,
+      typename _Predicate>
+      typename _Container::size_type
+      __erase_nodes_if(_Container& __cont, _UnsafeContainer& __ucont,
+         _Predicate __pred)
+      {
+ typename _Container::size_type __num = 0;
+ for (auto __iter = __ucont.begin(), __last = __ucont.end();
+      __iter != __last;)
+   {
+     if (__pred(*__iter))
+       {
+  __iter = __cont.erase(__iter);
+  ++__num;
+       }
+     else
+       ++__iter;
+   }
+ return __num;
+      }
+  }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    class multimap;
+  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
+    class map
+    {
+    public:
+      typedef _Key key_type;
+      typedef _Tp mapped_type;
+      typedef std::pair<const _Key, _Tp> value_type;
+      typedef _Compare key_compare;
+      typedef _Alloc allocator_type;
+    private:
+    public:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+      class value_compare
+      : public std::binary_function<value_type, value_type, bool>
+      {
+ friend class map<_Key, _Tp, _Compare, _Alloc>;
+      protected:
+ _Compare comp;
+ value_compare(_Compare __c)
+ : comp(__c) { }
+      public:
+ bool operator()(const value_type& __x, const value_type& __y) const
+ { return comp(__x.first, __y.first); }
+      };
+#pragma GCC diagnostic pop
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<value_type>::other _Pair_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
+         key_compare, _Pair_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      typedef typename _Rep_type::reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      map() = default;
+      explicit
+      map(const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a)) { }
+      map(const map&) = default;
+      map(map&&) = default;
+      map(initializer_list<value_type> __l,
+   const _Compare& __comp = _Compare(),
+   const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      explicit
+      map(const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a)) { }
+      map(const map& __m, const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }
+      map(map&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }
+      map(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a))
+      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last,
+     const allocator_type& __a)
+ : _M_t(_Pair_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_unique(__first, __last); }
+      template<typename _InputIterator>
+ map(_InputIterator __first, _InputIterator __last,
+     const _Compare& __comp,
+     const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Pair_alloc_type(__a))
+ { _M_t._M_insert_range_unique(__first, __last); }
+      ~map() = default;
+      map&
+      operator=(const map&) = default;
+      map&
+      operator=(map&&) = default;
+      map&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_unique(__l.begin(), __l.end());
+ return *this;
+      }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() noexcept
+      { return _M_t.end(); }
+      const_iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() noexcept
+      { return _M_t.rend(); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      const_iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      const_reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      mapped_type&
+      operator[](const key_type& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
+         std::tuple<const key_type&>(__k),
+         std::tuple<>());
+ return (*__i).second;
+      }
+      mapped_type&
+      operator[](key_type&& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
+     std::forward_as_tuple(std::move(__k)),
+     std::tuple<>());
+ return (*__i).second;
+      }
+      mapped_type&
+      at(const key_type& __k)
+      {
+ iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __throw_out_of_range(("map::at"));
+ return (*__i).second;
+      }
+      const mapped_type&
+      at(const key_type& __k) const
+      {
+ const_iterator __i = lower_bound(__k);
+ if (__i == end() || key_comp()(__k, (*__i).first))
+   __throw_out_of_range(("map::at"));
+ return (*__i).second;
+      }
+      template<typename... _Args>
+ std::pair<iterator, bool>
+ emplace(_Args&&... __args)
+ {
+   return _M_t._M_emplace_unique(std::forward<_Args>(__args)...);
+ }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_unique(__pos,
+          std::forward<_Args>(__args)...);
+ }
+      std::pair<iterator, bool>
+      insert(const value_type& __x)
+      { return _M_t._M_insert_unique(__x); }
+      std::pair<iterator, bool>
+      insert(value_type&& __x)
+      { return _M_t._M_insert_unique(std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value,
+        pair<iterator, bool>>
+ insert(_Pair&& __x)
+ {
+   return _M_t._M_emplace_unique(std::forward<_Pair>(__x));
+ }
+      void
+      insert(std::initializer_list<value_type> __list)
+      { insert(__list.begin(), __list.end()); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_unique_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
+ insert(const_iterator __position, _Pair&& __x)
+ {
+   return _M_t._M_emplace_hint_unique(__position,
+          std::forward<_Pair>(__x));
+ }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_unique(__first, __last); }
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      swap(map& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return value_compare(_M_t.key_comp()); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x)))
+ {
+   return pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x));
+ }
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator==(const map<_K1, _T1, _C1, _A1>&,
+     const map<_K1, _T1, _C1, _A1>&);
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator<(const map<_K1, _T1, _C1, _A1>&,
+    const map<_K1, _T1, _C1, _A1>&);
+    };
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+       const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+       const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
+        const map<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline void
+    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
+  map<_Key, _Tp, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    class map;
+  template <typename _Key, typename _Tp,
+     typename _Compare = std::less<_Key>,
+     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
+    class multimap
+    {
+    public:
+      typedef _Key key_type;
+      typedef _Tp mapped_type;
+      typedef std::pair<const _Key, _Tp> value_type;
+      typedef _Compare key_compare;
+      typedef _Alloc allocator_type;
+    private:
+    public:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+      class value_compare
+      : public std::binary_function<value_type, value_type, bool>
+      {
+ friend class multimap<_Key, _Tp, _Compare, _Alloc>;
+      protected:
+ _Compare comp;
+ value_compare(_Compare __c)
+ : comp(__c) { }
+      public:
+ bool operator()(const value_type& __x, const value_type& __y) const
+ { return comp(__x.first, __y.first); }
+      };
+#pragma GCC diagnostic pop
+    private:
+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
+ rebind<value_type>::other _Pair_alloc_type;
+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
+         key_compare, _Pair_alloc_type> _Rep_type;
+      _Rep_type _M_t;
+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
+    public:
+      typedef typename _Alloc_traits::pointer pointer;
+      typedef typename _Alloc_traits::const_pointer const_pointer;
+      typedef typename _Alloc_traits::reference reference;
+      typedef typename _Alloc_traits::const_reference const_reference;
+      typedef typename _Rep_type::iterator iterator;
+      typedef typename _Rep_type::const_iterator const_iterator;
+      typedef typename _Rep_type::size_type size_type;
+      typedef typename _Rep_type::difference_type difference_type;
+      typedef typename _Rep_type::reverse_iterator reverse_iterator;
+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+      multimap() = default;
+      explicit
+      multimap(const _Compare& __comp,
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a)) { }
+      multimap(const multimap&) = default;
+      multimap(multimap&&) = default;
+      multimap(initializer_list<value_type> __l,
+        const _Compare& __comp = _Compare(),
+        const allocator_type& __a = allocator_type())
+      : _M_t(__comp, _Pair_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      explicit
+      multimap(const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a)) { }
+      multimap(const multimap& __m,
+        const __type_identity_t<allocator_type>& __a)
+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }
+      multimap(multimap&& __m, const __type_identity_t<allocator_type>& __a)
+      noexcept(is_nothrow_copy_constructible<_Compare>::value
+        && _Alloc_traits::_S_always_equal())
+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }
+      multimap(initializer_list<value_type> __l, const allocator_type& __a)
+      : _M_t(_Pair_alloc_type(__a))
+      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last,
+   const allocator_type& __a)
+ : _M_t(_Pair_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last)
+ : _M_t()
+ { _M_t._M_insert_range_equal(__first, __last); }
+      template<typename _InputIterator>
+ multimap(_InputIterator __first, _InputIterator __last,
+   const _Compare& __comp,
+   const allocator_type& __a = allocator_type())
+ : _M_t(__comp, _Pair_alloc_type(__a))
+ { _M_t._M_insert_range_equal(__first, __last); }
+      ~multimap() = default;
+      multimap&
+      operator=(const multimap&) = default;
+      multimap&
+      operator=(multimap&&) = default;
+      multimap&
+      operator=(initializer_list<value_type> __l)
+      {
+ _M_t._M_assign_equal(__l.begin(), __l.end());
+ return *this;
+      }
+      allocator_type
+      get_allocator() const noexcept
+      { return allocator_type(_M_t.get_allocator()); }
+      iterator
+      begin() noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      begin() const noexcept
+      { return _M_t.begin(); }
+      iterator
+      end() noexcept
+      { return _M_t.end(); }
+      const_iterator
+      end() const noexcept
+      { return _M_t.end(); }
+      reverse_iterator
+      rbegin() noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      rbegin() const noexcept
+      { return _M_t.rbegin(); }
+      reverse_iterator
+      rend() noexcept
+      { return _M_t.rend(); }
+      const_reverse_iterator
+      rend() const noexcept
+      { return _M_t.rend(); }
+      const_iterator
+      cbegin() const noexcept
+      { return _M_t.begin(); }
+      const_iterator
+      cend() const noexcept
+      { return _M_t.end(); }
+      const_reverse_iterator
+      crbegin() const noexcept
+      { return _M_t.rbegin(); }
+      const_reverse_iterator
+      crend() const noexcept
+      { return _M_t.rend(); }
+                         bool
+      empty() const noexcept
+      { return _M_t.empty(); }
+      size_type
+      size() const noexcept
+      { return _M_t.size(); }
+      size_type
+      max_size() const noexcept
+      { return _M_t.max_size(); }
+      template<typename... _Args>
+ iterator
+ emplace(_Args&&... __args)
+ { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
+      template<typename... _Args>
+ iterator
+ emplace_hint(const_iterator __pos, _Args&&... __args)
+ {
+   return _M_t._M_emplace_hint_equal(__pos,
+         std::forward<_Args>(__args)...);
+ }
+      iterator
+      insert(const value_type& __x)
+      { return _M_t._M_insert_equal(__x); }
+      iterator
+      insert(value_type&& __x)
+      { return _M_t._M_insert_equal(std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
+ insert(_Pair&& __x)
+ { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
+      iterator
+      insert(const_iterator __position, const value_type& __x)
+      { return _M_t._M_insert_equal_(__position, __x); }
+      iterator
+      insert(const_iterator __position, value_type&& __x)
+      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
+      template<typename _Pair>
+ __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
+ insert(const_iterator __position, _Pair&& __x)
+ {
+   return _M_t._M_emplace_hint_equal(__position,
+         std::forward<_Pair>(__x));
+ }
+      template<typename _InputIterator>
+ void
+ insert(_InputIterator __first, _InputIterator __last)
+ { _M_t._M_insert_range_equal(__first, __last); }
+      void
+      insert(initializer_list<value_type> __l)
+      { this->insert(__l.begin(), __l.end()); }
+      iterator
+      erase(const_iterator __position)
+      { return _M_t.erase(__position); }
+      __attribute ((__abi_tag__ ("cxx11")))
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
+      size_type
+      erase(const key_type& __x)
+      { return _M_t.erase(__x); }
+      iterator
+      erase(const_iterator __first, const_iterator __last)
+      { return _M_t.erase(__first, __last); }
+      void
+      swap(multimap& __x)
+      noexcept(__is_nothrow_swappable<_Compare>::value)
+      { _M_t.swap(__x._M_t); }
+      void
+      clear() noexcept
+      { _M_t.clear(); }
+      key_compare
+      key_comp() const
+      { return _M_t.key_comp(); }
+      value_compare
+      value_comp() const
+      { return value_compare(_M_t.key_comp()); }
+      iterator
+      find(const key_type& __x)
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      const_iterator
+      find(const key_type& __x) const
+      { return _M_t.find(__x); }
+      template<typename _Kt>
+ auto
+ find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
+ { return _M_t._M_find_tr(__x); }
+      size_type
+      count(const key_type& __x) const
+      { return _M_t.count(__x); }
+      template<typename _Kt>
+ auto
+ count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
+ { return _M_t._M_count_tr(__x); }
+      iterator
+      lower_bound(const key_type& __x)
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
+ { return iterator(_M_t._M_lower_bound_tr(__x)); }
+      const_iterator
+      lower_bound(const key_type& __x) const
+      { return _M_t.lower_bound(__x); }
+      template<typename _Kt>
+ auto
+ lower_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
+ { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
+      iterator
+      upper_bound(const key_type& __x)
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x)
+ -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
+ { return iterator(_M_t._M_upper_bound_tr(__x)); }
+      const_iterator
+      upper_bound(const key_type& __x) const
+      { return _M_t.upper_bound(__x); }
+      template<typename _Kt>
+ auto
+ upper_bound(const _Kt& __x) const
+ -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
+ { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
+      std::pair<iterator, iterator>
+      equal_range(const key_type& __x)
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x)
+ -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
+ { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
+      std::pair<const_iterator, const_iterator>
+      equal_range(const key_type& __x) const
+      { return _M_t.equal_range(__x); }
+      template<typename _Kt>
+ auto
+ equal_range(const _Kt& __x) const
+ -> decltype(pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x)))
+ {
+   return pair<const_iterator, const_iterator>(
+       _M_t._M_equal_range_tr(__x));
+ }
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator==(const multimap<_K1, _T1, _C1, _A1>&,
+     const multimap<_K1, _T1, _C1, _A1>&);
+      template<typename _K1, typename _T1, typename _C1, typename _A1>
+ friend bool
+ operator<(const multimap<_K1, _T1, _C1, _A1>&,
+    const multimap<_K1, _T1, _C1, _A1>&);
+  };
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t == __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __x._M_t < __y._M_t; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x == __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return __y < __x; }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__y < __x); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline bool
+    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    { return !(__x < __y); }
+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
+    inline void
+    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
+  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
+    noexcept(noexcept(__x.swap(__y)))
+    { __x.swap(__y); }
+}
+class CoinPackedVector;
+class CoinPackedVectorBase {
+public:
+  virtual int getNumElements() const = 0;
+  virtual const int *getIndices() const = 0;
+  virtual const double *getElements() const = 0;
+  void setTestForDuplicateIndex(bool test) const;
+  void setTestForDuplicateIndexWhenTrue(bool test) const;
+  bool testForDuplicateIndex() const { return testForDuplicateIndex_; }
+  inline void setTestsOff() const
+  {
+    testForDuplicateIndex_ = false;
+    testedDuplicateIndex_ = false;
+  }
+  double *denseVector(int denseSize) const;
+  double operator[](int i) const;
+  int getMaxIndex() const;
+  int getMinIndex() const;
+  void duplicateIndex(const char *methodName = __null,
+    const char *className = __null) const;
+  bool isExistingIndex(int i) const;
+  int findIndex(int i) const;
+  bool operator==(const CoinPackedVectorBase &rhs) const;
+  bool operator!=(const CoinPackedVectorBase &rhs) const;
+  int compare(const CoinPackedVectorBase &rhs) const;
+  template < class FloatEqual >
+  bool
+  isEquivalent(const CoinPackedVectorBase &rhs, const FloatEqual &eq) const
+  {
+    if (getNumElements() != rhs.getNumElements())
+      return false;
+    duplicateIndex("equivalent", "CoinPackedVector");
+    rhs.duplicateIndex("equivalent", "CoinPackedVector");
+    std::map< int, double > mv;
+    const int *inds = getIndices();
+    const double *elems = getElements();
+    int i;
+    for (i = getNumElements() - 1; i >= 0; --i) {
+      mv.insert(std::make_pair(inds[i], elems[i]));
+    }
+    std::map< int, double > mvRhs;
+    inds = rhs.getIndices();
+    elems = rhs.getElements();
+    for (i = getNumElements() - 1; i >= 0; --i) {
+      mvRhs.insert(std::make_pair(inds[i], elems[i]));
+    }
+    std::map< int, double >::const_iterator mvI = mv.begin();
+    std::map< int, double >::const_iterator mvIlast = mv.end();
+    std::map< int, double >::const_iterator mvIrhs = mvRhs.begin();
+    while (mvI != mvIlast) {
+      if (mvI->first != mvIrhs->first || !eq(mvI->second, mvIrhs->second))
+        return false;
+      ++mvI;
+      ++mvIrhs;
+    }
+    return true;
+  }
+  bool isEquivalent(const CoinPackedVectorBase &rhs) const;
+  double dotProduct(const double *dense) const;
+  double oneNorm() const;
+  double normSquare() const;
+  double twoNorm() const;
+  double infNorm() const;
+  double sum() const;
+protected:
+  CoinPackedVectorBase();
+public:
+  virtual ~CoinPackedVectorBase();
+private:
+  CoinPackedVectorBase(const CoinPackedVectorBase &);
+  CoinPackedVectorBase &operator=(const CoinPackedVectorBase &);
+protected:
+  void findMaxMinIndices() const;
+  std::set< int > *indexSet(const char *methodName = __null,
+    const char *className = __null) const;
+  void clearIndexSet() const;
+  void clearBase() const;
+  void copyMaxMinIndex(const CoinPackedVectorBase &x) const
+  {
+    maxIndex_ = x.maxIndex_;
+    minIndex_ = x.minIndex_;
+  }
+private:
+  mutable int maxIndex_;
+  mutable int minIndex_;
+  mutable std::set< int > *indexSetPtr_;
+  mutable bool testForDuplicateIndex_;
+  mutable bool testedDuplicateIndex_;
+};
+class CoinShallowPackedVector : public CoinPackedVectorBase {
+  friend void CoinShallowPackedVectorUnitTest();
+public:
+  virtual int getNumElements() const { return nElements_; }
+  virtual const int *getIndices() const { return indices_; }
+  virtual const double *getElements() const { return elements_; }
+  void clear();
+  CoinShallowPackedVector &operator=(const CoinShallowPackedVector &x);
+  CoinShallowPackedVector &operator=(const CoinPackedVectorBase &x);
+  void setVector(int size, const int *indices, const double *elements,
+    bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(int size,
+    const int *indices, const double *elements,
+    bool testForDuplicateIndex = true);
+  CoinShallowPackedVector(const CoinPackedVectorBase &);
+  CoinShallowPackedVector(const CoinShallowPackedVector &);
+  virtual ~CoinShallowPackedVector() {}
+  void print();
+private:
+  const int *indices_;
+  const double *elements_;
+  int nElements_;
+};
+void CoinShallowPackedVectorUnitTest();
+class CoinPackedMatrix {
+  friend void CoinPackedMatrixUnitTest();
+public:
+  inline double getExtraGap() const { return extraGap_; }
+  inline double getExtraMajor() const { return extraMajor_; }
+  void reserve(const int newMaxMajorDim, const CoinBigIndex newMaxSize,
+    bool create = false);
+  void clear();
+  inline bool isColOrdered() const { return colOrdered_; }
+  inline bool hasGaps() const { return (size_ < start_[majorDim_]); }
+  inline CoinBigIndex getNumElements() const { return size_; }
+  inline int getNumCols() const
+  {
+    return colOrdered_ ? majorDim_ : minorDim_;
+  }
+  inline int getNumRows() const
+  {
+    return colOrdered_ ? minorDim_ : majorDim_;
+  }
+  inline const double *getElements() const { return element_; }
+  inline const int *getIndices() const { return index_; }
+  inline int getSizeVectorStarts() const
+  {
+    return ((majorDim_ > 0) ? (majorDim_ + 1) : (0));
+  }
+  inline int getSizeVectorLengths() const { return majorDim_; }
+  inline const CoinBigIndex *getVectorStarts() const { return start_; }
+  inline const int *getVectorLengths() const { return length_; }
+  CoinBigIndex getVectorFirst(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorFirst", "CoinPackedMatrix");
+    return start_[i];
+  }
+  CoinBigIndex getVectorLast(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorLast", "CoinPackedMatrix");
+    return start_[i] + length_[i];
+  }
+  inline int getVectorSize(const int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vectorSize", "CoinPackedMatrix");
+    return length_[i];
+  }
+  const CoinShallowPackedVector getVector(int i) const
+  {
+    if (i < 0 || i >= majorDim_)
+      throw CoinError("bad index", "vector", "CoinPackedMatrix");
+    return CoinShallowPackedVector(length_[i],
+      index_ + start_[i],
+      element_ + start_[i],
+      false);
+  }
+  int *getMajorIndices() const;
+  void setDimensions(int numrows, int numcols);
+  void setExtraGap(const double newGap);
+  void setExtraMajor(const double newMajor);
+  void appendCol(const CoinPackedVectorBase &vec);
+  void appendCol(const int vecsize,
+    const int *vecind, const double *vecelem);
+  void appendCols(const int numcols,
+    const CoinPackedVectorBase *const *cols);
+  int appendCols(const int numcols,
+    const CoinBigIndex *columnStarts, const int *row,
+    const double *element, int numberRows = -1);
+  void appendRow(const CoinPackedVectorBase &vec);
+  void appendRow(const int vecsize,
+    const int *vecind, const double *vecelem);
+  void appendRows(const int numrows,
+    const CoinPackedVectorBase *const *rows);
+  int appendRows(const int numrows,
+    const CoinBigIndex *rowStarts, const int *column,
+    const double *element, int numberColumns = -1);
+  void rightAppendPackedMatrix(const CoinPackedMatrix &matrix);
+  void bottomAppendPackedMatrix(const CoinPackedMatrix &matrix);
+  void deleteCols(const int numDel, const int *indDel);
+  void deleteRows(const int numDel, const int *indDel);
+  void replaceVector(const int index,
+    const int numReplace, const double *newElements);
+  void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false);
+  double getCoefficient(int row, int column) const;
+  CoinBigIndex compress(double threshold);
+  CoinBigIndex eliminateDuplicates(double threshold);
+  void orderMatrix();
+  CoinBigIndex cleanMatrix(double threshold = 1.0e-20);
+  void removeGaps(double removeValue = -1.0);
+  void submatrixOf(const CoinPackedMatrix &matrix,
+    const int numMajor, const int *indMajor);
+  void submatrixOfWithDuplicates(const CoinPackedMatrix &matrix,
+    const int numMajor, const int *indMajor);
+  void copyOf(const CoinPackedMatrix &rhs);
+  void copyOf(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor = 0.0, const double extraGap = 0.0);
+  void copyReuseArrays(const CoinPackedMatrix &rhs);
+  void reverseOrderedCopyOf(const CoinPackedMatrix &rhs);
+  void assignMatrix(const bool colordered,
+    const int minor, const int major,
+    const CoinBigIndex numels,
+    double *&elem, int *&ind,
+    CoinBigIndex *&start, int *&len,
+    const int maxmajor = -1, const CoinBigIndex maxsize = -1);
+  CoinPackedMatrix &operator=(const CoinPackedMatrix &rhs);
+  void reverseOrdering();
+  void transpose();
+  void swap(CoinPackedMatrix &matrix);
+  void times(const double *x, double *y) const;
+  void times(const CoinPackedVectorBase &x, double *y) const;
+  void transposeTimes(const double *x, double *y) const;
+  void transposeTimes(const CoinPackedVectorBase &x, double *y) const;
+  int *countOrthoLength() const;
+  void countOrthoLength(int *counts) const;
+  inline int getMajorDim() const { return majorDim_; }
+  inline void setMajorDim(int value) { majorDim_ = value; }
+  inline int getMinorDim() const { return minorDim_; }
+  inline void setMinorDim(int value) { minorDim_ = value; }
+  inline int getMaxMajorDim() const { return maxMajorDim_; }
+  void dumpMatrix(const char *fname = __null) const;
+  void printMatrixElement(const int row_val, const int col_val) const;
+  void appendMajorVector(const CoinPackedVectorBase &vec);
+  void appendMajorVector(const int vecsize, const int *vecind,
+    const double *vecelem);
+  void appendMajorVectors(const int numvecs,
+    const CoinPackedVectorBase *const *vecs);
+  void appendMinorVector(const CoinPackedVectorBase &vec);
+  void appendMinorVector(const int vecsize, const int *vecind,
+    const double *vecelem);
+  void appendMinorVectors(const int numvecs,
+    const CoinPackedVectorBase *const *vecs);
+  void appendMinorFast(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element);
+  void majorAppendSameOrdered(const CoinPackedMatrix &matrix);
+  void minorAppendSameOrdered(const CoinPackedMatrix &matrix);
+  void majorAppendOrthoOrdered(const CoinPackedMatrix &matrix);
+  void minorAppendOrthoOrdered(const CoinPackedMatrix &matrix);
+  void deleteMajorVectors(const int numDel, const int *indDel);
+  void deleteMinorVectors(const int numDel, const int *indDel);
+  void timesMajor(const double *x, double *y) const;
+  void timesMajor(const CoinPackedVectorBase &x, double *y) const;
+  void timesMinor(const double *x, double *y) const;
+  void timesMinor(const CoinPackedVectorBase &x, double *y) const;
+  template < class FloatEqual >
+  bool
+  isEquivalent(const CoinPackedMatrix &rhs, const FloatEqual &eq) const
+  {
+    if ((isColOrdered() ^ rhs.isColOrdered()) || (getNumCols() != rhs.getNumCols()) || (getNumRows() != rhs.getNumRows()) || (getNumElements() != rhs.getNumElements()))
+      return false;
+    for (int i = getMajorDim() - 1; i >= 0; --i) {
+      CoinShallowPackedVector pv = getVector(i);
+      CoinShallowPackedVector rhsPv = rhs.getVector(i);
+      if (!pv.isEquivalent(rhsPv, eq))
+        return false;
+    }
+    return true;
+  }
+  bool isEquivalent2(const CoinPackedMatrix &rhs) const;
+  bool isEquivalent(const CoinPackedMatrix &rhs) const;
+  inline double *getMutableElements() const { return element_; }
+  inline int *getMutableIndices() const { return index_; }
+  inline CoinBigIndex *getMutableVectorStarts() const { return start_; }
+  inline int *getMutableVectorLengths() const { return length_; }
+  inline void setNumElements(CoinBigIndex value)
+  {
+    size_ = value;
+  }
+  inline void nullElementArray() { element_ = __null; }
+  inline void nullStartArray() { start_ = __null; }
+  inline void nullLengthArray() { length_ = __null; }
+  inline void nullIndexArray() { index_ = __null; }
+  CoinPackedMatrix();
+  CoinPackedMatrix(const bool colordered,
+    const double extraMajor, const double extraGap);
+  CoinPackedMatrix(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor, const double extraGap);
+  CoinPackedMatrix(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len);
+  CoinPackedMatrix(const bool colordered,
+    const int *rowIndices,
+    const int *colIndices,
+    const double *elements,
+    CoinBigIndex numels);
+  CoinPackedMatrix(const CoinPackedMatrix &m);
+  CoinPackedMatrix(const CoinPackedMatrix &m,
+    int extraForMajor, int extraElements,
+    bool reverseOrdering = false);
+  CoinPackedMatrix(const CoinPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  virtual ~CoinPackedMatrix();
+  int verifyMtx(int verbosity = 1, bool zeroesAreError = false) const;
+protected:
+  void gutsOfDestructor();
+  void gutsOfCopyOf(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len,
+    const double extraMajor = 0.0, const double extraGap = 0.0);
+  void gutsOfCopyOfNoGaps(const bool colordered,
+    const int minor, const int major,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start);
+  void gutsOfOpEqual(const bool colordered,
+    const int minor, const int major, const CoinBigIndex numels,
+    const double *elem, const int *ind,
+    const CoinBigIndex *start, const int *len);
+  void resizeForAddingMajorVectors(const int numVec, const int *lengthVec);
+  void resizeForAddingMinorVectors(const int *addedEntries);
+  int appendMajor(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  int appendMinor(const int number,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+private:
+  inline CoinBigIndex getLastStart() const
+  {
+    return majorDim_ == 0 ? 0 : start_[majorDim_];
+  }
+protected:
+  bool colOrdered_;
+  double extraGap_;
+  double extraMajor_;
+  double *element_;
+  int *index_;
+  CoinBigIndex *start_;
+  int *length_;
+  int majorDim_;
+  int minorDim_;
+  CoinBigIndex size_;
+  int maxMajorDim_;
+  CoinBigIndex maxSize_;
+};
+void CoinPackedMatrixUnitTest();
+class CoinIndexedVector;
+class ClpSimplex;
+class ClpModel;
+class ClpMatrixBase {
+public:
+  virtual CoinPackedMatrix *getPackedMatrix() const = 0;
+  virtual bool isColOrdered() const = 0;
+  virtual CoinBigIndex getNumElements() const = 0;
+  virtual int getNumCols() const = 0;
+  virtual int getNumRows() const = 0;
+  virtual const double *getElements() const = 0;
+  virtual const int *getIndices() const = 0;
+  virtual const CoinBigIndex *getVectorStarts() const = 0;
+  virtual const int *getVectorLengths() const = 0;
+  virtual int getVectorLength(int index) const;
+  virtual void deleteCols(const int numDel, const int *indDel) = 0;
+  virtual void deleteRows(const int numDel, const int *indDel) = 0;
+  virtual void appendCols(int number, const CoinPackedVectorBase *const *columns);
+  virtual void appendRows(int number, const CoinPackedVectorBase *const *rows);
+  virtual void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false);
+  virtual int appendMatrix(int number, int type,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  virtual ClpMatrixBase *reverseOrderedCopy() const
+  {
+    return __null;
+  }
+  virtual int countBasis(const int *whichColumn,
+    int &numberColumnBasic)
+    = 0;
+  virtual void fillBasis(ClpSimplex *model,
+    const int *whichColumn,
+    int &numberColumnBasic,
+    int *row, int *start,
+    int *rowCount, int *columnCount,
+    CoinFactorizationDouble *element)
+    = 0;
+  virtual int scale(ClpModel *, ClpSimplex * = __null) const
+  {
+    return 1;
+  }
+  virtual void scaleRowCopy(ClpModel *) const {}
+  virtual bool canGetRowCopy() const
+  {
+    return true;
+  }
+  inline virtual ClpMatrixBase *scaledColumnCopy(ClpModel *) const
+  {
+    return this->clone();
+  }
+  virtual bool allElementsInRange(ClpModel *,
+    double, double,
+    int = 15)
+  {
+    return true;
+  }
+  virtual void setDimensions(int numrows, int numcols);
+  virtual void rangeOfElements(double &smallestNegative, double &largestNegative,
+    double &smallestPositive, double &largestPositive);
+  virtual void unpack(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column) const = 0;
+  virtual void unpackPacked(ClpSimplex *model,
+    CoinIndexedVector *rowArray,
+    int column) const = 0;
+  virtual int refresh(ClpSimplex *)
+  {
+    return 0;
+  }
+  virtual void reallyScale(const double *rowScale, const double *columnScale);
+  virtual CoinBigIndex *dubiousWeights(const ClpSimplex *model, int *inputWeights) const;
+  virtual void add(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column, double multiplier) const = 0;
+  virtual void add(const ClpSimplex *model, double *array,
+    int column, double multiplier) const = 0;
+  virtual void releasePackedMatrix() const = 0;
+  virtual bool canDoPartialPricing() const;
+  virtual int hiddenRows() const;
+  virtual void partialPricing(ClpSimplex *model, double start, double end,
+    int &bestSequence, int &numberWanted);
+  virtual int extendUpdated(ClpSimplex *model, CoinIndexedVector *update, int mode);
+  virtual void primalExpanded(ClpSimplex *model, int mode);
+  virtual void dualExpanded(ClpSimplex *model, CoinIndexedVector *array,
+    double *other, int mode);
+  virtual int generalExpanded(ClpSimplex *model, int mode, int &number);
+  virtual int updatePivot(ClpSimplex *model, double oldInValue, double oldOutValue);
+  virtual void createVariable(ClpSimplex *model, int &bestSequence);
+  virtual int checkFeasible(ClpSimplex *model, double &sum) const;
+  double reducedCost(ClpSimplex *model, int sequence) const;
+  virtual void correctSequence(const ClpSimplex *model, int &sequenceIn, int &sequenceOut);
+  virtual void times(double scalar,
+    const double * x, double * y) const = 0;
+  virtual void times(double scalar,
+    const double * x, double * y,
+    const double * rowScale,
+    const double * columnScale) const;
+  virtual void transposeTimes(double scalar,
+    const double * x, double * y) const = 0;
+  virtual void transposeTimes(double scalar,
+    const double * x, double * y,
+    const double * rowScale,
+    const double * columnScale,
+    double * spare = __null) const;
+  virtual void transposeTimes(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const = 0;
+  virtual void subsetTransposeTimes(const ClpSimplex *model,
+    const CoinIndexedVector *x,
+    const CoinIndexedVector *y,
+    CoinIndexedVector *z) const = 0;
+  virtual bool canCombine(const ClpSimplex *,
+    const CoinIndexedVector *) const
+  {
+    return false;
+  }
+  virtual int transposeTimes2(const ClpSimplex *model,
+    const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2,
+    CoinIndexedVector *spare,
+    double *infeas, double *reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void subsetTimes2(const ClpSimplex *model,
+    CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void listTransposeTimes(const ClpSimplex *model,
+    double *x,
+    int *y,
+    int number,
+    double *z) const;
+  virtual ClpMatrixBase *clone() const = 0;
+  virtual ClpMatrixBase *subsetClone(
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns) const;
+  virtual void backToBasics() {}
+  inline int type() const
+  {
+    return type_;
+  }
+  void setType(int newtype)
+  {
+    type_ = newtype;
+  }
+  void useEffectiveRhs(ClpSimplex *model);
+  virtual double *rhsOffset(ClpSimplex *model, bool forceRefresh = false,
+    bool check = false);
+  inline int lastRefresh() const
+  {
+    return lastRefresh_;
+  }
+  inline int refreshFrequency() const
+  {
+    return refreshFrequency_;
+  }
+  inline void setRefreshFrequency(int value)
+  {
+    refreshFrequency_ = value;
+  }
+  inline bool skipDualCheck() const
+  {
+    return skipDualCheck_;
+  }
+  inline void setSkipDualCheck(bool yes)
+  {
+    skipDualCheck_ = yes;
+  }
+  inline int minimumObjectsScan() const
+  {
+    return minimumObjectsScan_;
+  }
+  inline void setMinimumObjectsScan(int value)
+  {
+    minimumObjectsScan_ = value;
+  }
+  inline int minimumGoodReducedCosts() const
+  {
+    return minimumGoodReducedCosts_;
+  }
+  inline void setMinimumGoodReducedCosts(int value)
+  {
+    minimumGoodReducedCosts_ = value;
+  }
+  inline double startFraction() const
+  {
+    return startFraction_;
+  }
+  inline void setStartFraction(double value)
+  {
+    startFraction_ = value;
+  }
+  inline double endFraction() const
+  {
+    return endFraction_;
+  }
+  inline void setEndFraction(double value)
+  {
+    endFraction_ = value;
+  }
+  inline double savedBestDj() const
+  {
+    return savedBestDj_;
+  }
+  inline void setSavedBestDj(double value)
+  {
+    savedBestDj_ = value;
+  }
+  inline int originalWanted() const
+  {
+    return originalWanted_;
+  }
+  inline void setOriginalWanted(int value)
+  {
+    originalWanted_ = value;
+  }
+  inline int currentWanted() const
+  {
+    return currentWanted_;
+  }
+  inline void setCurrentWanted(int value)
+  {
+    currentWanted_ = value;
+  }
+  inline int savedBestSequence() const
+  {
+    return savedBestSequence_;
+  }
+  inline void setSavedBestSequence(int value)
+  {
+    savedBestSequence_ = value;
+  }
+protected:
+  ClpMatrixBase();
+public:
+  virtual ~ClpMatrixBase();
+protected:
+  ClpMatrixBase(const ClpMatrixBase &);
+  ClpMatrixBase &operator=(const ClpMatrixBase &);
+protected:
+  double *rhsOffset_;
+  double startFraction_;
+  double endFraction_;
+  double savedBestDj_;
+  int originalWanted_;
+  int currentWanted_;
+  int savedBestSequence_;
+  int type_;
+  int lastRefresh_;
+  int refreshFrequency_;
+  int minimumObjectsScan_;
+  int minimumGoodReducedCosts_;
+  int trueSequenceIn_;
+  int trueSequenceOut_;
+  bool skipDualCheck_;
+};
+class ClpSimplex;
+class CoinIndexedVector;
+class ClpPrimalColumnPivot {
+public:
+  virtual int pivotColumn(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2)
+    = 0;
+  virtual void updateWeights(CoinIndexedVector *input);
+  virtual void saveWeights(ClpSimplex *model, int mode) = 0;
+  virtual int pivotRow(double &way)
+  {
+    way = 0;
+    return -2;
+  }
+  virtual void clearArrays();
+  virtual bool looksOptimal() const
+  {
+    return looksOptimal_;
+  }
+  virtual void setLooksOptimal(bool flag)
+  {
+    looksOptimal_ = flag;
+  }
+  ClpPrimalColumnPivot();
+  ClpPrimalColumnPivot(const ClpPrimalColumnPivot &);
+  ClpPrimalColumnPivot &operator=(const ClpPrimalColumnPivot &rhs);
+  virtual ~ClpPrimalColumnPivot();
+  virtual ClpPrimalColumnPivot *clone(bool copyData = true) const = 0;
+  inline ClpSimplex *model()
+  {
+    return model_;
+  }
+  inline void setModel(ClpSimplex *newmodel)
+  {
+    model_ = newmodel;
+  }
+  inline int type()
+  {
+    return type_;
+  }
+  virtual int numberSprintColumns(int &numberIterations) const;
+  virtual void switchOffSprint();
+  virtual void maximumPivotsChanged() {}
+protected:
+  ClpSimplex *model_;
+  int type_;
+  bool looksOptimal_;
+};
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<size_t _Nw>
+    struct _Base_bitset
+    {
+      typedef unsigned long _WordT;
+      _WordT _M_w[_Nw];
+      constexpr _Base_bitset() noexcept
+      : _M_w() { }
+      constexpr _Base_bitset(unsigned long long __val) noexcept
+      : _M_w{ _WordT(__val)
+       } { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t __pos) noexcept
+      { return _M_w[_S_whichword(__pos)]; }
+      constexpr _WordT
+      _M_getword(size_t __pos) const noexcept
+      { return _M_w[_S_whichword(__pos)]; }
+      const _WordT*
+      _M_getdata() const noexcept
+      { return _M_w; }
+      _WordT&
+      _M_hiword() noexcept
+      { return _M_w[_Nw - 1]; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return _M_w[_Nw - 1]; }
+      void
+      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] &= __x._M_w[__i];
+      }
+      void
+      _M_do_or(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] |= __x._M_w[__i];
+      }
+      void
+      _M_do_xor(const _Base_bitset<_Nw>& __x) noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] ^= __x._M_w[__i];
+      }
+      void
+      _M_do_left_shift(size_t __shift) noexcept;
+      void
+      _M_do_right_shift(size_t __shift) noexcept;
+      void
+      _M_do_flip() noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] = ~_M_w[__i];
+      }
+      void
+      _M_do_set() noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   _M_w[__i] = ~static_cast<_WordT>(0);
+      }
+      void
+      _M_do_reset() noexcept
+      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }
+      bool
+      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; ++__i)
+   if (_M_w[__i] != __x._M_w[__i])
+     return false;
+ return true;
+      }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        {
+   for (size_t __i = 0; __i < _Nw - 1; __i++)
+     if (_M_w[__i] != ~static_cast<_WordT>(0))
+       return false;
+   return _M_hiword() == (~static_cast<_WordT>(0)
+     >> (_Nw * (8 * 8)
+         - _Nb));
+ }
+      bool
+      _M_is_any() const noexcept
+      {
+ for (size_t __i = 0; __i < _Nw; __i++)
+   if (_M_w[__i] != static_cast<_WordT>(0))
+     return true;
+ return false;
+      }
+      size_t
+      _M_do_count() const noexcept
+      {
+ size_t __result = 0;
+ for (size_t __i = 0; __i < _Nw; __i++)
+   __result += __builtin_popcountl(_M_w[__i]);
+ return __result;
+      }
+      unsigned long
+      _M_do_to_ulong() const;
+      unsigned long long
+      _M_do_to_ullong() const;
+      size_t
+      _M_do_find_first(size_t) const noexcept;
+      size_t
+      _M_do_find_next(size_t, size_t) const noexcept;
+    };
+  template<size_t _Nw>
+    void
+    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept
+    {
+      if (__builtin_expect(__shift != 0, 1))
+ {
+   const size_t __wshift = __shift / (8 * 8);
+   const size_t __offset = __shift % (8 * 8);
+   if (__offset == 0)
+     for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
+       _M_w[__n] = _M_w[__n - __wshift];
+   else
+     {
+       const size_t __sub_offset = ((8 * 8)
+        - __offset);
+       for (size_t __n = _Nw - 1; __n > __wshift; --__n)
+  _M_w[__n] = ((_M_w[__n - __wshift] << __offset)
+        | (_M_w[__n - __wshift - 1] >> __sub_offset));
+       _M_w[__wshift] = _M_w[0] << __offset;
+     }
+   std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
+ }
+    }
+  template<size_t _Nw>
+    void
+    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept
+    {
+      if (__builtin_expect(__shift != 0, 1))
+ {
+   const size_t __wshift = __shift / (8 * 8);
+   const size_t __offset = __shift % (8 * 8);
+   const size_t __limit = _Nw - __wshift - 1;
+   if (__offset == 0)
+     for (size_t __n = 0; __n <= __limit; ++__n)
+       _M_w[__n] = _M_w[__n + __wshift];
+   else
+     {
+       const size_t __sub_offset = ((8 * 8)
+        - __offset);
+       for (size_t __n = 0; __n < __limit; ++__n)
+  _M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
+        | (_M_w[__n + __wshift + 1] << __sub_offset));
+       _M_w[__limit] = _M_w[_Nw-1] >> __offset;
+     }
+   std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
+ }
+    }
+  template<size_t _Nw>
+    unsigned long
+    _Base_bitset<_Nw>::_M_do_to_ulong() const
+    {
+      for (size_t __i = 1; __i < _Nw; ++__i)
+ if (_M_w[__i])
+   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
+      return _M_w[0];
+    }
+  template<size_t _Nw>
+    unsigned long long
+    _Base_bitset<_Nw>::_M_do_to_ullong() const
+    {
+      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
+      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
+ if (_M_w[__i])
+   __throw_overflow_error(("_Base_bitset::_M_do_to_ullong"));
+      if (__dw)
+ return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
+     << (8 * 8));
+      return _M_w[0];
+    }
+  template<size_t _Nw>
+    size_t
+    _Base_bitset<_Nw>::
+    _M_do_find_first(size_t __not_found) const noexcept
+    {
+      for (size_t __i = 0; __i < _Nw; __i++)
+ {
+   _WordT __thisword = _M_w[__i];
+   if (__thisword != static_cast<_WordT>(0))
+     return (__i * (8 * 8)
+      + __builtin_ctzl(__thisword));
+ }
+      return __not_found;
+    }
+  template<size_t _Nw>
+    size_t
+    _Base_bitset<_Nw>::
+    _M_do_find_next(size_t __prev, size_t __not_found) const noexcept
+    {
+      ++__prev;
+      if (__prev >= _Nw * (8 * 8))
+ return __not_found;
+      size_t __i = _S_whichword(__prev);
+      _WordT __thisword = _M_w[__i];
+      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
+      if (__thisword != static_cast<_WordT>(0))
+ return (__i * (8 * 8)
+  + __builtin_ctzl(__thisword));
+      __i++;
+      for (; __i < _Nw; __i++)
+ {
+   __thisword = _M_w[__i];
+   if (__thisword != static_cast<_WordT>(0))
+     return (__i * (8 * 8)
+      + __builtin_ctzl(__thisword));
+ }
+      return __not_found;
+    }
+  template<>
+    struct _Base_bitset<1>
+    {
+      typedef unsigned long _WordT;
+      _WordT _M_w;
+      constexpr _Base_bitset() noexcept
+      : _M_w(0)
+      { }
+      constexpr _Base_bitset(unsigned long long __val) noexcept
+      : _M_w(__val)
+      { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t) noexcept
+      { return _M_w; }
+      constexpr _WordT
+      _M_getword(size_t) const noexcept
+      { return _M_w; }
+      const _WordT*
+      _M_getdata() const noexcept
+      { return &_M_w; }
+      _WordT&
+      _M_hiword() noexcept
+      { return _M_w; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return _M_w; }
+      void
+      _M_do_and(const _Base_bitset<1>& __x) noexcept
+      { _M_w &= __x._M_w; }
+      void
+      _M_do_or(const _Base_bitset<1>& __x) noexcept
+      { _M_w |= __x._M_w; }
+      void
+      _M_do_xor(const _Base_bitset<1>& __x) noexcept
+      { _M_w ^= __x._M_w; }
+      void
+      _M_do_left_shift(size_t __shift) noexcept
+      { _M_w <<= __shift; }
+      void
+      _M_do_right_shift(size_t __shift) noexcept
+      { _M_w >>= __shift; }
+      void
+      _M_do_flip() noexcept
+      { _M_w = ~_M_w; }
+      void
+      _M_do_set() noexcept
+      { _M_w = ~static_cast<_WordT>(0); }
+      void
+      _M_do_reset() noexcept
+      { _M_w = 0; }
+      bool
+      _M_is_equal(const _Base_bitset<1>& __x) const noexcept
+      { return _M_w == __x._M_w; }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        { return _M_w == (~static_cast<_WordT>(0)
+     >> ((8 * 8) - _Nb)); }
+      bool
+      _M_is_any() const noexcept
+      { return _M_w != 0; }
+      size_t
+      _M_do_count() const noexcept
+      { return __builtin_popcountl(_M_w); }
+      unsigned long
+      _M_do_to_ulong() const noexcept
+      { return _M_w; }
+      unsigned long long
+      _M_do_to_ullong() const noexcept
+      { return _M_w; }
+      size_t
+      _M_do_find_first(size_t __not_found) const noexcept
+      {
+        if (_M_w != 0)
+          return __builtin_ctzl(_M_w);
+        else
+          return __not_found;
+      }
+      size_t
+      _M_do_find_next(size_t __prev, size_t __not_found) const
+ noexcept
+      {
+ ++__prev;
+ if (__prev >= ((size_t) (8 * 8)))
+   return __not_found;
+ _WordT __x = _M_w >> __prev;
+ if (__x != 0)
+   return __builtin_ctzl(__x) + __prev;
+ else
+   return __not_found;
+      }
+    };
+  template<>
+    struct _Base_bitset<0>
+    {
+      typedef unsigned long _WordT;
+      constexpr _Base_bitset() noexcept
+      { }
+      constexpr _Base_bitset(unsigned long long) noexcept
+      { }
+      static constexpr size_t
+      _S_whichword(size_t __pos) noexcept
+      { return __pos / (8 * 8); }
+      static constexpr size_t
+      _S_whichbyte(size_t __pos) noexcept
+      { return (__pos % (8 * 8)) / 8; }
+      static constexpr size_t
+      _S_whichbit(size_t __pos) noexcept
+      { return __pos % (8 * 8); }
+      static constexpr _WordT
+      _S_maskbit(size_t __pos) noexcept
+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
+      _WordT&
+      _M_getword(size_t) noexcept
+      {
+ __throw_out_of_range(("_Base_bitset::_M_getword"));
+ return *new _WordT;
+      }
+      constexpr _WordT
+      _M_getword(size_t) const noexcept
+      { return 0; }
+      constexpr _WordT
+      _M_hiword() const noexcept
+      { return 0; }
+      void
+      _M_do_and(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_or(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_xor(const _Base_bitset<0>&) noexcept
+      { }
+      void
+      _M_do_left_shift(size_t) noexcept
+      { }
+      void
+      _M_do_right_shift(size_t) noexcept
+      { }
+      void
+      _M_do_flip() noexcept
+      { }
+      void
+      _M_do_set() noexcept
+      { }
+      void
+      _M_do_reset() noexcept
+      { }
+      bool
+      _M_is_equal(const _Base_bitset<0>&) const noexcept
+      { return true; }
+      template<size_t _Nb>
+        bool
+        _M_are_all() const noexcept
+        { return true; }
+      bool
+      _M_is_any() const noexcept
+      { return false; }
+      size_t
+      _M_do_count() const noexcept
+      { return 0; }
+      unsigned long
+      _M_do_to_ulong() const noexcept
+      { return 0; }
+      unsigned long long
+      _M_do_to_ullong() const noexcept
+      { return 0; }
+      size_t
+      _M_do_find_first(size_t) const noexcept
+      { return 0; }
+      size_t
+      _M_do_find_next(size_t, size_t) const noexcept
+      { return 0; }
+    };
+  template<size_t _Extrabits>
+    struct _Sanitize
+    {
+      typedef unsigned long _WordT;
+      static void
+      _S_do_sanitize(_WordT& __val) noexcept
+      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
+    };
+  template<>
+    struct _Sanitize<0>
+    {
+      typedef unsigned long _WordT;
+      static void
+      _S_do_sanitize(_WordT) noexcept { }
+    };
+  template<size_t _Nb, bool = (_Nb < (8 * 8))>
+    struct _Sanitize_val
+    {
+      static constexpr unsigned long long
+      _S_do_sanitize_val(unsigned long long __val)
+      { return __val; }
+    };
+  template<size_t _Nb>
+    struct _Sanitize_val<_Nb, true>
+    {
+      static constexpr unsigned long long
+      _S_do_sanitize_val(unsigned long long __val)
+      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
+    };
+  template<size_t _Nb>
+    class bitset
+    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
+    {
+    private:
+      typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))> _Base;
+      typedef unsigned long _WordT;
+      template<class _CharT, class _Traits, class _Alloc>
+      void
+      _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+    size_t __position) const
+      {
+ if (__position > __s.size())
+   __throw_out_of_range_fmt(("bitset::bitset: __position " "(which is %zu) > __s.size() " "(which is %zu)"),
+       __position, __s.size());
+      }
+      void _M_check(size_t __position, const char *__s) const
+      {
+ if (__position >= _Nb)
+   __throw_out_of_range_fmt(("%s: __position (which is %zu) " ">= _Nb (which is %zu)"),
+       __s, __position, _Nb);
+      }
+      void
+      _M_do_sanitize() noexcept
+      {
+ typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
+ __sanitize_type::_S_do_sanitize(this->_M_hiword());
+      }
+      friend struct std::hash<bitset>;
+    public:
+      class reference
+      {
+ friend class bitset;
+ _WordT* _M_wp;
+ size_t _M_bpos;
+ reference();
+      public:
+ reference(bitset& __b, size_t __pos) noexcept
+ {
+   _M_wp = &__b._M_getword(__pos);
+   _M_bpos = _Base::_S_whichbit(__pos);
+ }
+ reference(const reference&) = default;
+ ~reference() noexcept
+ { }
+ reference&
+ operator=(bool __x) noexcept
+ {
+   if (__x)
+     *_M_wp |= _Base::_S_maskbit(_M_bpos);
+   else
+     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+ reference&
+ operator=(const reference& __j) noexcept
+ {
+   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
+     *_M_wp |= _Base::_S_maskbit(_M_bpos);
+   else
+     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+ bool
+ operator~() const noexcept
+ { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }
+ operator bool() const noexcept
+ { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
+ reference&
+ flip() noexcept
+ {
+   *_M_wp ^= _Base::_S_maskbit(_M_bpos);
+   return *this;
+ }
+      };
+      friend class reference;
+      constexpr bitset() noexcept
+      { }
+      constexpr bitset(unsigned long long __val) noexcept
+      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
+      template<class _CharT, class _Traits, class _Alloc>
+ explicit
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position = 0)
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position,
+         std::basic_string<_CharT, _Traits, _Alloc>::npos,
+         _CharT('0'), _CharT('1'));
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position, size_t __n)
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
+        size_t __position, size_t __n,
+        _CharT __zero, _CharT __one = _CharT('1'))
+ : _Base()
+ {
+   _M_check_initial_position(__s, __position);
+   _M_copy_from_string(__s, __position, __n, __zero, __one);
+ }
+      template<typename _CharT>
+        explicit
+        bitset(const _CharT* __str,
+        typename std::basic_string<_CharT>::size_type __n
+        = std::basic_string<_CharT>::npos,
+        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
+        : _Base()
+        {
+   if (!__str)
+     __throw_logic_error(("bitset::bitset(const _CharT*, ...)"));
+   if (__n == std::basic_string<_CharT>::npos)
+     __n = std::char_traits<_CharT>::length(__str);
+   _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
+            __n, __zero,
+            __one);
+ }
+      bitset<_Nb>&
+      operator&=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_and(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator|=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_or(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator^=(const bitset<_Nb>& __rhs) noexcept
+      {
+ this->_M_do_xor(__rhs);
+ return *this;
+      }
+      bitset<_Nb>&
+      operator<<=(size_t __position) noexcept
+      {
+ if (__builtin_expect(__position < _Nb, 1))
+   {
+     this->_M_do_left_shift(__position);
+     this->_M_do_sanitize();
+   }
+ else
+   this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      operator>>=(size_t __position) noexcept
+      {
+ if (__builtin_expect(__position < _Nb, 1))
+   {
+     this->_M_do_right_shift(__position);
+     this->_M_do_sanitize();
+   }
+ else
+   this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_set(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_set(size_t __pos, int __val) noexcept
+      {
+ if (__val)
+   this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
+ else
+   this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_reset(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
+ return *this;
+      }
+      bitset<_Nb>&
+      _Unchecked_flip(size_t __pos) noexcept
+      {
+ this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
+ return *this;
+      }
+      constexpr bool
+      _Unchecked_test(size_t __pos) const noexcept
+      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
+  != static_cast<_WordT>(0)); }
+      bitset<_Nb>&
+      set() noexcept
+      {
+ this->_M_do_set();
+ this->_M_do_sanitize();
+ return *this;
+      }
+      bitset<_Nb>&
+      set(size_t __position, bool __val = true)
+      {
+ this->_M_check(__position, ("bitset::set"));
+ return _Unchecked_set(__position, __val);
+      }
+      bitset<_Nb>&
+      reset() noexcept
+      {
+ this->_M_do_reset();
+ return *this;
+      }
+      bitset<_Nb>&
+      reset(size_t __position)
+      {
+ this->_M_check(__position, ("bitset::reset"));
+ return _Unchecked_reset(__position);
+      }
+      bitset<_Nb>&
+      flip() noexcept
+      {
+ this->_M_do_flip();
+ this->_M_do_sanitize();
+ return *this;
+      }
+      bitset<_Nb>&
+      flip(size_t __position)
+      {
+ this->_M_check(__position, ("bitset::flip"));
+ return _Unchecked_flip(__position);
+      }
+      bitset<_Nb>
+      operator~() const noexcept
+      { return bitset<_Nb>(*this).flip(); }
+      reference
+      operator[](size_t __position)
+      { return reference(*this, __position); }
+      constexpr bool
+      operator[](size_t __position) const
+      { return _Unchecked_test(__position); }
+      unsigned long
+      to_ulong() const
+      { return this->_M_do_to_ulong(); }
+      unsigned long long
+      to_ullong() const
+      { return this->_M_do_to_ullong(); }
+      template<class _CharT, class _Traits, class _Alloc>
+ std::basic_string<_CharT, _Traits, _Alloc>
+ to_string() const
+ {
+   std::basic_string<_CharT, _Traits, _Alloc> __result;
+   _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
+   return __result;
+ }
+      template<class _CharT, class _Traits, class _Alloc>
+ std::basic_string<_CharT, _Traits, _Alloc>
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ {
+   std::basic_string<_CharT, _Traits, _Alloc> __result;
+   _M_copy_to_string(__result, __zero, __one);
+   return __result;
+ }
+      template<class _CharT, class _Traits>
+ std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
+ to_string() const
+ { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }
+      template<class _CharT, class _Traits>
+ std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ { return to_string<_CharT, _Traits,
+                    std::allocator<_CharT> >(__zero, __one); }
+      template<class _CharT>
+ std::basic_string<_CharT, std::char_traits<_CharT>,
+                   std::allocator<_CharT> >
+ to_string() const
+ {
+   return to_string<_CharT, std::char_traits<_CharT>,
+                    std::allocator<_CharT> >();
+ }
+      template<class _CharT>
+ std::basic_string<_CharT, std::char_traits<_CharT>,
+                   std::allocator<_CharT> >
+ to_string(_CharT __zero, _CharT __one = _CharT('1')) const
+ {
+   return to_string<_CharT, std::char_traits<_CharT>,
+                    std::allocator<_CharT> >(__zero, __one);
+ }
+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
+      to_string() const
+      {
+ return to_string<char, std::char_traits<char>,
+                  std::allocator<char> >();
+      }
+      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
+      to_string(char __zero, char __one = '1') const
+      {
+ return to_string<char, std::char_traits<char>,
+                  std::allocator<char> >(__zero, __one);
+      }
+      template<class _CharT, class _Traits>
+        void
+        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
+    _CharT, _CharT);
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+ _M_copy_from_string(const std::basic_string<_CharT,
+       _Traits, _Alloc>& __s, size_t __pos, size_t __n,
+       _CharT __zero, _CharT __one)
+ { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
+         __zero, __one); }
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
+     _CharT, _CharT) const;
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+ _M_copy_from_string(const std::basic_string<_CharT,
+       _Traits, _Alloc>& __s, size_t __pos, size_t __n)
+ { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }
+      template<class _CharT, class _Traits, class _Alloc>
+ void
+        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
+ { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }
+      size_t
+      count() const noexcept
+      { return this->_M_do_count(); }
+      constexpr size_t
+      size() const noexcept
+      { return _Nb; }
+      bool
+      operator==(const bitset<_Nb>& __rhs) const noexcept
+      { return this->_M_is_equal(__rhs); }
+      bool
+      operator!=(const bitset<_Nb>& __rhs) const noexcept
+      { return !this->_M_is_equal(__rhs); }
+      bool
+      test(size_t __position) const
+      {
+ this->_M_check(__position, ("bitset::test"));
+ return _Unchecked_test(__position);
+      }
+      bool
+      all() const noexcept
+      { return this->template _M_are_all<_Nb>(); }
+      bool
+      any() const noexcept
+      { return this->_M_is_any(); }
+      bool
+      none() const noexcept
+      { return !this->_M_is_any(); }
+      bitset<_Nb>
+      operator<<(size_t __position) const noexcept
+      { return bitset<_Nb>(*this) <<= __position; }
+      bitset<_Nb>
+      operator>>(size_t __position) const noexcept
+      { return bitset<_Nb>(*this) >>= __position; }
+      size_t
+      _Find_first() const noexcept
+      { return this->_M_do_find_first(_Nb); }
+      size_t
+      _Find_next(size_t __prev) const noexcept
+      { return this->_M_do_find_next(__prev, _Nb); }
+    };
+  template<size_t _Nb>
+    template<class _CharT, class _Traits>
+      void
+      bitset<_Nb>::
+      _M_copy_from_ptr(const _CharT* __s, size_t __len,
+         size_t __pos, size_t __n, _CharT __zero, _CharT __one)
+      {
+ reset();
+ const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
+ for (size_t __i = __nbits; __i > 0; --__i)
+   {
+     const _CharT __c = __s[__pos + __nbits - __i];
+     if (_Traits::eq(__c, __zero))
+       ;
+     else if (_Traits::eq(__c, __one))
+       _Unchecked_set(__i - 1);
+     else
+       __throw_invalid_argument(("bitset::_M_copy_from_ptr"));
+   }
+      }
+  template<size_t _Nb>
+    template<class _CharT, class _Traits, class _Alloc>
+      void
+      bitset<_Nb>::
+      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
+   _CharT __zero, _CharT __one) const
+      {
+ __s.assign(_Nb, __zero);
+ size_t __n = this->_Find_first();
+ while (__n < _Nb)
+   {
+     __s[_Nb - __n - 1] = __one;
+     __n = _Find_next(__n);
+   }
+      }
+  template<size_t _Nb>
+    inline bitset<_Nb>
+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result &= __y;
+      return __result;
+    }
+  template<size_t _Nb>
+    inline bitset<_Nb>
+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result |= __y;
+      return __result;
+    }
+  template <size_t _Nb>
+    inline bitset<_Nb>
+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
+    {
+      bitset<_Nb> __result(__x);
+      __result ^= __y;
+      return __result;
+    }
+  template<class _CharT, class _Traits, size_t _Nb>
+    std::basic_istream<_CharT, _Traits>&
+    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
+    {
+      typedef typename _Traits::char_type char_type;
+      typedef std::basic_istream<_CharT, _Traits> __istream_type;
+      typedef typename __istream_type::ios_base __ios_base;
+      std::basic_string<_CharT, _Traits> __tmp;
+      __tmp.reserve(_Nb);
+      const char_type __zero = __is.widen('0');
+      const char_type __one = __is.widen('1');
+      typename __ios_base::iostate __state = __ios_base::goodbit;
+      typename __istream_type::sentry __sentry(__is);
+      if (__sentry)
+ {
+   try
+     {
+       for (size_t __i = _Nb; __i > 0; --__i)
+  {
+    static typename _Traits::int_type __eof = _Traits::eof();
+    typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
+    if (_Traits::eq_int_type(__c1, __eof))
+      {
+        __state |= __ios_base::eofbit;
+        break;
+      }
+    else
+      {
+        const char_type __c2 = _Traits::to_char_type(__c1);
+        if (_Traits::eq(__c2, __zero))
+   __tmp.push_back(__zero);
+        else if (_Traits::eq(__c2, __one))
+   __tmp.push_back(__one);
+        else if (_Traits::
+          eq_int_type(__is.rdbuf()->sputbackc(__c2),
+        __eof))
+   {
+     __state |= __ios_base::failbit;
+     break;
+   }
+      }
+  }
+     }
+   catch(__cxxabiv1::__forced_unwind&)
+     {
+       __is._M_setstate(__ios_base::badbit);
+       throw;
+     }
+   catch(...)
+     { __is._M_setstate(__ios_base::badbit); }
+ }
+      if (__tmp.empty() && _Nb)
+ __state |= __ios_base::failbit;
+      else
+ __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
+    __zero, __one);
+      if (__state)
+ __is.setstate(__state);
+      return __is;
+    }
+  template <class _CharT, class _Traits, size_t _Nb>
+    std::basic_ostream<_CharT, _Traits>&
+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
+        const bitset<_Nb>& __x)
+    {
+      std::basic_string<_CharT, _Traits> __tmp;
+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
+      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
+      return __os << __tmp;
+    }
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template<size_t _Nb>
+    struct hash<std::bitset<_Nb>>
+    : public __hash_base<size_t, std::bitset<_Nb>>
+    {
+      size_t
+      operator()(const std::bitset<_Nb>& __b) const noexcept
+      {
+ const size_t __clength = (_Nb + 8 - 1) / 8;
+ return std::_Hash_impl::hash(__b._M_getdata(), __clength);
+      }
+    };
+  template<>
+    struct hash<std::bitset<0>>
+    : public __hash_base<size_t, std::bitset<0>>
+    {
+      size_t
+      operator()(const std::bitset<0>&) const noexcept
+      { return 0; }
+    };
+}
+class CoinIndexedVector;
+class ClpPrimalColumnSteepest : public ClpPrimalColumnPivot {
+public:
+  virtual int pivotColumn(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int pivotColumnOldMethod(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow1,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justDjs(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int partialPricing(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    int numberWanted,
+    int numberLook);
+  void djsAndDevex(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndSteepest(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndDevex2(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void djsAndSteepest2(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justDevex(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  void justSteepest(CoinIndexedVector *updates,
+    CoinIndexedVector *spareRow2,
+    CoinIndexedVector *spareColumn1,
+    CoinIndexedVector *spareColumn2);
+  int transposeTimes2(const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    CoinIndexedVector *spare, double scaleFactor);
+  virtual void updateWeights(CoinIndexedVector *input);
+  void checkAccuracy(int sequence, double relativeTolerance,
+    CoinIndexedVector *rowArray1,
+    CoinIndexedVector *rowArray2);
+  void initializeWeights();
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  void redoInfeasibilities();
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const;
+  virtual void maximumPivotsChanged();
+  inline int mode() const
+  {
+    return mode_;
+  }
+  inline void setMode(int mode)
+  {
+    mode_ = mode;
+  }
+  inline CoinIndexedVector *infeasible() const
+  {
+    return infeasible_;
+  }
+  inline const double *weights() const
+  {
+    return weights_;
+  }
+  inline CoinIndexedVector *alternateWeights() const
+  {
+    return alternateWeights_;
+  }
+  virtual int numberSprintColumns(int &numberIterations) const;
+  virtual void switchOffSprint();
+  enum Persistence {
+    normal = 0x00,
+    keep = 0x01
+  };
+  ClpPrimalColumnSteepest(int mode = 3);
+  ClpPrimalColumnSteepest(const ClpPrimalColumnSteepest &rhs);
+  ClpPrimalColumnSteepest &operator=(const ClpPrimalColumnSteepest &rhs);
+  virtual ~ClpPrimalColumnSteepest();
+  virtual ClpPrimalColumnPivot *clone(bool copyData = true) const;
+  inline bool reference(int i) const
+  {
+    return ((reference_[i >> 5] >> (i & 31)) & 1) != 0;
+  }
+  inline void setReference(int i, bool trueFalse)
+  {
+    unsigned int &value = reference_[i >> 5];
+    int bit = i & 31;
+    if (trueFalse)
+      value |= (1 << bit);
+    else
+      value &= ~(1 << bit);
+  }
+  inline void setPersistence(Persistence life)
+  {
+    persistence_ = life;
+  }
+  inline Persistence persistence() const
+  {
+    return persistence_;
+  }
+protected:
+  double devex_;
+  double *weights_;
+  CoinIndexedVector *infeasible_;
+  CoinIndexedVector *alternateWeights_;
+  double *savedWeights_;
+  unsigned int *reference_;
+  int state_;
+  int mode_;
+  int infeasibilitiesState_;
+  Persistence persistence_;
+  int numberSwitched_;
+  int pivotSequence_;
+  int savedPivotSequence_;
+  int savedSequenceOut_;
+  int lastRectified_;
+  int sizeFactorization_;
+};
+class ClpPackedMatrix2;
+class ClpPackedMatrix3;
+class CoinDoubleArrayWithLength;
+class ClpPackedMatrix : public ClpMatrixBase {
+public:
+  virtual CoinPackedMatrix *getPackedMatrix() const
+  {
+    return matrix_;
+  }
+  virtual bool isColOrdered() const
+  {
+    return matrix_->isColOrdered();
+  }
+  virtual CoinBigIndex getNumElements() const
+  {
+    return matrix_->getNumElements();
+  }
+  virtual int getNumCols() const
+  {
+    return matrix_->getNumCols();
+  }
+  virtual int getNumRows() const
+  {
+    return matrix_->getNumRows();
+  }
+  virtual const double *getElements() const
+  {
+    return matrix_->getElements();
+  }
+  inline double *getMutableElements() const
+  {
+    return matrix_->getMutableElements();
+  }
+  virtual const int *getIndices() const
+  {
+    return matrix_->getIndices();
+  }
+  virtual const CoinBigIndex *getVectorStarts() const
+  {
+    return matrix_->getVectorStarts();
+  }
+  virtual const int *getVectorLengths() const
+  {
+    return matrix_->getVectorLengths();
+  }
+  virtual int getVectorLength(int index) const
+  {
+    return matrix_->getVectorSize(index);
+  }
+  virtual void deleteCols(const int numDel, const int *indDel);
+  virtual void deleteRows(const int numDel, const int *indDel);
+  virtual void appendCols(int number, const CoinPackedVectorBase *const *columns);
+  virtual void appendRows(int number, const CoinPackedVectorBase *const *rows);
+  virtual int appendMatrix(int number, int type,
+    const CoinBigIndex *starts, const int *index,
+    const double *element, int numberOther = -1);
+  virtual void replaceVector(const int index,
+    const int numReplace, const double *newElements)
+  {
+    matrix_->replaceVector(index, numReplace, newElements);
+  }
+  virtual void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false)
+  {
+    matrix_->modifyCoefficient(row, column, newElement, keepZero);
+  }
+  virtual ClpMatrixBase *reverseOrderedCopy() const;
+  virtual int countBasis(const int *whichColumn,
+    int &numberColumnBasic);
+  virtual void fillBasis(ClpSimplex *model,
+    const int *whichColumn,
+    int &numberColumnBasic,
+    int *row, int *start,
+    int *rowCount, int *columnCount,
+    CoinFactorizationDouble *element);
+  virtual int scale(ClpModel *model, ClpSimplex *simplex = __null) const;
+  virtual void scaleRowCopy(ClpModel *model) const;
+  void createScaledMatrix(ClpSimplex *model) const;
+  virtual ClpMatrixBase *scaledColumnCopy(ClpModel *model) const;
+  virtual bool allElementsInRange(ClpModel *model,
+    double smallest, double largest,
+    int check = 15);
+  virtual void rangeOfElements(double &smallestNegative, double &largestNegative,
+    double &smallestPositive, double &largestPositive);
+  virtual void unpack(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column) const;
+  virtual void unpackPacked(ClpSimplex *model,
+    CoinIndexedVector *rowArray,
+    int column) const;
+  virtual void add(const ClpSimplex *model, CoinIndexedVector *rowArray,
+    int column, double multiplier) const;
+  virtual void add(const ClpSimplex *model, double *array,
+    int column, double multiplier) const;
+  virtual void releasePackedMatrix() const {}
+  virtual CoinBigIndex *dubiousWeights(const ClpSimplex *model, int *inputWeights) const;
+  virtual bool canDoPartialPricing() const;
+  virtual void partialPricing(ClpSimplex *model, double start, double end,
+    int &bestSequence, int &numberWanted);
+  virtual int refresh(ClpSimplex *model);
+  virtual void reallyScale(const double *rowScale, const double *columnScale);
+  virtual void setDimensions(int numrows, int numcols);
+  virtual void times(double scalar,
+    const double *x, double *y) const;
+  virtual void times(double scalar,
+    const double *x, double *y,
+    const double *rowScale,
+    const double *columnScale) const;
+  virtual void transposeTimes(double scalar,
+    const double *x, double *y) const;
+  virtual void transposeTimes(double scalar,
+    const double *x, double *y,
+    const double *rowScale,
+    const double *columnScale,
+    double *spare = __null) const;
+  void transposeTimesSubset(int number,
+    const int *which,
+    const double *pi, double *y,
+    const double *rowScale,
+    const double *columnScale,
+    double *spare = __null) const;
+  virtual void transposeTimes(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  void transposeTimesByColumn(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual void transposeTimesByRow(const ClpSimplex *model, double scalar,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual void subsetTransposeTimes(const ClpSimplex *model,
+    const CoinIndexedVector *x,
+    const CoinIndexedVector *y,
+    CoinIndexedVector *z) const;
+  virtual bool canCombine(const ClpSimplex *model,
+    const CoinIndexedVector *pi) const;
+  virtual int transposeTimes2(const ClpSimplex *model,
+    const CoinIndexedVector *pi1, CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2,
+    CoinIndexedVector *spare,
+    double *infeas, double *reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  virtual void subsetTimes2(const ClpSimplex *model,
+    CoinIndexedVector *dj1,
+    const CoinIndexedVector *pi2, CoinIndexedVector *dj2,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  void useEffectiveRhs(ClpSimplex *model);
+  inline CoinPackedMatrix *matrix() const
+  {
+    return matrix_;
+  }
+  inline void setMatrixNull()
+  {
+    matrix_ = __null;
+  }
+  inline void makeSpecialColumnCopy()
+  {
+    flags_ |= 16;
+  }
+  void releaseSpecialColumnCopy();
+  inline bool zeros() const
+  {
+    return ((flags_ & 1) != 0);
+  }
+  inline bool wantsSpecialColumnCopy() const
+  {
+    return ((flags_ & 16) != 0);
+  }
+  inline int flags() const
+  {
+    return flags_;
+  }
+  inline void checkGaps()
+  {
+    flags_ = (matrix_->hasGaps()) ? (flags_ | 2) : (flags_ & (~2));
+  }
+  inline int numberActiveColumns() const
+  {
+    return numberActiveColumns_;
+  }
+  inline void setNumberActiveColumns(int value)
+  {
+    numberActiveColumns_ = value;
+  }
+  ClpPackedMatrix();
+  virtual ~ClpPackedMatrix();
+  ClpPackedMatrix(const ClpPackedMatrix &);
+  ClpPackedMatrix(const CoinPackedMatrix &);
+  ClpPackedMatrix(const ClpPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  ClpPackedMatrix(const CoinPackedMatrix &wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  ClpPackedMatrix(CoinPackedMatrix *matrix);
+  ClpPackedMatrix &operator=(const ClpPackedMatrix &);
+  virtual ClpMatrixBase *clone() const;
+  virtual void copy(const ClpPackedMatrix *from);
+  virtual ClpMatrixBase *subsetClone(
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns) const;
+  void specialRowCopy(ClpSimplex *model, const ClpMatrixBase *rowCopy);
+  void specialColumnCopy(ClpSimplex *model);
+  virtual void correctSequence(const ClpSimplex *model, int &sequenceIn, int &sequenceOut);
+private:
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const double tolerance) const;
+  int gutsOfTransposeTimesScaled(const double * pi,
+    const double * columnScale,
+    int * index,
+    double * array,
+    const double tolerance) const;
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    const double tolerance) const;
+  int gutsOfTransposeTimesUnscaled(const double * pi,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    int * spareIndex,
+    double * spareArray,
+    const double * reducedCost,
+    double &upperTheta,
+    double acceptablePivot,
+    double dualTolerance,
+    int &numberRemaining,
+    const double zeroTolerance) const;
+  int gutsOfTransposeTimesScaled(const double * pi,
+    const double * columnScale,
+    int * index,
+    double * array,
+    const unsigned char *status,
+    const double tolerance) const;
+  int gutsOfTransposeTimesByRowGEK(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    int numberColumns,
+    const double tolerance,
+    const double scalar) const;
+  int gutsOfTransposeTimesByRowGE3(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    double * array2,
+    const double tolerance,
+    const double scalar) const;
+  int gutsOfTransposeTimesByRowGE3a(const CoinIndexedVector * piVector,
+    int * index,
+    double * output,
+    int * lookup,
+    char * marked,
+    const double tolerance,
+    const double scalar) const;
+  void gutsOfTransposeTimesByRowEQ2(const CoinIndexedVector *piVector, CoinIndexedVector *output,
+    CoinIndexedVector *spareVector, const double tolerance, const double scalar) const;
+  void gutsOfTransposeTimesByRowEQ1(const CoinIndexedVector *piVector, CoinIndexedVector *output,
+    const double tolerance, const double scalar) const;
+  void clearCopies();
+protected:
+  void checkFlags(int type) const;
+  CoinPackedMatrix *matrix_;
+  int numberActiveColumns_;
+  mutable int flags_;
+  ClpPackedMatrix2 *rowCopy_;
+  ClpPackedMatrix3 *columnCopy_;
+};
+class ClpPackedMatrix2 {
+public:
+  void transposeTimes(const ClpSimplex *model,
+    const CoinPackedMatrix *rowCopy,
+    const CoinIndexedVector *x,
+    CoinIndexedVector *spareArray,
+    CoinIndexedVector *z) const;
+  inline bool usefulInfo() const
+  {
+    return rowStart_ != __null;
+  }
+  ClpPackedMatrix2();
+  ClpPackedMatrix2(ClpSimplex *model, const CoinPackedMatrix *rowCopy);
+  virtual ~ClpPackedMatrix2();
+  ClpPackedMatrix2(const ClpPackedMatrix2 &);
+  ClpPackedMatrix2 &operator=(const ClpPackedMatrix2 &);
+protected:
+  int numberBlocks_;
+  int numberRows_;
+  int *offset_;
+  mutable unsigned short *count_;
+  mutable CoinBigIndex *rowStart_;
+  unsigned short *column_;
+  double *work_;
+};
+typedef struct {
+  CoinBigIndex startElements_;
+  CoinBigIndex startRows_;
+  int startIndices_;
+  int numberInBlock_;
+  int numberScan_;
+  int firstAtLower_;
+  int firstAtUpper_;
+  int firstBasic_;
+  int numberElements_;
+  int numberOnes_;
+} blockStruct;
+class ClpPackedMatrix3 {
+public:
+  void transposeTimes(const ClpSimplex *model,
+    const double *pi,
+    CoinIndexedVector *output) const;
+  void transposeTimes(const ClpSimplex *model,
+    const double *pi,
+    CoinIndexedVector *output,
+    CoinIndexedVector *candidate,
+    const CoinIndexedVector *rowArray) const;
+  void transposeTimes2(const ClpSimplex *model,
+    const double *pi, CoinIndexedVector *dj1,
+    const double *piWeight,
+    double * infeas,
+    double * reducedCost,
+    double referenceIn, double devex,
+    unsigned int *reference,
+    double *weights, double scaleFactor);
+  ClpPackedMatrix3();
+  ClpPackedMatrix3(ClpSimplex *model, const CoinPackedMatrix *columnCopy);
+  virtual ~ClpPackedMatrix3();
+  ClpPackedMatrix3(const ClpPackedMatrix3 &);
+  ClpPackedMatrix3 &operator=(const ClpPackedMatrix3 &);
+  void sortBlocks(const ClpSimplex *model);
+  void swapOne(const ClpSimplex *model, const ClpPackedMatrix *matrix,
+    int iColumn);
+  void swapOne(int iBlock, int kA, int kB);
+  void checkBlocks(const ClpSimplex *model);
+  int redoInfeasibilities(const ClpSimplex *model,
+    ClpPrimalColumnSteepest *pivotChoose,
+    int type);
+protected:
+  int numberBlocks_;
+  int numberColumns_;
+  int numberColumnsWithGaps_;
+  CoinBigIndex numberElements_;
+  int maxBlockSize_;
+  int *column_;
+  CoinBigIndex *start_;
+  int *row_;
+  double *element_;
+  CoinDoubleArrayWithLength *temporary_;
+  blockStruct *block_;
+  int ifActive_;
+};
+class CoinOneMessage {
+public:
+  CoinOneMessage();
+  CoinOneMessage(int externalNumber, char detail,
+    const char *message);
+  ~CoinOneMessage();
+  CoinOneMessage(const CoinOneMessage &);
+  CoinOneMessage &operator=(const CoinOneMessage &);
+  void replaceMessage(const char *message);
+  inline int externalNumber() const
+  {
+    return externalNumber_;
+  }
+  inline void setExternalNumber(int number)
+  {
+    externalNumber_ = number;
+  }
+  inline char severity() const
+  {
+    return severity_;
+  }
+  inline void setDetail(int level)
+  {
+    detail_ = static_cast< char >(level);
+  }
+  inline int detail() const
+  {
+    return detail_;
+  }
+  inline char *message() const
+  {
+    return message_;
+  }
+  int externalNumber_;
+  char detail_;
+  char severity_;
+  mutable char message_[400];
+};
+class CoinMessages {
+public:
+  enum Language {
+    us_en = 0,
+    uk_en,
+    it
+  };
+  CoinMessages(int numberMessages = 0);
+  ~CoinMessages();
+  CoinMessages(const CoinMessages &);
+  CoinMessages &operator=(const CoinMessages &);
+  void addMessage(int messageNumber, const CoinOneMessage &message);
+  void replaceMessage(int messageNumber, const char *message);
+  inline Language language() const
+  {
+    return language_;
+  }
+  void setLanguage(Language newlanguage)
+  {
+    language_ = newlanguage;
+  }
+  void setDetailMessage(int newLevel, int messageNumber);
+  void setDetailMessages(int newLevel, int numberMessages,
+    int *messageNumbers);
+  void setDetailMessages(int newLevel, int low, int high);
+  inline int getClass() const
+  {
+    return class_;
+  }
+  void toCompact();
+  void fromCompact();
+  int numberMessages_;
+  Language language_;
+  char source_[5];
+  int class_;
+  int lengthMessages_;
+  CoinOneMessage **message_;
+};
+enum CoinMessageMarker {
+  CoinMessageEol = 0,
+  CoinMessageNewline = 1
+};
+class CoinMessageHandler {
+  friend bool CoinMessageHandlerUnitTest();
+public:
+  virtual int print();
+  virtual void checkSeverity();
+  CoinMessageHandler();
+  CoinMessageHandler(FILE *fp);
+  virtual ~CoinMessageHandler();
+  CoinMessageHandler(const CoinMessageHandler &);
+  CoinMessageHandler &operator=(const CoinMessageHandler &);
+  virtual CoinMessageHandler *clone() const;
+  inline int detail(int messageNumber, const CoinMessages &normalMessage) const
+  {
+    return normalMessage.message_[messageNumber]->detail();
+  }
+  inline int logLevel() const
+  {
+    return logLevel_;
+  }
+  void setLogLevel(int value);
+  inline int logLevel(int which) const
+  {
+    return logLevels_[which];
+  }
+  void setLogLevel(int which, int value);
+  void setPrecision(unsigned int new_precision);
+  inline int precision() { return (g_precision_); }
+  void setPrefix(bool yesNo);
+  bool prefix() const;
+  inline double doubleValue(int position) const
+  {
+    return doubleValue_[position];
+  }
+  inline int numberDoubleFields() const
+  {
+    return static_cast< int >(doubleValue_.size());
+  }
+  inline CoinBigIndex intValue(int position) const
+  {
+    return longValue_[position];
+  }
+  inline int numberIntFields() const
+  {
+    return static_cast< int >(longValue_.size());
+  }
+  inline char charValue(int position) const
+  {
+    return charValue_[position];
+  }
+  inline int numberCharFields() const
+  {
+    return static_cast< int >(charValue_.size());
+  }
+  inline std::string stringValue(int position) const
+  {
+    return stringValue_[position];
+  }
+  inline int numberStringFields() const
+  {
+    return static_cast< int >(stringValue_.size());
+  }
+  inline CoinOneMessage currentMessage() const
+  {
+    return currentMessage_;
+  }
+  inline std::string currentSource() const
+  {
+    return source_;
+  }
+  inline const char *messageBuffer() const
+  {
+    return messageBuffer_;
+  }
+  inline int highestNumber() const
+  {
+    return highestNumber_;
+  }
+  inline FILE *filePointer() const
+  {
+    return fp_;
+  }
+  inline void setFilePointer(FILE *fp)
+  {
+    fp_ = fp;
+  }
+  CoinMessageHandler &message(int messageNumber,
+    const CoinMessages &messages);
+  CoinMessageHandler &message(int detail = -1);
+  CoinMessageHandler &message(int externalNumber, const char *source,
+    const char *msg,
+    char severity, int detail = -1);
+  CoinMessageHandler &operator<<(int intvalue);
+  CoinMessageHandler &operator<<(double doublevalue);
+  CoinMessageHandler &operator<<(const std::string &stringvalue);
+  CoinMessageHandler &operator<<(char charvalue);
+  CoinMessageHandler &operator<<(const char *stringvalue);
+  CoinMessageHandler &operator<<(CoinMessageMarker);
+  int finish();
+  CoinMessageHandler &printing(bool onOff);
+protected:
+  std::vector< double > doubleValue_;
+  std::vector< CoinBigIndex > longValue_;
+  std::vector< char > charValue_;
+  std::vector< std::string > stringValue_;
+  int logLevel_;
+  int logLevels_[4];
+  int prefix_;
+  CoinOneMessage currentMessage_;
+  int internalNumber_;
+  char *format_;
+  char messageBuffer_[1000];
+  char *messageOut_;
+  std::string source_;
+  int printStatus_;
+  int highestNumber_;
+  FILE *fp_;
+  char g_format_[8];
+  int g_precision_;
+private:
+  void gutsOfCopy(const CoinMessageHandler &rhs);
+  char *nextPerCent(char *start, const bool initial = false);
+  int internalPrint();
+  void calcPrintStatus(int msglvl, int msgclass);
+};
+bool CoinMessageHandlerUnitTest();
+extern "C" {
+typedef __socklen_t socklen_t;
+extern int access (const char *__name, int __type) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int euidaccess (const char *__name, int __type)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int eaccess (const char *__name, int __type)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int execveat (int __fd, const char *__path, char *const __argv[],
+                     char *const __envp[], int __flags)
+    noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
+extern int faccessat (int __fd, const char *__file, int __type, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
+extern __off_t lseek (int __fd, __off_t __offset, int __whence) noexcept (true);
+extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
+     noexcept (true);
+extern int close (int __fd);
+extern void closefrom (int __lowfd) noexcept (true);
+extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
+                                                  ;
+extern ssize_t write (int __fd, const void *__buf, size_t __n)
+                                         ;
+extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
+        __off_t __offset)
+                                                  ;
+extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
+         __off_t __offset)
+                                         ;
+extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
+   __off64_t __offset)
+                                                  ;
+extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
+    __off64_t __offset)
+                                         ;
+extern int pipe (int __pipedes[2]) noexcept (true) ;
+extern int pipe2 (int __pipedes[2], int __flags) noexcept (true) ;
+extern unsigned int alarm (unsigned int __seconds) noexcept (true);
+extern unsigned int sleep (unsigned int __seconds);
+extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
+     noexcept (true);
+extern int usleep (__useconds_t __useconds);
+extern int pause (void);
+extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchown (int __fd, __uid_t __owner, __gid_t __group) noexcept (true) ;
+extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchownat (int __fd, const char *__file, __uid_t __owner,
+       __gid_t __group, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
+extern int chdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int fchdir (int __fd) noexcept (true) ;
+extern char *getcwd (char *__buf, size_t __size) noexcept (true) ;
+extern char *get_current_dir_name (void) noexcept (true);
+extern char *getwd (char *__buf)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
+                                       ;
+extern int dup (int __fd) noexcept (true) ;
+extern int dup2 (int __fd, int __fd2) noexcept (true);
+extern int dup3 (int __fd, int __fd2, int __flags) noexcept (true);
+extern char **__environ;
+extern char **environ;
+extern int execve (const char *__path, char *const __argv[],
+     char *const __envp[]) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
+     noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int execv (const char *__path, char *const __argv[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execle (const char *__path, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execl (const char *__path, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execvp (const char *__file, char *const __argv[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execlp (const char *__file, const char *__arg, ...)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int execvpe (const char *__file, char *const __argv[],
+      char *const __envp[])
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern int nice (int __inc) noexcept (true) ;
+extern void _exit (int __status) __attribute__ ((__noreturn__));
+enum
+  {
+    _PC_LINK_MAX,
+    _PC_MAX_CANON,
+    _PC_MAX_INPUT,
+    _PC_NAME_MAX,
+    _PC_PATH_MAX,
+    _PC_PIPE_BUF,
+    _PC_CHOWN_RESTRICTED,
+    _PC_NO_TRUNC,
+    _PC_VDISABLE,
+    _PC_SYNC_IO,
+    _PC_ASYNC_IO,
+    _PC_PRIO_IO,
+    _PC_SOCK_MAXBUF,
+    _PC_FILESIZEBITS,
+    _PC_REC_INCR_XFER_SIZE,
+    _PC_REC_MAX_XFER_SIZE,
+    _PC_REC_MIN_XFER_SIZE,
+    _PC_REC_XFER_ALIGN,
+    _PC_ALLOC_SIZE_MIN,
+    _PC_SYMLINK_MAX,
+    _PC_2_SYMLINKS
+  };
+enum
+  {
+    _SC_ARG_MAX,
+    _SC_CHILD_MAX,
+    _SC_CLK_TCK,
+    _SC_NGROUPS_MAX,
+    _SC_OPEN_MAX,
+    _SC_STREAM_MAX,
+    _SC_TZNAME_MAX,
+    _SC_JOB_CONTROL,
+    _SC_SAVED_IDS,
+    _SC_REALTIME_SIGNALS,
+    _SC_PRIORITY_SCHEDULING,
+    _SC_TIMERS,
+    _SC_ASYNCHRONOUS_IO,
+    _SC_PRIORITIZED_IO,
+    _SC_SYNCHRONIZED_IO,
+    _SC_FSYNC,
+    _SC_MAPPED_FILES,
+    _SC_MEMLOCK,
+    _SC_MEMLOCK_RANGE,
+    _SC_MEMORY_PROTECTION,
+    _SC_MESSAGE_PASSING,
+    _SC_SEMAPHORES,
+    _SC_SHARED_MEMORY_OBJECTS,
+    _SC_AIO_LISTIO_MAX,
+    _SC_AIO_MAX,
+    _SC_AIO_PRIO_DELTA_MAX,
+    _SC_DELAYTIMER_MAX,
+    _SC_MQ_OPEN_MAX,
+    _SC_MQ_PRIO_MAX,
+    _SC_VERSION,
+    _SC_PAGESIZE,
+    _SC_RTSIG_MAX,
+    _SC_SEM_NSEMS_MAX,
+    _SC_SEM_VALUE_MAX,
+    _SC_SIGQUEUE_MAX,
+    _SC_TIMER_MAX,
+    _SC_BC_BASE_MAX,
+    _SC_BC_DIM_MAX,
+    _SC_BC_SCALE_MAX,
+    _SC_BC_STRING_MAX,
+    _SC_COLL_WEIGHTS_MAX,
+    _SC_EQUIV_CLASS_MAX,
+    _SC_EXPR_NEST_MAX,
+    _SC_LINE_MAX,
+    _SC_RE_DUP_MAX,
+    _SC_CHARCLASS_NAME_MAX,
+    _SC_2_VERSION,
+    _SC_2_C_BIND,
+    _SC_2_C_DEV,
+    _SC_2_FORT_DEV,
+    _SC_2_FORT_RUN,
+    _SC_2_SW_DEV,
+    _SC_2_LOCALEDEF,
+    _SC_PII,
+    _SC_PII_XTI,
+    _SC_PII_SOCKET,
+    _SC_PII_INTERNET,
+    _SC_PII_OSI,
+    _SC_POLL,
+    _SC_SELECT,
+    _SC_UIO_MAXIOV,
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+    _SC_PII_INTERNET_STREAM,
+    _SC_PII_INTERNET_DGRAM,
+    _SC_PII_OSI_COTS,
+    _SC_PII_OSI_CLTS,
+    _SC_PII_OSI_M,
+    _SC_T_IOV_MAX,
+    _SC_THREADS,
+    _SC_THREAD_SAFE_FUNCTIONS,
+    _SC_GETGR_R_SIZE_MAX,
+    _SC_GETPW_R_SIZE_MAX,
+    _SC_LOGIN_NAME_MAX,
+    _SC_TTY_NAME_MAX,
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+    _SC_THREAD_KEYS_MAX,
+    _SC_THREAD_STACK_MIN,
+    _SC_THREAD_THREADS_MAX,
+    _SC_THREAD_ATTR_STACKADDR,
+    _SC_THREAD_ATTR_STACKSIZE,
+    _SC_THREAD_PRIORITY_SCHEDULING,
+    _SC_THREAD_PRIO_INHERIT,
+    _SC_THREAD_PRIO_PROTECT,
+    _SC_THREAD_PROCESS_SHARED,
+    _SC_NPROCESSORS_CONF,
+    _SC_NPROCESSORS_ONLN,
+    _SC_PHYS_PAGES,
+    _SC_AVPHYS_PAGES,
+    _SC_ATEXIT_MAX,
+    _SC_PASS_MAX,
+    _SC_XOPEN_VERSION,
+    _SC_XOPEN_XCU_VERSION,
+    _SC_XOPEN_UNIX,
+    _SC_XOPEN_CRYPT,
+    _SC_XOPEN_ENH_I18N,
+    _SC_XOPEN_SHM,
+    _SC_2_CHAR_TERM,
+    _SC_2_C_VERSION,
+    _SC_2_UPE,
+    _SC_XOPEN_XPG2,
+    _SC_XOPEN_XPG3,
+    _SC_XOPEN_XPG4,
+    _SC_CHAR_BIT,
+    _SC_CHAR_MAX,
+    _SC_CHAR_MIN,
+    _SC_INT_MAX,
+    _SC_INT_MIN,
+    _SC_LONG_BIT,
+    _SC_WORD_BIT,
+    _SC_MB_LEN_MAX,
+    _SC_NZERO,
+    _SC_SSIZE_MAX,
+    _SC_SCHAR_MAX,
+    _SC_SCHAR_MIN,
+    _SC_SHRT_MAX,
+    _SC_SHRT_MIN,
+    _SC_UCHAR_MAX,
+    _SC_UINT_MAX,
+    _SC_ULONG_MAX,
+    _SC_USHRT_MAX,
+    _SC_NL_ARGMAX,
+    _SC_NL_LANGMAX,
+    _SC_NL_MSGMAX,
+    _SC_NL_NMAX,
+    _SC_NL_SETMAX,
+    _SC_NL_TEXTMAX,
+    _SC_XBS5_ILP32_OFF32,
+    _SC_XBS5_ILP32_OFFBIG,
+    _SC_XBS5_LP64_OFF64,
+    _SC_XBS5_LPBIG_OFFBIG,
+    _SC_XOPEN_LEGACY,
+    _SC_XOPEN_REALTIME,
+    _SC_XOPEN_REALTIME_THREADS,
+    _SC_ADVISORY_INFO,
+    _SC_BARRIERS,
+    _SC_BASE,
+    _SC_C_LANG_SUPPORT,
+    _SC_C_LANG_SUPPORT_R,
+    _SC_CLOCK_SELECTION,
+    _SC_CPUTIME,
+    _SC_THREAD_CPUTIME,
+    _SC_DEVICE_IO,
+    _SC_DEVICE_SPECIFIC,
+    _SC_DEVICE_SPECIFIC_R,
+    _SC_FD_MGMT,
+    _SC_FIFO,
+    _SC_PIPE,
+    _SC_FILE_ATTRIBUTES,
+    _SC_FILE_LOCKING,
+    _SC_FILE_SYSTEM,
+    _SC_MONOTONIC_CLOCK,
+    _SC_MULTI_PROCESS,
+    _SC_SINGLE_PROCESS,
+    _SC_NETWORKING,
+    _SC_READER_WRITER_LOCKS,
+    _SC_SPIN_LOCKS,
+    _SC_REGEXP,
+    _SC_REGEX_VERSION,
+    _SC_SHELL,
+    _SC_SIGNALS,
+    _SC_SPAWN,
+    _SC_SPORADIC_SERVER,
+    _SC_THREAD_SPORADIC_SERVER,
+    _SC_SYSTEM_DATABASE,
+    _SC_SYSTEM_DATABASE_R,
+    _SC_TIMEOUTS,
+    _SC_TYPED_MEMORY_OBJECTS,
+    _SC_USER_GROUPS,
+    _SC_USER_GROUPS_R,
+    _SC_2_PBS,
+    _SC_2_PBS_ACCOUNTING,
+    _SC_2_PBS_LOCATE,
+    _SC_2_PBS_MESSAGE,
+    _SC_2_PBS_TRACK,
+    _SC_SYMLOOP_MAX,
+    _SC_STREAMS,
+    _SC_2_PBS_CHECKPOINT,
+    _SC_V6_ILP32_OFF32,
+    _SC_V6_ILP32_OFFBIG,
+    _SC_V6_LP64_OFF64,
+    _SC_V6_LPBIG_OFFBIG,
+    _SC_HOST_NAME_MAX,
+    _SC_TRACE,
+    _SC_TRACE_EVENT_FILTER,
+    _SC_TRACE_INHERIT,
+    _SC_TRACE_LOG,
+    _SC_LEVEL1_ICACHE_SIZE,
+    _SC_LEVEL1_ICACHE_ASSOC,
+    _SC_LEVEL1_ICACHE_LINESIZE,
+    _SC_LEVEL1_DCACHE_SIZE,
+    _SC_LEVEL1_DCACHE_ASSOC,
+    _SC_LEVEL1_DCACHE_LINESIZE,
+    _SC_LEVEL2_CACHE_SIZE,
+    _SC_LEVEL2_CACHE_ASSOC,
+    _SC_LEVEL2_CACHE_LINESIZE,
+    _SC_LEVEL3_CACHE_SIZE,
+    _SC_LEVEL3_CACHE_ASSOC,
+    _SC_LEVEL3_CACHE_LINESIZE,
+    _SC_LEVEL4_CACHE_SIZE,
+    _SC_LEVEL4_CACHE_ASSOC,
+    _SC_LEVEL4_CACHE_LINESIZE,
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+    _SC_RAW_SOCKETS,
+    _SC_V7_ILP32_OFF32,
+    _SC_V7_ILP32_OFFBIG,
+    _SC_V7_LP64_OFF64,
+    _SC_V7_LPBIG_OFFBIG,
+    _SC_SS_REPL_MAX,
+    _SC_TRACE_EVENT_NAME_MAX,
+    _SC_TRACE_NAME_MAX,
+    _SC_TRACE_SYS_MAX,
+    _SC_TRACE_USER_EVENT_MAX,
+    _SC_XOPEN_STREAMS,
+    _SC_THREAD_ROBUST_PRIO_INHERIT,
+    _SC_THREAD_ROBUST_PRIO_PROTECT,
+    _SC_MINSIGSTKSZ,
+    _SC_SIGSTKSZ
+  };
+enum
+  {
+    _CS_PATH,
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+    _CS_GNU_LIBC_VERSION,
+    _CS_GNU_LIBPTHREAD_VERSION,
+    _CS_V5_WIDTH_RESTRICTED_ENVS,
+    _CS_V7_WIDTH_RESTRICTED_ENVS,
+    _CS_LFS_CFLAGS = 1000,
+    _CS_LFS_LDFLAGS,
+    _CS_LFS_LIBS,
+    _CS_LFS_LINTFLAGS,
+    _CS_LFS64_CFLAGS,
+    _CS_LFS64_LDFLAGS,
+    _CS_LFS64_LIBS,
+    _CS_LFS64_LINTFLAGS,
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+    _CS_XBS5_ILP32_OFF32_LIBS,
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+    _CS_XBS5_LP64_OFF64_LIBS,
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LIBS,
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LIBS,
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_V6_ENV,
+    _CS_V7_ENV
+  };
+extern long int pathconf (const char *__path, int __name)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern long int fpathconf (int __fd, int __name) noexcept (true);
+extern long int sysconf (int __name) noexcept (true);
+extern size_t confstr (int __name, char *__buf, size_t __len) noexcept (true)
+                                                  ;
+extern __pid_t getpid (void) noexcept (true);
+extern __pid_t getppid (void) noexcept (true);
+extern __pid_t getpgrp (void) noexcept (true);
+extern __pid_t __getpgid (__pid_t __pid) noexcept (true);
+extern __pid_t getpgid (__pid_t __pid) noexcept (true);
+extern int setpgid (__pid_t __pid, __pid_t __pgid) noexcept (true);
+extern int setpgrp (void) noexcept (true);
+extern __pid_t setsid (void) noexcept (true);
+extern __pid_t getsid (__pid_t __pid) noexcept (true);
+extern __uid_t getuid (void) noexcept (true);
+extern __uid_t geteuid (void) noexcept (true);
+extern __gid_t getgid (void) noexcept (true);
+extern __gid_t getegid (void) noexcept (true);
+extern int getgroups (int __size, __gid_t __list[]) noexcept (true)
+                                                  ;
+extern int group_member (__gid_t __gid) noexcept (true);
+extern int setuid (__uid_t __uid) noexcept (true) ;
+extern int setreuid (__uid_t __ruid, __uid_t __euid) noexcept (true) ;
+extern int seteuid (__uid_t __uid) noexcept (true) ;
+extern int setgid (__gid_t __gid) noexcept (true) ;
+extern int setregid (__gid_t __rgid, __gid_t __egid) noexcept (true) ;
+extern int setegid (__gid_t __gid) noexcept (true) ;
+extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
+     noexcept (true);
+extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
+     noexcept (true);
+extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
+     noexcept (true) ;
+extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
+     noexcept (true) ;
+extern __pid_t fork (void) noexcept (true);
+extern __pid_t vfork (void) noexcept (true);
+extern __pid_t _Fork (void) noexcept (true);
+extern char *ttyname (int __fd) noexcept (true);
+extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
+     noexcept (true) __attribute__ ((__nonnull__ (2)))
+                                                   ;
+extern int isatty (int __fd) noexcept (true);
+extern int ttyslot (void) noexcept (true);
+extern int link (const char *__from, const char *__to)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;
+extern int linkat (int __fromfd, const char *__from, int __tofd,
+     const char *__to, int __flags)
+     noexcept (true) __attribute__ ((__nonnull__ (2, 4))) ;
+extern int symlink (const char *__from, const char *__to)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;
+extern ssize_t readlink (const char *__restrict __path,
+    char *__restrict __buf, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
+                                                   ;
+extern int symlinkat (const char *__from, int __tofd,
+        const char *__to) noexcept (true) __attribute__ ((__nonnull__ (1, 3))) ;
+extern ssize_t readlinkat (int __fd, const char *__restrict __path,
+      char *__restrict __buf, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (2, 3)))
+                                                   ;
+extern int unlink (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int unlinkat (int __fd, const char *__name, int __flag)
+     noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int rmdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern __pid_t tcgetpgrp (int __fd) noexcept (true);
+extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) noexcept (true);
+extern char *getlogin (void);
+extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
+                                                  ;
+extern int setlogin (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern "C" {
+extern char *optarg;
+extern int optind;
+extern int opterr;
+extern int optopt;
+extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
+       noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
+}
+
+extern "C" {
+}
+extern int gethostname (char *__name, size_t __len) noexcept (true) __attribute__ ((__nonnull__ (1)))
+                                                  ;
+extern int sethostname (const char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int sethostid (long int __id) noexcept (true) ;
+extern int getdomainname (char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1)))
+                                                   ;
+extern int setdomainname (const char *__name, size_t __len)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int vhangup (void) noexcept (true);
+extern int revoke (const char *__file) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int profil (unsigned short int *__sample_buffer, size_t __size,
+     size_t __offset, unsigned int __scale)
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int acct (const char *__name) noexcept (true);
+extern char *getusershell (void) noexcept (true);
+extern void endusershell (void) noexcept (true);
+extern void setusershell (void) noexcept (true);
+extern int daemon (int __nochdir, int __noclose) noexcept (true) ;
+extern int chroot (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));
+extern int fsync (int __fd);
+extern int syncfs (int __fd) noexcept (true);
+extern long int gethostid (void);
+extern void sync (void) noexcept (true);
+extern int getpagesize (void) noexcept (true) __attribute__ ((__const__));
+extern int getdtablesize (void) noexcept (true);
+extern int truncate (const char *__file, __off_t __length)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int truncate64 (const char *__file, __off64_t __length)
+     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
+extern int ftruncate (int __fd, __off_t __length) noexcept (true) ;
+extern int ftruncate64 (int __fd, __off64_t __length) noexcept (true) ;
+extern int brk (void *__addr) noexcept (true) ;
+extern void *sbrk (intptr_t __delta) noexcept (true);
+extern long int syscall (long int __sysno, ...) noexcept (true);
+extern int lockf (int __fd, int __cmd, __off_t __len) ;
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
+ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
+    int __outfd, __off64_t *__poutoff,
+    size_t __length, unsigned int __flags);
+extern int fdatasync (int __fildes);
+extern char *crypt (const char *__key, const char *__salt)
+     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
+extern void swab (const void *__restrict __from, void *__restrict __to,
+    ssize_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
+                                          ;
+int getentropy (void *__buffer, size_t __length)
+                                          ;
+extern int close_range (unsigned int __fd, unsigned int __max_fd,
+   int __flags) noexcept (true);
+extern __pid_t gettid (void) noexcept (true);
+
+}
+template < class T >
+inline void
+CoinCopyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+  CoinBigIndex n = (size + 7) / 8;
+  if (to > from) {
+    const T *downfrom = from + size;
+    T *downto = to + size;
+    switch (size % 8) {
+    case 0:
+      do {
+        *--downto = *--downfrom;
+      case 7:
+        *--downto = *--downfrom;
+      case 6:
+        *--downto = *--downfrom;
+      case 5:
+        *--downto = *--downfrom;
+      case 4:
+        *--downto = *--downfrom;
+      case 3:
+        *--downto = *--downfrom;
+      case 2:
+        *--downto = *--downfrom;
+      case 1:
+        *--downto = *--downfrom;
+      } while (--n > 0);
+    }
+  } else {
+    --from;
+    --to;
+    switch (size % 8) {
+    case 0:
+      do {
+        *++to = *++from;
+      case 7:
+        *++to = *++from;
+      case 6:
+        *++to = *++from;
+      case 5:
+        *++to = *++from;
+      case 4:
+        *++to = *++from;
+      case 3:
+        *++to = *++from;
+      case 2:
+        *++to = *++from;
+      case 1:
+        *++to = *++from;
+      } while (--n > 0);
+    }
+  }
+}
+template < class T >
+inline void
+CoinCopy(const T *first, const T *last, T *to)
+{
+  CoinCopyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline void
+CoinDisjointCopyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, from += 8, to += 8) {
+    to[0] = from[0];
+    to[1] = from[1];
+    to[2] = from[2];
+    to[3] = from[3];
+    to[4] = from[4];
+    to[5] = from[5];
+    to[6] = from[6];
+    to[7] = from[7];
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = from[6];
+  case 6:
+    to[5] = from[5];
+  case 5:
+    to[4] = from[4];
+  case 4:
+    to[3] = from[3];
+  case 3:
+    to[2] = from[2];
+  case 2:
+    to[1] = from[1];
+  case 1:
+    to[0] = from[0];
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinDisjointCopy(const T *first, const T *last,
+  T *to)
+{
+  CoinDisjointCopyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline T *
+CoinCopyOfArray(const T *array, const CoinBigIndex size)
+{
+  if (array) {
+    T *arrayNew = new T[size];
+    std::memcpy(arrayNew, array, size * sizeof(T));
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+template < class T >
+inline T *
+CoinCopyOfArrayPartial(const T *array, const CoinBigIndex size, const CoinBigIndex copySize)
+{
+  if (array || size) {
+    T *arrayNew = new T[size];
+    (static_cast<void> (0));
+    std::memcpy(arrayNew, array, copySize * sizeof(T));
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+template < class T >
+inline T *
+CoinCopyOfArray(const T *array, const CoinBigIndex size, T value)
+{
+  T *arrayNew = new T[size];
+  if (array) {
+    std::memcpy(arrayNew, array, size * sizeof(T));
+  } else {
+    CoinBigIndex i;
+    for (i = 0; i < size; i++)
+      arrayNew[i] = value;
+  }
+  return arrayNew;
+}
+template < class T >
+inline T *
+CoinCopyOfArrayOrZero(const T *array, const CoinBigIndex size)
+{
+  T *arrayNew = new T[size];
+  if (array) {
+    std::memcpy(arrayNew, array, size * sizeof(T));
+  } else {
+    std::memset(arrayNew, 0, size * sizeof(T));
+  }
+  return arrayNew;
+}
+template < class T >
+inline void
+CoinMemcpyN(const T *from, const CoinBigIndex size, T *to)
+{
+  if (size == 0 || from == to)
+    return;
+    for (CoinBigIndex n = static_cast<CoinBigIndex>(size>>3); n > 0; --n, from += 8, to += 8) {
+    to[0] = from[0];
+    to[1] = from[1];
+    to[2] = from[2];
+    to[3] = from[3];
+    to[4] = from[4];
+    to[5] = from[5];
+    to[6] = from[6];
+    to[7] = from[7];
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = from[6];
+  case 6:
+    to[5] = from[5];
+  case 5:
+    to[4] = from[4];
+  case 4:
+    to[3] = from[3];
+  case 3:
+    to[2] = from[2];
+  case 2:
+    to[1] = from[1];
+  case 1:
+    to[0] = from[0];
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinMemcpy(const T *first, const T *last,
+  T *to)
+{
+  CoinMemcpyN(first, static_cast< CoinBigIndex >(last - first), to);
+}
+template < class T >
+inline void
+CoinFillN(T *to, const CoinBigIndex size, const T value)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, to += 8) {
+    to[0] = value;
+    to[1] = value;
+    to[2] = value;
+    to[3] = value;
+    to[4] = value;
+    to[5] = value;
+    to[6] = value;
+    to[7] = value;
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = value;
+  case 6:
+    to[5] = value;
+  case 5:
+    to[4] = value;
+  case 4:
+    to[3] = value;
+  case 3:
+    to[2] = value;
+  case 2:
+    to[1] = value;
+  case 1:
+    to[0] = value;
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinFill(T *first, T *last, const T value)
+{
+  CoinFillN(first, last - first, value);
+}
+template < class T >
+inline void
+CoinZeroN(T *to, const CoinBigIndex size)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, to += 8) {
+    to[0] = 0;
+    to[1] = 0;
+    to[2] = 0;
+    to[3] = 0;
+    to[4] = 0;
+    to[5] = 0;
+    to[6] = 0;
+    to[7] = 0;
+  }
+  switch (size % 8) {
+  case 7:
+    to[6] = 0;
+  case 6:
+    to[5] = 0;
+  case 5:
+    to[4] = 0;
+  case 4:
+    to[3] = 0;
+  case 3:
+    to[2] = 0;
+  case 2:
+    to[1] = 0;
+  case 1:
+    to[0] = 0;
+  case 0:
+    break;
+  }
+}
+inline void
+CoinCheckDoubleZero(double *to, const CoinBigIndex size)
+{
+  CoinBigIndex n = 0;
+  for (CoinBigIndex j = 0; j < size; j++) {
+    if (to[j])
+      n++;
+  }
+  if (n) {
+    printf("array of length %d should be zero has %d nonzero\n",
+      static_cast< int >(size), static_cast< int >(n));
+  }
+}
+inline void
+CoinCheckIntZero(int *to, const CoinBigIndex size)
+{
+  CoinBigIndex n = 0;
+  for (CoinBigIndex j = 0; j < size; j++) {
+    if (to[j])
+      n++;
+  }
+  if (n) {
+    printf("array of length %d should be zero has %d nonzero\n",
+      static_cast< int >(size),
+      static_cast< int >(n));
+  }
+}
+template < class T >
+inline void
+CoinZero(T *first, T *last)
+{
+  CoinZeroN(first, last - first);
+}
+inline char *CoinStrdup(const char *name)
+{
+  char *dup = __null;
+  if (name) {
+    const int len = static_cast< int >(strlen(name));
+    dup = static_cast< char * >(malloc(len + 1));
+    CoinMemcpyN(name, len, dup);
+    dup[len] = 0;
+  }
+  return dup;
+}
+template < class T >
+inline T
+CoinMax(const T x1, const T x2)
+{
+  return (x1 > x2) ? x1 : x2;
+}
+template < class T >
+inline T
+CoinMin(const T x1, const T x2)
+{
+  return (x1 < x2) ? x1 : x2;
+}
+template < class T >
+inline T
+CoinAbs(const T value)
+{
+  return value < 0 ? -value : value;
+}
+template < class T >
+inline bool
+CoinIsSorted(const T *first, const CoinBigIndex size)
+{
+  if (size == 0)
+    return true;
+  const CoinBigIndex size1 = size - 1;
+  for (CoinBigIndex n = size1 / 8; n > 0; --n, first += 8) {
+    if (first[8] < first[7])
+      return false;
+    if (first[7] < first[6])
+      return false;
+    if (first[6] < first[5])
+      return false;
+    if (first[5] < first[4])
+      return false;
+    if (first[4] < first[3])
+      return false;
+    if (first[3] < first[2])
+      return false;
+    if (first[2] < first[1])
+      return false;
+    if (first[1] < first[0])
+      return false;
+  }
+  switch (size1 % 8) {
+  case 7:
+    if (first[7] < first[6])
+      return false;
+  case 6:
+    if (first[6] < first[5])
+      return false;
+  case 5:
+    if (first[5] < first[4])
+      return false;
+  case 4:
+    if (first[4] < first[3])
+      return false;
+  case 3:
+    if (first[3] < first[2])
+      return false;
+  case 2:
+    if (first[2] < first[1])
+      return false;
+  case 1:
+    if (first[1] < first[0])
+      return false;
+  case 0:
+    break;
+  }
+  return true;
+}
+template < class T >
+inline bool
+CoinIsSorted(const T *first, const T *last)
+{
+  return CoinIsSorted(first, static_cast< CoinBigIndex >(last - first));
+}
+template < class T >
+inline void
+CoinIotaN(T *first, const CoinBigIndex size, T init)
+{
+  if (size == 0)
+    return;
+  for (CoinBigIndex n = size / 8; n > 0; --n, first += 8, init += 8) {
+    first[0] = init;
+    first[1] = init + 1;
+    first[2] = init + 2;
+    first[3] = init + 3;
+    first[4] = init + 4;
+    first[5] = init + 5;
+    first[6] = init + 6;
+    first[7] = init + 7;
+  }
+  switch (size % 8) {
+  case 7:
+    first[6] = init + 6;
+  case 6:
+    first[5] = init + 5;
+  case 5:
+    first[4] = init + 4;
+  case 4:
+    first[3] = init + 3;
+  case 3:
+    first[2] = init + 2;
+  case 2:
+    first[1] = init + 1;
+  case 1:
+    first[0] = init;
+  case 0:
+    break;
+  }
+}
+template < class T >
+inline void
+CoinIota(T *first, const T *last, T init)
+{
+  CoinIotaN(first, last - first, init);
+}
+template < class T >
+inline T *
+CoinDeleteEntriesFromArray(T *arrayFirst, T *arrayLast,
+  const int *firstDelPos, const int *lastDelPos)
+{
+  CoinBigIndex delNum = static_cast< CoinBigIndex >(lastDelPos - firstDelPos);
+  if (delNum == 0)
+    return arrayLast;
+  if (delNum < 0)
+    throw CoinError("trying to delete negative number of entries",
+      "CoinDeleteEntriesFromArray", "");
+  int *delSortedPos = __null;
+  if (!(CoinIsSorted(firstDelPos, lastDelPos) && std::adjacent_find(firstDelPos, lastDelPos) == lastDelPos)) {
+    delSortedPos = new int[delNum];
+    CoinDisjointCopy(firstDelPos, lastDelPos, delSortedPos);
+    std::sort(delSortedPos, delSortedPos + delNum);
+    delNum = static_cast< CoinBigIndex >(std::unique(delSortedPos,
+                                           delSortedPos + delNum)
+      - delSortedPos);
+  }
+  const int *delSorted = delSortedPos ? delSortedPos : firstDelPos;
+  const CoinBigIndex last = delNum - 1;
+  int size = delSorted[0];
+  for (CoinBigIndex i = 0; i < last; ++i) {
+    const int copyFirst = delSorted[i] + 1;
+    const int copyLast = delSorted[i + 1];
+    CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
+      arrayFirst + size);
+    size += copyLast - copyFirst;
+  }
+  const int copyFirst = delSorted[last] + 1;
+  const int copyLast = static_cast< int >(arrayLast - arrayFirst);
+  CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
+    arrayFirst + size);
+  size += copyLast - copyFirst;
+  if (delSortedPos)
+    delete[] delSortedPos;
+  return arrayFirst + size;
+}
+inline double CoinDrand48(bool isSeed = false, unsigned int seed = 1)
+{
+  static unsigned int last = 123456;
+  if (isSeed) {
+    last = seed;
+  } else {
+    last = 1664525 * last + 1013904223;
+    return ((static_cast< double >(last)) / 4294967296.0);
+  }
+  return (0.0);
+}
+inline void CoinSeedRandom(int iseed)
+{
+  CoinDrand48(true, iseed);
+}
+inline char CoinFindDirSeparator()
+{
+  int size = 1000;
+  char *buf = 0;
+  while (true) {
+    buf = new char[size];
+    if (getcwd(buf, size))
+      break;
+    delete[] buf;
+    buf = 0;
+    size = 2 * size;
+  }
+  char dirsep = buf[0] == '/' ? '/' : '\\';
+  delete[] buf;
+  return dirsep;
+}
+inline int CoinStrNCaseCmp(const char *s0, const char *s1,
+  const size_t len)
+{
+  for (size_t i = 0; i < len; ++i) {
+    if (s0[i] == 0) {
+      return s1[i] == 0 ? 0 : -1;
+    }
+    if (s1[i] == 0) {
+      return 1;
+    }
+    const int c0 = std::tolower(s0[i]);
+    const int c1 = std::tolower(s1[i]);
+    if (c0 < c1)
+      return -1;
+    if (c0 > c1)
+      return 1;
+  }
+  return 0;
+}
+template < class T >
+inline void CoinSwap(T &x, T &y)
+{
+  T t = x;
+  x = y;
+  y = t;
+}
+template < class T >
+inline int
+CoinToFile(const T *array, CoinBigIndex size, FILE *fp)
+{
+  CoinBigIndex numberWritten;
+  if (array && size) {
+    numberWritten = static_cast< CoinBigIndex >(fwrite(&size, sizeof(int), 1, fp));
+    if (numberWritten != 1)
+      return 1;
+    numberWritten = static_cast< CoinBigIndex >(fwrite(array, sizeof(T), size_t(size), fp));
+    if (numberWritten != size)
+      return 1;
+  } else {
+    size = 0;
+    numberWritten = static_cast< CoinBigIndex >(fwrite(&size, sizeof(int), 1, fp));
+    if (numberWritten != 1)
+      return 1;
+  }
+  return 0;
+}
+template < class T >
+inline int
+CoinFromFile(T *&array, CoinBigIndex size, FILE *fp, CoinBigIndex &newSize)
+{
+  CoinBigIndex numberRead;
+  numberRead = static_cast< CoinBigIndex >(fread(&newSize, sizeof(int), 1, fp));
+  if (numberRead != 1)
+    return 1;
+  int returnCode = 0;
+  if (size != newSize && (newSize || array))
+    returnCode = 2;
+  if (newSize) {
+    array = new T[newSize];
+    numberRead = static_cast< CoinBigIndex >(fread(array, sizeof(T), newSize, fp));
+    if (numberRead != newSize)
+      returnCode = 1;
+  } else {
+    array = __null;
+  }
+  return returnCode;
+}
+inline int
+CoinStrlenAsInt(const char *string)
+{
+  return static_cast< int >(strlen(string));
+}
+class CoinThreadRandom {
+public:
+  CoinThreadRandom()
+  {
+    seed_ = 12345678;
+  }
+  CoinThreadRandom(int seed)
+  {
+    seed_ = seed;
+  }
+  ~CoinThreadRandom() {}
+  CoinThreadRandom(const CoinThreadRandom &rhs)
+  {
+    seed_ = rhs.seed_;
+  }
+  CoinThreadRandom &operator=(const CoinThreadRandom &rhs)
+  {
+    if (this != &rhs) {
+      seed_ = rhs.seed_;
+    }
+    return *this;
+  }
+  inline void setSeed(int seed)
+  {
+    seed_ = seed;
+  }
+  inline unsigned int getSeed() const
+  {
+    return seed_;
+  }
+  inline double randomDouble() const
+  {
+    double retVal;
+    seed_ = 1664525 * (seed_) + 1013904223;
+    retVal = ((static_cast< double >(seed_)) / 4294967296.0);
+    return retVal;
+  }
+  inline void randomize(int n = 0)
+  {
+    if (!n)
+      n = seed_ & 255;
+    for (int i = 0; i < n; i++)
+      randomDouble();
+  }
+protected:
+  mutable unsigned int seed_;
+};
+
+const double COIN_DBL_MIN = (std::numeric_limits< double >::min)();
+const double COIN_DBL_MAX = (std::numeric_limits< double >::max)();
+const int COIN_INT_MAX = (std::numeric_limits< int >::max)();
+const double COIN_INT_MAX_AS_DOUBLE = (std::numeric_limits< int >::max)();
+extern bool CoinFinite(double val);
+extern bool CoinIsnan(double val);
+enum ClpIntParam {
+  ClpMaxNumIteration = 0,
+  ClpMaxNumIterationHotStart,
+  ClpNameDiscipline,
+  ClpLastIntParam
+};
+enum ClpDblParam {
+  ClpDualObjectiveLimit,
+  ClpPrimalObjectiveLimit,
+  ClpDualTolerance,
+  ClpPrimalTolerance,
+  ClpObjOffset,
+  ClpMaxSeconds,
+  ClpMaxWallSeconds,
+  ClpPresolveTolerance,
+  ClpLastDblParam
+};
+enum ClpStrParam {
+  ClpProbName = 0,
+  ClpLastStrParam
+};
+template < class T >
+inline void
+ClpDisjointCopyN(const T *array, const CoinBigIndex size, T *newArray)
+{
+  memcpy(reinterpret_cast< void * >(newArray), array, size * sizeof(T));
+}
+template < class T >
+inline void
+ClpFillN(T *array, const CoinBigIndex size, T value)
+{
+  CoinBigIndex i;
+  for (i = 0; i < size; i++)
+    array[i] = value;
+}
+template < class T >
+inline T *
+ClpCopyOfArray(const T *array, const CoinBigIndex size, T value)
+{
+  T *arrayNew = new T[size];
+  if (array)
+    ClpDisjointCopyN(array, size, arrayNew);
+  else
+    ClpFillN(arrayNew, size, value);
+  return arrayNew;
+}
+template < class T >
+inline T *
+ClpCopyOfArray(const T *array, const CoinBigIndex size)
+{
+  if (array) {
+    T *arrayNew = new T[size];
+    ClpDisjointCopyN(array, size, arrayNew);
+    return arrayNew;
+  } else {
+    return __null;
+  }
+}
+typedef struct {
+  int typeStruct;
+  int typeCall;
+  void *data;
+} ClpTrustedData;
+class ClpSimplex;
+class ClpModel;
+class ClpObjective {
+public:
+  virtual double *gradient(const ClpSimplex *model,
+    const double *solution,
+    double &offset, bool refresh,
+    int includeLinear = 2)
+    = 0;
+  virtual double reducedGradient(ClpSimplex *model, double *region,
+    bool useFeasibleCosts)
+    = 0;
+  virtual double stepLength(ClpSimplex *model,
+    const double *solution,
+    const double *change,
+    double maximumTheta,
+    double &currentObj,
+    double &predictedObj,
+    double &thetaObj)
+    = 0;
+  virtual double objectiveValue(const ClpSimplex *model, const double *solution) const = 0;
+  virtual void resize(int newNumberColumns) = 0;
+  virtual void deleteSome(int numberToDelete, const int *which) = 0;
+  virtual void reallyScale(const double *columnScale) = 0;
+  virtual int markNonlinear(char *which);
+  virtual void newXValues() {}
+  ClpObjective();
+  ClpObjective(const ClpObjective &);
+  ClpObjective &operator=(const ClpObjective &rhs);
+  virtual ~ClpObjective();
+  virtual ClpObjective *clone() const = 0;
+  virtual ClpObjective *subsetClone(int numberColumns,
+    const int *whichColumns) const;
+  inline int type() const
+  {
+    return type_;
+  }
+  inline void setType(int value)
+  {
+    type_ = value;
+  }
+  inline int activated() const
+  {
+    return activated_;
+  }
+  inline void setActivated(int value)
+  {
+    activated_ = value;
+  }
+  inline double nonlinearOffset() const
+  {
+    return offset_;
+  }
+protected:
+  double offset_;
+  int type_;
+  int activated_;
+};
+class ClpEventHandler;
+class CoinBuild;
+class CoinModel;
+class ClpModel {
+public:
+  ClpModel(bool emptyMessages = false);
+  ClpModel(const ClpModel &rhs, int scalingMode = -1);
+  ClpModel &operator=(const ClpModel &rhs);
+  ClpModel(const ClpModel *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true);
+  ~ClpModel();
+  void loadProblem(const ClpMatrixBase &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const CoinPackedMatrix &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  int loadProblem(CoinModel &modelObject, bool tryPlusMinusOne = false);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value, const int *length,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadQuadraticObjective(const int numberColumns,
+    const CoinBigIndex *start,
+    const int *column, const double *element);
+  void loadQuadraticObjective(const CoinPackedMatrix &matrix);
+  void deleteQuadraticObjective();
+  void setRowObjective(const double *rowObjective);
+  int readMps(const char *filename,
+    bool keepNames = false,
+    bool ignoreErrors = false);
+  int readGMPL(const char *filename, const char *dataName,
+    bool keepNames = false);
+  void copyInIntegerInformation(const char *information);
+  void deleteIntegerInformation();
+  void setContinuous(int index);
+  void setInteger(int index);
+  bool isInteger(int index) const;
+  void resize(int newNumberRows, int newNumberColumns);
+private:
+  void synchronizeMatrix();
+public:
+  void deleteRows(int number, const int *which);
+  void addRow(int numberInRow, const int *columns,
+    const double *elements, double rowLower = -COIN_DBL_MAX,
+    double rowUpper = COIN_DBL_MAX);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinBigIndex *rowStarts, const int *columns,
+    const double *elements);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinBigIndex *rowStarts, const int *rowLengths,
+    const int *columns,
+    const double *elements);
+  void addRows(int number, const double *rowLower,
+    const double *rowUpper,
+    const CoinPackedVectorBase *const *rows);
+  int addRows(const CoinBuild &buildObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  int addRows(CoinModel &modelObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  void deleteColumns(int number, const int *which);
+  void deleteRowsAndColumns(int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns);
+  void addColumn(int numberInColumn,
+    const int *rows,
+    const double *elements,
+    double columnLower = 0.0,
+    double columnUpper = COIN_DBL_MAX,
+    double objective = 0.0);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinBigIndex *columnStarts, const int *rows,
+    const double *elements);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinBigIndex *columnStarts, const int *columnLengths,
+    const int *rows,
+    const double *elements);
+  void addColumns(int number, const double *columnLower,
+    const double *columnUpper,
+    const double *objective,
+    const CoinPackedVectorBase *const *columns);
+  int addColumns(const CoinBuild &buildObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  int addColumns(CoinModel &modelObject, bool tryPlusMinusOne = false,
+    bool checkDuplicates = true);
+  inline void modifyCoefficient(int row, int column, double newElement,
+    bool keepZero = false)
+  {
+    matrix_->modifyCoefficient(row, column, newElement, keepZero);
+  }
+  void chgRowLower(const double *rowLower);
+  void chgRowUpper(const double *rowUpper);
+  void chgColumnLower(const double *columnLower);
+  void chgColumnUpper(const double *columnUpper);
+  void chgObjCoefficients(const double *objIn);
+  void borrowModel(ClpModel &otherModel);
+  void returnModel(ClpModel &otherModel);
+  void createEmptyMatrix();
+  CoinBigIndex cleanMatrix(double threshold = 1.0e-20);
+  void copy(const ClpMatrixBase *from, ClpMatrixBase *&to);
+  void dropNames();
+  void copyNames(const std::vector< std::string > &rowNames,
+    const std::vector< std::string > &columnNames);
+  void copyRowNames(const std::vector< std::string > &rowNames, int first, int last);
+  void copyColumnNames(const std::vector< std::string > &columnNames, int first, int last);
+  void copyRowNames(const char *const *rowNames, int first, int last);
+  void copyColumnNames(const char *const *columnNames, int first, int last);
+  void setRowName(int rowIndex, std::string &name);
+  void setColumnName(int colIndex, std::string &name);
+  int findNetwork(char *rotate, double fractionNeeded = 0.75);
+  CoinModel *createCoinModel() const;
+  int writeMps(const char *filename,
+    int formatType = 0, int numberAcross = 2,
+    double objSense = 0.0) const;
+  inline int numberRows() const
+  {
+    return numberRows_;
+  }
+  inline int getNumRows() const
+  {
+    return numberRows_;
+  }
+  inline int getNumCols() const
+  {
+    return numberColumns_;
+  }
+  inline int numberColumns() const
+  {
+    return numberColumns_;
+  }
+  inline double primalTolerance() const
+  {
+    return dblParam_[ClpPrimalTolerance];
+  }
+  void setPrimalTolerance(double value);
+  inline double dualTolerance() const
+  {
+    return dblParam_[ClpDualTolerance];
+  }
+  void setDualTolerance(double value);
+  inline double primalObjectiveLimit() const
+  {
+    return dblParam_[ClpPrimalObjectiveLimit];
+  }
+  void setPrimalObjectiveLimit(double value);
+  inline double dualObjectiveLimit() const
+  {
+    return dblParam_[ClpDualObjectiveLimit];
+  }
+  void setDualObjectiveLimit(double value);
+  inline double objectiveOffset() const
+  {
+    return dblParam_[ClpObjOffset];
+  }
+  void setObjectiveOffset(double value);
+  inline double presolveTolerance() const
+  {
+    return dblParam_[ClpPresolveTolerance];
+  }
+  inline const std::string &problemName() const
+  {
+    return strParam_[ClpProbName];
+  }
+  inline int numberIterations() const
+  {
+    return numberIterations_;
+  }
+  inline int getIterationCount() const
+  {
+    return numberIterations_;
+  }
+  inline void setNumberIterations(int numberIterationsNew)
+  {
+    numberIterations_ = numberIterationsNew;
+  }
+  inline int solveType() const
+  {
+    return solveType_;
+  }
+  inline void setSolveType(int type)
+  {
+    solveType_ = type;
+  }
+  inline int maximumIterations() const
+  {
+    return intParam_[ClpMaxNumIteration];
+  }
+  void setMaximumIterations(int value);
+  inline double maximumSeconds() const
+  {
+    return dblParam_[ClpMaxSeconds];
+  }
+  void setMaximumSeconds(double value);
+  void setMaximumWallSeconds(double value);
+  bool hitMaximumIterations() const;
+  inline int status() const
+  {
+    return problemStatus_;
+  }
+  inline int problemStatus() const
+  {
+    return problemStatus_;
+  }
+  inline void setProblemStatus(int problemStatusNew)
+  {
+    problemStatus_ = problemStatusNew;
+  }
+  inline int secondaryStatus() const
+  {
+    return secondaryStatus_;
+  }
+  inline void setSecondaryStatus(int newstatus)
+  {
+    secondaryStatus_ = newstatus;
+  }
+  inline bool isAbandoned() const
+  {
+    return problemStatus_ == 4;
+  }
+  inline bool isProvenOptimal() const
+  {
+    return problemStatus_ == 0;
+  }
+  inline bool isProvenPrimalInfeasible() const
+  {
+    return problemStatus_ == 1;
+  }
+  inline bool isProvenDualInfeasible() const
+  {
+    return problemStatus_ == 2;
+  }
+  bool isPrimalObjectiveLimitReached() const;
+  bool isDualObjectiveLimitReached() const;
+  inline bool isIterationLimitReached() const
+  {
+    return problemStatus_ == 3;
+  }
+  inline double optimizationDirection() const
+  {
+    return optimizationDirection_;
+  }
+  inline double getObjSense() const
+  {
+    return optimizationDirection_;
+  }
+  void setOptimizationDirection(double value);
+  inline double *primalRowSolution() const
+  {
+    return rowActivity_;
+  }
+  inline const double *getRowActivity() const
+  {
+    return rowActivity_;
+  }
+  inline double *primalColumnSolution() const
+  {
+    return columnActivity_;
+  }
+  inline const double *getColSolution() const
+  {
+    return columnActivity_;
+  }
+  inline void setColSolution(const double *input)
+  {
+    memcpy(columnActivity_, input, numberColumns_ * sizeof(double));
+  }
+  inline double *dualRowSolution() const
+  {
+    return dual_;
+  }
+  inline const double *getRowPrice() const
+  {
+    return dual_;
+  }
+  inline double *dualColumnSolution() const
+  {
+    return reducedCost_;
+  }
+  inline const double *getReducedCost() const
+  {
+    return reducedCost_;
+  }
+  inline double *rowLower() const
+  {
+    return rowLower_;
+  }
+  inline const double *getRowLower() const
+  {
+    return rowLower_;
+  }
+  inline double *rowUpper() const
+  {
+    return rowUpper_;
+  }
+  inline const double *getRowUpper() const
+  {
+    return rowUpper_;
+  }
+  void setObjectiveCoefficient(int elementIndex, double elementValue);
+  inline void setObjCoeff(int elementIndex, double elementValue)
+  {
+    setObjectiveCoefficient(elementIndex, elementValue);
+  }
+  void setColumnLower(int elementIndex, double elementValue);
+  void setColumnUpper(int elementIndex, double elementValue);
+  void setColumnBounds(int elementIndex,
+    double lower, double upper);
+  void setColumnSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline void setColLower(int elementIndex, double elementValue)
+  {
+    setColumnLower(elementIndex, elementValue);
+  }
+  inline void setColUpper(int elementIndex, double elementValue)
+  {
+    setColumnUpper(elementIndex, elementValue);
+  }
+  inline void setColBounds(int elementIndex,
+    double lower, double upper)
+  {
+    setColumnBounds(elementIndex, lower, upper);
+  }
+  inline void setColSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList)
+  {
+    setColumnSetBounds(indexFirst, indexLast, boundList);
+  }
+  void setRowLower(int elementIndex, double elementValue);
+  void setRowUpper(int elementIndex, double elementValue);
+  void setRowBounds(int elementIndex,
+    double lower, double upper);
+  void setRowSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline const double *rowScale() const
+  {
+    return rowScale_;
+  }
+  inline const double *columnScale() const
+  {
+    return columnScale_;
+  }
+  inline const double *inverseRowScale() const
+  {
+    return inverseRowScale_;
+  }
+  inline const double *inverseColumnScale() const
+  {
+    return inverseColumnScale_;
+  }
+  inline double *mutableRowScale() const
+  {
+    return rowScale_;
+  }
+  inline double *mutableColumnScale() const
+  {
+    return columnScale_;
+  }
+  inline double *mutableInverseRowScale() const
+  {
+    return inverseRowScale_;
+  }
+  inline double *mutableInverseColumnScale() const
+  {
+    return inverseColumnScale_;
+  }
+  inline double *swapRowScale(double *newScale)
+  {
+    double *oldScale = rowScale_;
+    rowScale_ = newScale;
+    return oldScale;
+  }
+  void setRowScale(double *scale);
+  void setColumnScale(double *scale);
+  inline double objectiveScale() const
+  {
+    return objectiveScale_;
+  }
+  inline void setObjectiveScale(double value)
+  {
+    objectiveScale_ = value;
+  }
+  inline double rhsScale() const
+  {
+    return rhsScale_;
+  }
+  inline void setRhsScale(double value)
+  {
+    rhsScale_ = value;
+  }
+  void scaling(int mode = 1);
+  void unscale();
+  inline int scalingFlag() const
+  {
+    return scalingFlag_;
+  }
+  inline double *objective() const
+  {
+    if (objective_) {
+      double offset;
+      return objective_->gradient(__null, __null, offset, false);
+    } else {
+      return __null;
+    }
+  }
+  inline double *objective(const double *solution, double &offset, bool refresh = true) const
+  {
+    offset = 0.0;
+    if (objective_) {
+      return objective_->gradient(__null, solution, offset, refresh);
+    } else {
+      return __null;
+    }
+  }
+  inline const double *getObjCoefficients() const
+  {
+    if (objective_) {
+      double offset;
+      return objective_->gradient(__null, __null, offset, false);
+    } else {
+      return __null;
+    }
+  }
+  inline double *rowObjective() const
+  {
+    return rowObjective_;
+  }
+  inline const double *getRowObjCoefficients() const
+  {
+    return rowObjective_;
+  }
+  inline double *columnLower() const
+  {
+    return columnLower_;
+  }
+  inline const double *getColLower() const
+  {
+    return columnLower_;
+  }
+  inline double *columnUpper() const
+  {
+    return columnUpper_;
+  }
+  inline const double *getColUpper() const
+  {
+    return columnUpper_;
+  }
+  inline CoinPackedMatrix *matrix() const
+  {
+    if (matrix_ == __null)
+      return __null;
+    else
+      return matrix_->getPackedMatrix();
+  }
+  inline CoinBigIndex getNumElements() const
+  {
+    return matrix_->getNumElements();
+  }
+  inline double getSmallElementValue() const
+  {
+    return smallElement_;
+  }
+  inline void setSmallElementValue(double value)
+  {
+    smallElement_ = value;
+  }
+  inline ClpMatrixBase *rowCopy() const
+  {
+    return rowCopy_;
+  }
+  void setNewRowCopy(ClpMatrixBase *newCopy);
+  inline ClpMatrixBase *clpMatrix() const
+  {
+    return matrix_;
+  }
+  inline ClpPackedMatrix *clpScaledMatrix() const
+  {
+    return scaledMatrix_;
+  }
+  inline void setClpScaledMatrix(ClpPackedMatrix *scaledMatrix)
+  {
+    delete scaledMatrix_;
+    scaledMatrix_ = scaledMatrix;
+  }
+  inline ClpPackedMatrix *swapScaledMatrix(ClpPackedMatrix *scaledMatrix)
+  {
+    ClpPackedMatrix *oldMatrix = scaledMatrix_;
+    scaledMatrix_ = scaledMatrix;
+    return oldMatrix;
+  }
+  void replaceMatrix(ClpMatrixBase *matrix, bool deleteCurrent = false);
+  inline void replaceMatrix(CoinPackedMatrix *newmatrix,
+    bool deleteCurrent = false)
+  {
+    replaceMatrix(new ClpPackedMatrix(newmatrix), deleteCurrent);
+  }
+  inline double objectiveValue() const
+  {
+    return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
+  }
+  inline void setObjectiveValue(double value)
+  {
+    objectiveValue_ = (value + dblParam_[ClpObjOffset]) / optimizationDirection_;
+  }
+  inline double getObjValue() const
+  {
+    return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
+  }
+  inline char *integerInformation() const
+  {
+    return integerType_;
+  }
+  double *infeasibilityRay(bool fullRay = false) const;
+  double *unboundedRay() const;
+  inline double *ray() const
+  {
+    return ray_;
+  }
+  inline bool rayExists() const
+  {
+    return (ray_ != __null);
+  }
+  inline void deleteRay()
+  {
+    delete[] ray_;
+    ray_ = __null;
+  }
+  inline const double *internalRay() const
+  {
+    return ray_;
+  }
+  inline bool statusExists() const
+  {
+    return (status_ != __null);
+  }
+  inline unsigned char *statusArray() const
+  {
+    return status_;
+  }
+  unsigned char *statusCopy() const;
+  void copyinStatus(const unsigned char *statusArray);
+  inline void setUserPointer(void *pointer)
+  {
+    userPointer_ = pointer;
+  }
+  inline void *getUserPointer() const
+  {
+    return userPointer_;
+  }
+  inline void setTrustedUserPointer(ClpTrustedData *pointer)
+  {
+    trustedUserPointer_ = pointer;
+  }
+  inline ClpTrustedData *getTrustedUserPointer() const
+  {
+    return trustedUserPointer_;
+  }
+  inline int whatsChanged() const
+  {
+    return whatsChanged_;
+  }
+  inline void setWhatsChanged(int value)
+  {
+    whatsChanged_ = value;
+  }
+  inline int numberThreads() const
+  {
+    return numberThreads_;
+  }
+  inline void setNumberThreads(int value)
+  {
+    numberThreads_ = value;
+  }
+  void passInMessageHandler(CoinMessageHandler *handler);
+  CoinMessageHandler *pushMessageHandler(CoinMessageHandler *handler,
+    bool &oldDefault);
+  void popMessageHandler(CoinMessageHandler *oldHandler, bool oldDefault);
+  void newLanguage(CoinMessages::Language language);
+  inline void setLanguage(CoinMessages::Language language)
+  {
+    newLanguage(language);
+  }
+  void setDefaultMessageHandler();
+  inline CoinMessageHandler *messageHandler() const
+  {
+    return handler_;
+  }
+  inline CoinMessages messages() const
+  {
+    return messages_;
+  }
+  inline CoinMessages *messagesPointer()
+  {
+    return &messages_;
+  }
+  inline CoinMessages coinMessages() const
+  {
+    return coinMessages_;
+  }
+  inline CoinMessages *coinMessagesPointer()
+  {
+    return &coinMessages_;
+  }
+  inline void setLogLevel(int value)
+  {
+    handler_->setLogLevel(value);
+  }
+  inline int logLevel() const
+  {
+    return handler_->logLevel();
+  }
+  inline bool defaultHandler() const
+  {
+    return defaultHandler_;
+  }
+  void passInEventHandler(const ClpEventHandler *eventHandler);
+  inline ClpEventHandler *eventHandler() const
+  {
+    return eventHandler_;
+  }
+  inline CoinThreadRandom *randomNumberGenerator()
+  {
+    return &randomNumberGenerator_;
+  }
+  inline CoinThreadRandom &mutableRandomNumberGenerator()
+  {
+    return randomNumberGenerator_;
+  }
+  inline void setRandomSeed(int value)
+  {
+    randomNumberGenerator_.setSeed(value);
+  }
+  inline int lengthNames() const
+  {
+    return lengthNames_;
+  }
+  inline void setLengthNames(int value)
+  {
+    lengthNames_ = value;
+  }
+  inline const std::vector< std::string > *rowNames() const
+  {
+    return &rowNames_;
+  }
+  inline const std::string &rowName(int iRow) const
+  {
+    return rowNames_[iRow];
+  }
+  std::string getRowName(int iRow) const;
+  inline const std::vector< std::string > *columnNames() const
+  {
+    return &columnNames_;
+  }
+  inline const std::string &columnName(int iColumn) const
+  {
+    return columnNames_[iColumn];
+  }
+  std::string getColumnName(int iColumn) const;
+  inline ClpObjective *objectiveAsObject() const
+  {
+    return objective_;
+  }
+  void setObjective(ClpObjective *objective);
+  inline void setObjectivePointer(ClpObjective *newobjective)
+  {
+    objective_ = newobjective;
+  }
+  int emptyProblem(int *infeasNumber = __null, double *infeasSum = __null, bool printMessage = true);
+  void times(double scalar,
+    const double *x, double *y) const;
+  void transposeTimes(double scalar,
+    const double *x, double *y) const;
+  bool setIntParam(ClpIntParam key, int value);
+  bool setDblParam(ClpDblParam key, double value);
+  bool setStrParam(ClpStrParam key, const std::string &value);
+  inline bool getIntParam(ClpIntParam key, int &value) const
+  {
+    if (key < ClpLastIntParam) {
+      value = intParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  inline bool getDblParam(ClpDblParam key, double &value) const
+  {
+    if (key < ClpLastDblParam) {
+      value = dblParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  inline bool getStrParam(ClpStrParam key, std::string &value) const
+  {
+    if (key < ClpLastStrParam) {
+      value = strParam_[key];
+      return true;
+    } else {
+      return false;
+    }
+  }
+  void generateCpp(FILE *fp);
+  inline unsigned int specialOptions() const
+  {
+    return specialOptions_;
+  }
+  void setSpecialOptions(unsigned int value);
+  inline bool inCbcBranchAndBound() const
+  {
+    return (specialOptions_ & 0x01000000) != 0;
+  }
+protected:
+  void gutsOfDelete(int type);
+  void gutsOfCopy(const ClpModel &rhs, int trueCopy = 1);
+  void getRowBound(int iRow, double &lower, double &upper) const;
+  void gutsOfLoadModel(int numberRows, int numberColumns,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void gutsOfScaling();
+  inline double rawObjectiveValue() const
+  {
+    return objectiveValue_;
+  }
+  inline bool permanentArrays() const
+  {
+    return (specialOptions_ & 65536) != 0;
+  }
+  void startPermanentArrays();
+  void stopPermanentArrays();
+  const char *const *rowNamesAsChar() const;
+  const char *const *columnNamesAsChar() const;
+  void deleteNamesAsChar(const char *const *names, int number) const;
+  void onStopped();
+protected:
+  double optimizationDirection_;
+  double dblParam_[ClpLastDblParam];
+  double objectiveValue_;
+  double smallElement_;
+  double objectiveScale_;
+  double rhsScale_;
+  int numberRows_;
+  int numberColumns_;
+  double *rowActivity_;
+  double *columnActivity_;
+  double *dual_;
+  double *reducedCost_;
+  double *rowLower_;
+  double *rowUpper_;
+  ClpObjective *objective_;
+  double *rowObjective_;
+  double *columnLower_;
+  double *columnUpper_;
+  ClpMatrixBase *matrix_;
+  ClpMatrixBase *rowCopy_;
+  ClpPackedMatrix *scaledMatrix_;
+  double *ray_;
+  double *rowScale_;
+  double *columnScale_;
+  double *inverseRowScale_;
+  double *inverseColumnScale_;
+  int scalingFlag_;
+  unsigned char *status_;
+  char *integerType_;
+  void *userPointer_;
+  ClpTrustedData *trustedUserPointer_;
+  int intParam_[ClpLastIntParam];
+  int numberIterations_;
+  int solveType_;
+  unsigned int whatsChanged_;
+  int problemStatus_;
+  int secondaryStatus_;
+  int lengthNames_;
+  int numberThreads_;
+  unsigned int specialOptions_;
+  CoinMessageHandler *handler_;
+  bool defaultHandler_;
+  CoinThreadRandom randomNumberGenerator_;
+  ClpEventHandler *eventHandler_;
+  std::vector< std::string > rowNames_;
+  std::vector< std::string > columnNames_;
+  CoinMessages messages_;
+  CoinMessages coinMessages_;
+  int maximumColumns_;
+  int maximumRows_;
+  int maximumInternalColumns_;
+  int maximumInternalRows_;
+  CoinPackedMatrix baseMatrix_;
+  CoinPackedMatrix baseRowCopy_;
+  double *savedRowScale_;
+  double *savedColumnScale_;
+  std::string strParam_[ClpLastStrParam];
+};
+class ClpDataSave {
+public:
+  ClpDataSave();
+  ClpDataSave(const ClpDataSave &);
+  ClpDataSave &operator=(const ClpDataSave &rhs);
+  ~ClpDataSave();
+public:
+  double dualBound_;
+  double infeasibilityCost_;
+  double pivotTolerance_;
+  double zeroFactorizationTolerance_;
+  double zeroSimplexTolerance_;
+  double acceptablePivot_;
+  double objectiveScale_;
+  int sparseThreshold_;
+  int perturbation_;
+  int forceFactorization_;
+  int scalingFlag_;
+  unsigned int specialOptions_;
+};
+
+class ClpSolve {
+public:
+  enum SolveType {
+    useDual = 0,
+    usePrimal,
+    usePrimalorSprint,
+    useBarrier,
+    useBarrierNoCross,
+    automatic,
+    tryDantzigWolfe,
+    tryBenders,
+    notImplemented
+  };
+  enum PresolveType {
+    presolveOn = 0,
+    presolveOff,
+    presolveNumber,
+    presolveNumberCost
+  };
+  ClpSolve();
+  ClpSolve(SolveType method, PresolveType presolveType,
+    int numberPasses, int options[6],
+    int extraInfo[6], int independentOptions[3]);
+  void generateCpp(FILE *fp);
+  ClpSolve(const ClpSolve &);
+  ClpSolve &operator=(const ClpSolve &rhs);
+  ~ClpSolve();
+  void setSpecialOption(int which, int value, int extraInfo = -1);
+  int getSpecialOption(int which) const;
+  void setSolveType(SolveType method, int extraInfo = -1);
+  SolveType getSolveType();
+  void setPresolveType(PresolveType amount, int extraInfo = -1);
+  PresolveType getPresolveType();
+  int getPresolvePasses() const;
+  int getExtraInfo(int which) const;
+  void setInfeasibleReturn(bool trueFalse);
+  inline bool infeasibleReturn() const
+  {
+    return independentOptions_[0] != 0;
+  }
+  inline bool doDual() const
+  {
+    return (independentOptions_[1] & 1) == 0;
+  }
+  inline void setDoDual(bool doDual_)
+  {
+    if (doDual_)
+      independentOptions_[1] &= ~1;
+    else
+      independentOptions_[1] |= 1;
+  }
+  inline bool doSingleton() const
+  {
+    return (independentOptions_[1] & 2) == 0;
+  }
+  inline void setDoSingleton(bool doSingleton_)
+  {
+    if (doSingleton_)
+      independentOptions_[1] &= ~2;
+    else
+      independentOptions_[1] |= 2;
+  }
+  inline bool doDoubleton() const
+  {
+    return (independentOptions_[1] & 4) == 0;
+  }
+  inline void setDoDoubleton(bool doDoubleton_)
+  {
+    if (doDoubleton_)
+      independentOptions_[1] &= ~4;
+    else
+      independentOptions_[1] |= 4;
+  }
+  inline bool doTripleton() const
+  {
+    return (independentOptions_[1] & 8) == 0;
+  }
+  inline void setDoTripleton(bool doTripleton_)
+  {
+    if (doTripleton_)
+      independentOptions_[1] &= ~8;
+    else
+      independentOptions_[1] |= 8;
+  }
+  inline bool doTighten() const
+  {
+    return (independentOptions_[1] & 16) == 0;
+  }
+  inline void setDoTighten(bool doTighten_)
+  {
+    if (doTighten_)
+      independentOptions_[1] &= ~16;
+    else
+      independentOptions_[1] |= 16;
+  }
+  inline bool doForcing() const
+  {
+    return (independentOptions_[1] & 32) == 0;
+  }
+  inline void setDoForcing(bool doForcing_)
+  {
+    if (doForcing_)
+      independentOptions_[1] &= ~32;
+    else
+      independentOptions_[1] |= 32;
+  }
+  inline bool doImpliedFree() const
+  {
+    return (independentOptions_[1] & 64) == 0;
+  }
+  inline void setDoImpliedFree(bool doImpliedfree)
+  {
+    if (doImpliedfree)
+      independentOptions_[1] &= ~64;
+    else
+      independentOptions_[1] |= 64;
+  }
+  inline bool doDupcol() const
+  {
+    return (independentOptions_[1] & 128) == 0;
+  }
+  inline void setDoDupcol(bool doDupcol_)
+  {
+    if (doDupcol_)
+      independentOptions_[1] &= ~128;
+    else
+      independentOptions_[1] |= 128;
+  }
+  inline bool doDuprow() const
+  {
+    return (independentOptions_[1] & 256) == 0;
+  }
+  inline void setDoDuprow(bool doDuprow_)
+  {
+    if (doDuprow_)
+      independentOptions_[1] &= ~256;
+    else
+      independentOptions_[1] |= 256;
+  }
+  inline bool doSingletonColumn() const
+  {
+    return (independentOptions_[1] & 512) == 0;
+  }
+  inline void setDoSingletonColumn(bool doSingleton_)
+  {
+    if (doSingleton_)
+      independentOptions_[1] &= ~512;
+    else
+      independentOptions_[1] |= 512;
+  }
+  inline bool doKillSmall() const
+  {
+    return (independentOptions_[1] & 8192) == 0;
+  }
+  inline void setDoKillSmall(bool doKill)
+  {
+    if (doKill)
+      independentOptions_[1] &= ~8192;
+    else
+      independentOptions_[1] |= 8192;
+  }
+  inline int presolveActions() const
+  {
+    return independentOptions_[1] & 0xffffff;
+  }
+  inline void setPresolveActions(int action)
+  {
+    independentOptions_[1] = (independentOptions_[1] & 0xff000000) | (action & 0xffffff);
+  }
+  inline int substitution() const
+  {
+    return independentOptions_[2];
+  }
+  inline void setSubstitution(int value)
+  {
+    independentOptions_[2] = value;
+  }
+  inline void setIndependentOption(int type, int value)
+  {
+    independentOptions_[type] = value;
+  }
+  inline int independentOption(int type) const
+  {
+    return independentOptions_[type];
+  }
+private:
+  SolveType method_;
+  PresolveType presolveType_;
+  int numberPasses_;
+  int options_[7];
+  int extraInfo_[7];
+  int independentOptions_[3];
+};
+class ClpSimplexProgress {
+public:
+  ClpSimplexProgress();
+  ClpSimplexProgress(ClpSimplex *model);
+  ClpSimplexProgress(const ClpSimplexProgress &);
+  ClpSimplexProgress &operator=(const ClpSimplexProgress &rhs);
+  ~ClpSimplexProgress();
+  void reset();
+  void fillFromModel(ClpSimplex *model);
+  int looping();
+  void startCheck();
+  int cycle(int in, int out, int wayIn, int wayOut);
+  double lastObjective(int back = 1) const;
+  void setInfeasibility(double value);
+  double lastInfeasibility(int back = 1) const;
+  int numberInfeasibilities(int back = 1) const;
+  void modifyObjective(double value);
+  int lastIterationNumber(int back = 1) const;
+  void clearIterationNumbers();
+  inline void newOddState()
+  {
+    oddState_ = -oddState_ - 1;
+  }
+  inline void endOddState()
+  {
+    oddState_ = abs(oddState_);
+  }
+  inline void clearOddState()
+  {
+    oddState_ = 0;
+  }
+  inline int oddState() const
+  {
+    return oddState_;
+  }
+  inline int badTimes() const
+  {
+    return numberBadTimes_;
+  }
+  inline void clearBadTimes()
+  {
+    numberBadTimes_ = 0;
+  }
+  inline int reallyBadTimes() const
+  {
+    return numberReallyBadTimes_;
+  }
+  inline void incrementReallyBadTimes()
+  {
+    numberReallyBadTimes_++;
+  }
+  inline int timesFlagged() const
+  {
+    return numberTimesFlagged_;
+  }
+  inline void clearTimesFlagged()
+  {
+    numberTimesFlagged_ = 0;
+  }
+  inline void incrementTimesFlagged()
+  {
+    numberTimesFlagged_++;
+  }
+  double objective_[5];
+  double infeasibility_[5];
+  double realInfeasibility_[5];
+  double initialWeight_;
+  int in_[12];
+  int out_[12];
+  char way_[12];
+  ClpSimplex *model_;
+  int numberInfeasibilities_[5];
+  int iterationNumber_[5];
+  int numberTimes_;
+  int numberBadTimes_;
+  int numberReallyBadTimes_;
+  int numberTimesFlagged_;
+  int oddState_;
+};
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+  template<typename _Tp, typename _CharT = char,
+           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
+    class istream_iterator
+    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
+    {
+    public:
+      typedef _CharT char_type;
+      typedef _Traits traits_type;
+      typedef basic_istream<_CharT, _Traits> istream_type;
+    private:
+      istream_type* _M_stream;
+      _Tp _M_value;
+      bool _M_ok;
+    public:
+      constexpr istream_iterator()
+      noexcept(is_nothrow_default_constructible<_Tp>::value)
+      : _M_stream(0), _M_value(), _M_ok(false) {}
+      istream_iterator(istream_type& __s)
+      : _M_stream(std::__addressof(__s)), _M_ok(true)
+      { _M_read(); }
+      istream_iterator(const istream_iterator& __obj)
+      noexcept(is_nothrow_copy_constructible<_Tp>::value)
+      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
+        _M_ok(__obj._M_ok)
+      { }
+      istream_iterator& operator=(const istream_iterator&) = default;
+      ~istream_iterator() = default;
+      const _Tp&
+      operator*() const noexcept
+      {
+                        ;
+ return _M_value;
+      }
+      const _Tp*
+      operator->() const noexcept
+      { return std::__addressof((operator*())); }
+      istream_iterator&
+      operator++()
+      {
+                        ;
+ _M_read();
+ return *this;
+      }
+      istream_iterator
+      operator++(int)
+      {
+                        ;
+ istream_iterator __tmp = *this;
+ _M_read();
+ return __tmp;
+      }
+    private:
+      bool
+      _M_equal(const istream_iterator& __x) const noexcept
+      {
+ return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
+      }
+      void
+      _M_read()
+      {
+        if (_M_stream && !(*_M_stream >> _M_value))
+          {
+            _M_stream = 0;
+            _M_ok = false;
+          }
+      }
+      friend bool
+      operator==(const istream_iterator& __x, const istream_iterator& __y)
+      noexcept
+      { return __x._M_equal(__y); }
+      friend bool
+      operator!=(const istream_iterator& __x, const istream_iterator& __y)
+      noexcept
+      { return !__x._M_equal(__y); }
+    };
+  template<typename _Tp, typename _CharT = char,
+           typename _Traits = char_traits<_CharT> >
+    class ostream_iterator
+    : public iterator<output_iterator_tag, void, void, void, void>
+    {
+    public:
+      typedef _CharT char_type;
+      typedef _Traits traits_type;
+      typedef basic_ostream<_CharT, _Traits> ostream_type;
+    private:
+      ostream_type* _M_stream;
+      const _CharT* _M_string;
+    public:
+      ostream_iterator(ostream_type& __s) noexcept
+      : _M_stream(std::__addressof(__s)), _M_string(0) {}
+      ostream_iterator(ostream_type& __s, const _CharT* __c) noexcept
+      : _M_stream(std::__addressof(__s)), _M_string(__c) { }
+      ostream_iterator(const ostream_iterator& __obj) noexcept
+      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }
+      ostream_iterator& operator=(const ostream_iterator&) = default;
+      ostream_iterator&
+      operator=(const _Tp& __value)
+      {
+                        ;
+ *_M_stream << __value;
+ if (_M_string)
+          *_M_stream << _M_string;
+ return *this;
+      }
+      ostream_iterator&
+      operator*() noexcept
+      { return *this; }
+      ostream_iterator&
+      operator++() noexcept
+      { return *this; }
+      ostream_iterator&
+      operator++(int) noexcept
+      { return *this; }
+    };
+#pragma GCC diagnostic pop
+}
+template < class ForwardIterator, class Distance >
+void coinDistance(ForwardIterator first, ForwardIterator last,
+  Distance &n)
+{
+  n = std::distance(first, last);
+}
+template < class ForwardIterator >
+size_t coinDistance(ForwardIterator first, ForwardIterator last)
+{
+  size_t retVal;
+  retVal = std::distance(first, last);
+  return retVal;
+}
+template < class S, class T >
+struct CoinPair {
+public:
+  S first;
+  T second;
+public:
+  CoinPair(const S &s, const T &t)
+    : first(s)
+    , second(t)
+  {
+  }
+};
+template < class S, class T >
+class CoinFirstLess_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return t1.first < t2.first;
+  }
+};
+template < class S, class T >
+class CoinFirstGreater_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return t1.first > t2.first;
+  }
+};
+template < class S, class T >
+class CoinFirstAbsLess_2 {
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs < t2Abs;
+  }
+};
+template < class S, class T >
+class CoinFirstAbsGreater_2 {
+public:
+  inline bool operator()(CoinPair< S, T > t1, CoinPair< S, T > t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs > t2Abs;
+  }
+};
+template < class S, class T, class V >
+class CoinExternalVectorFirstLess_2 {
+private:
+  CoinExternalVectorFirstLess_2();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return vec_[t1.first] < vec_[t2.first];
+  }
+  CoinExternalVectorFirstLess_2(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class V >
+class CoinExternalVectorFirstGreater_2 {
+private:
+  CoinExternalVectorFirstGreater_2();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinPair< S, T > &t1,
+    const CoinPair< S, T > &t2) const
+  {
+    return vec_[t1.first] > vec_[t2.first];
+  }
+  CoinExternalVectorFirstGreater_2(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class CoinCompare2 >
+void CoinSort_2(S *sfirst, S *slast, T *tfirst, const CoinCompare2 &pc)
+{
+  const size_t len = coinDistance(sfirst, slast);
+  if (len <= 1)
+    return;
+  typedef CoinPair< S, T > ST_pair;
+  ST_pair *x = static_cast< ST_pair * >(::operator new(len * sizeof(ST_pair)));
+  size_t i = 0;
+  S *scurrent = sfirst;
+  T *tcurrent = tfirst;
+  while (scurrent != slast) {
+    new (x + i++) ST_pair(*scurrent++, *tcurrent++);
+  }
+  std::sort(x, x + len, pc);
+  scurrent = sfirst;
+  tcurrent = tfirst;
+  for (i = 0; i < len; ++i) {
+    *scurrent++ = x[i].first;
+    *tcurrent++ = x[i].second;
+  }
+  ::operator delete(x);
+}
+template < class S, class T >
+void
+CoinSort_2Std(S *sfirst, S *slast, T *tfirst)
+{
+  CoinSort_2(sfirst, slast, tfirst, CoinFirstLess_2< S, T >());
+}
+template < class S, class T >
+void CoinSort_2(S *sfirst, S *slast, T *tfirst)
+{
+  CoinSort_2(sfirst, slast, tfirst, CoinFirstLess_2< S, T >());
+}
+template < class S, class T >
+void CoinShortSort_2(S *key, S *lastKey, T *array2)
+{
+  const size_t number = coinDistance(key, lastKey);
+  if (number <= 2) {
+    if (number == 2 && key[0] > key[1]) {
+      S tempS = key[0];
+      T tempT = array2[0];
+      key[0] = key[1];
+      array2[0] = array2[1];
+      key[1] = tempS;
+      array2[1] = tempT;
+    }
+    return;
+  } else if (number > 10000) {
+    CoinSort_2Std(key, lastKey, array2);
+    return;
+  }
+  int minsize = 10;
+  size_t n = number;
+  int sp;
+  S *v = key;
+  S *m, t;
+  S *ls[32], *rs[32];
+  S *l, *r, c;
+  T it;
+  size_t j;
+  S last = key[0];
+  for (j = 1; j < n; j++) {
+    if (key[j] >= last) {
+      last = key[j];
+    } else {
+      break;
+    }
+  }
+  if (j == n) {
+    return;
+  }
+  sp = 0;
+  ls[sp] = v;
+  rs[sp] = v + (n - 1);
+  while (sp >= 0) {
+    if (rs[sp] - ls[sp] > minsize) {
+      l = ls[sp];
+      r = rs[sp];
+      m = l + (r - l) / 2;
+      if (*l > *m) {
+        t = *l;
+        *l = *m;
+        *m = t;
+        it = array2[l - v];
+        array2[l - v] = array2[m - v];
+        array2[m - v] = it;
+      }
+      if (*m > *r) {
+        t = *m;
+        *m = *r;
+        *r = t;
+        it = array2[m - v];
+        array2[m - v] = array2[r - v];
+        array2[r - v] = it;
+        if (*l > *m) {
+          t = *l;
+          *l = *m;
+          *m = t;
+          it = array2[l - v];
+          array2[l - v] = array2[m - v];
+          array2[m - v] = it;
+        }
+      }
+      c = *m;
+      while (r - l > 1) {
+        while (*(++l) < c)
+          ;
+        while (*(--r) > c)
+          ;
+        t = *l;
+        *l = *r;
+        *r = t;
+        it = array2[l - v];
+        array2[l - v] = array2[r - v];
+        array2[r - v] = it;
+      }
+      l = r - 1;
+      if (l < m) {
+        ls[sp + 1] = ls[sp];
+        rs[sp + 1] = l;
+        ls[sp] = r;
+      } else {
+        ls[sp + 1] = r;
+        rs[sp + 1] = rs[sp];
+        rs[sp] = l;
+      }
+      sp++;
+    } else
+      sp--;
+  }
+  for (l = v, m = v + (n - 1); l < m; l++) {
+    if (*l > *(l + 1)) {
+      c = *(l + 1);
+      it = array2[(l - v) + 1];
+      for (r = l; r >= v && *r > c; r--) {
+        *(r + 1) = *r;
+        array2[(r - v) + 1] = array2[(r - v)];
+      }
+      *(r + 1) = c;
+      array2[(r - v) + 1] = it;
+    }
+  }
+}
+template < class S, class T, class U >
+class CoinTriple {
+public:
+  S first;
+  T second;
+  U third;
+public:
+  CoinTriple(const S &s, const T &t, const U &u)
+    : first(s)
+    , second(t)
+    , third(u)
+  {
+  }
+};
+template < class S, class T, class U >
+class CoinFirstLess_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return t1.first < t2.first;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstGreater_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return t1.first > t2.first;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstAbsLess_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs < t2Abs;
+  }
+};
+template < class S, class T, class U >
+class CoinFirstAbsGreater_3 {
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    const T t1Abs = t1.first < static_cast< T >(0) ? -t1.first : t1.first;
+    const T t2Abs = t2.first < static_cast< T >(0) ? -t2.first : t2.first;
+    return t1Abs > t2Abs;
+  }
+};
+template < class S, class T, class U, class V >
+class CoinExternalVectorFirstLess_3 {
+private:
+  CoinExternalVectorFirstLess_3();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return vec_[t1.first] < vec_[t2.first];
+  }
+  CoinExternalVectorFirstLess_3(const V *v)
+    : vec_(v)
+  {
+  }
+};
+template < class S, class T, class U, class V >
+class CoinExternalVectorFirstGreater_3 {
+private:
+  CoinExternalVectorFirstGreater_3();
+private:
+  const V *vec_;
+public:
+  inline bool operator()(const CoinTriple< S, T, U > &t1,
+    const CoinTriple< S, T, U > &t2) const
+  {
+    return vec_[t1.first] > vec_[t2.first];
+  }
+  CoinExternalVectorFirstGreater_3(const V *v)
+    : vec_(v)
+  {
+  }
+};
+typedef CoinExternalVectorFirstLess_3< int, int, double, double >
+  CoinIncrSolutionOrdered;
+typedef CoinExternalVectorFirstGreater_3< int, int, double, double >
+  CoinDecrSolutionOrdered;
+template < class S, class T, class U, class CoinCompare3 >
+void CoinSort_3(S *sfirst, S *slast, T *tfirst, U *ufirst, const CoinCompare3 &tc)
+{
+  const size_t len = coinDistance(sfirst, slast);
+  if (len <= 1)
+    return;
+  typedef CoinTriple< S, T, U > STU_triple;
+  STU_triple *x = static_cast< STU_triple * >(::operator new(len * sizeof(STU_triple)));
+  size_t i = 0;
+  S *scurrent = sfirst;
+  T *tcurrent = tfirst;
+  U *ucurrent = ufirst;
+  while (scurrent != slast) {
+    new (x + i++) STU_triple(*scurrent++, *tcurrent++, *ucurrent++);
+  }
+  std::sort(x, x + len, tc);
+  scurrent = sfirst;
+  tcurrent = tfirst;
+  ucurrent = ufirst;
+  for (i = 0; i < len; ++i) {
+    *scurrent++ = x[i].first;
+    *tcurrent++ = x[i].second;
+    *ucurrent++ = x[i].third;
+  }
+  ::operator delete(x);
+}
+template < class S, class T, class U >
+void CoinSort_3(S *sfirst, S *slast, T *tfirst, U *ufirst)
+{
+  CoinSort_3(sfirst, slast, tfirst, ufirst, CoinFirstLess_3< S, T, U >());
+}
+
+class CoinIndexedVector {
+  friend void CoinIndexedVectorUnitTest();
+public:
+  inline int getNumElements() const { return nElements_; }
+  inline const int *getIndices() const { return indices_; }
+  inline int *getIndices() { return indices_; }
+  inline double *denseVector() const { return elements_; }
+  inline void setDenseVector(double *array)
+  {
+    elements_ = array;
+  }
+  inline void setIndexVector(int *array)
+  {
+    indices_ = array;
+  }
+  double &operator[](int i) const;
+  inline void setNumElements(int value)
+  {
+    nElements_ = value;
+    if (!nElements_)
+      packedMode_ = false;
+  }
+  void clear();
+  void empty();
+  void reallyClear();
+  CoinIndexedVector &operator=(const CoinIndexedVector &);
+  CoinIndexedVector &operator=(const CoinPackedVectorBase &rhs);
+  void copy(const CoinIndexedVector &rhs, double multiplier = 1.0);
+  void borrowVector(int size, int numberIndices, int *inds, double *elems);
+  void returnVector();
+  void setVector(int numberIndices, const int *inds, const double *elems);
+  void setVector(int size, int numberIndices, const int *inds, const double *elems);
+  void setConstant(int size, const int *inds, double elems);
+  void setFull(int size, const double *elems);
+  void setElement(int index, double element);
+  void insert(int index, double element);
+  inline void quickInsert(int index, double element)
+  {
+    (static_cast<void> (0));
+    indices_[nElements_++] = index;
+    (static_cast<void> (0));
+    elements_[index] = element;
+  }
+  void add(int index, double element);
+  inline void quickAdd(int index, double element)
+  {
+    if (elements_[index]) {
+      element += elements_[index];
+      if ((element > 0 ? element : -element) >= 1.0e-50) {
+        elements_[index] = element;
+      } else {
+        elements_[index] = 1.0e-100;
+      }
+    } else if ((element > 0 ? element : -element) >= 1.0e-50) {
+      indices_[nElements_++] = index;
+      (static_cast<void> (0));
+      elements_[index] = element;
+    }
+  }
+  inline void quickAddNonZero(int index, double element)
+  {
+    (static_cast<void> (0));
+    if (elements_[index]) {
+      element += elements_[index];
+      if ((element > 0 ? element : -element) >= 1.0e-50) {
+        elements_[index] = element;
+      } else {
+        elements_[index] = COIN_DBL_MIN;
+      }
+    } else {
+      indices_[nElements_++] = index;
+      (static_cast<void> (0));
+      elements_[index] = element;
+    }
+  }
+  inline void zero(int index)
+  {
+    if (elements_[index])
+      elements_[index] = COIN_DBL_MIN;
+  }
+  int clean(double tolerance);
+  int cleanAndPack(double tolerance);
+  int cleanAndPackSafe(double tolerance);
+  inline void setPacked()
+  {
+    packedMode_ = true;
+  }
+  inline void checkClear() {};
+  inline void checkClean() {};
+  int scan();
+  int scan(int start, int end);
+  int scan(double tolerance);
+  int scan(int start, int end, double tolerance);
+  int scanAndPack();
+  int scanAndPack(int start, int end);
+  int scanAndPack(double tolerance);
+  int scanAndPack(int start, int end, double tolerance);
+  void createPacked(int number, const int *indices,
+    const double *elements);
+  void createUnpacked(int number, const int *indices,
+    const double *elements);
+  void createOneUnpackedElement(int index, double element);
+  void expand();
+  void append(const CoinPackedVectorBase &caboose);
+  void append(const CoinIndexedVector &caboose);
+  void append(CoinIndexedVector &other, int adjustIndex, bool zapElements = false);
+  void swap(int i, int j);
+  void truncate(int newSize);
+  void print() const;
+  void operator+=(double value);
+  void operator-=(double value);
+  void operator*=(double value);
+  void operator/=(double value);
+  bool operator==(const CoinPackedVectorBase &rhs) const;
+  bool operator!=(const CoinPackedVectorBase &rhs) const;
+  bool operator==(const CoinIndexedVector &rhs) const;
+  bool operator!=(const CoinIndexedVector &rhs) const;
+  int isApproximatelyEqual(const CoinIndexedVector &rhs, double tolerance = 1.0e-8) const;
+  int getMaxIndex() const;
+  int getMinIndex() const;
+  void sort()
+  {
+    std::sort(indices_, indices_ + nElements_);
+  }
+  void sortIncrIndex()
+  {
+    std::sort(indices_, indices_ + nElements_);
+  }
+  void sortDecrIndex();
+  void sortIncrElement();
+  void sortDecrElement();
+  void sortPacked();
+  CoinIndexedVector operator+(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator-(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator*(
+    const CoinIndexedVector &op2);
+  CoinIndexedVector operator/(
+    const CoinIndexedVector &op2);
+  void operator+=(const CoinIndexedVector &op2);
+  void operator-=(const CoinIndexedVector &op2);
+  void operator*=(const CoinIndexedVector &op2);
+  void operator/=(const CoinIndexedVector &op2);
+  void reserve(int n);
+  inline int capacity() const { return capacity_; }
+  inline void setCapacity(int value)
+  {
+    capacity_ = value;
+  }
+  inline void setPackedMode(bool yesNo)
+  {
+    packedMode_ = yesNo;
+  }
+  inline bool packedMode() const
+  {
+    return packedMode_;
+  }
+  CoinIndexedVector();
+  CoinIndexedVector(int size, const int *inds, const double *elems);
+  CoinIndexedVector(int size, const int *inds, double element);
+  CoinIndexedVector(int size, const double *elements);
+  CoinIndexedVector(int size);
+  CoinIndexedVector(const CoinIndexedVector &);
+  CoinIndexedVector(const CoinIndexedVector *);
+  CoinIndexedVector(const CoinPackedVectorBase &rhs);
+  ~CoinIndexedVector();
+private:
+  void gutsOfSetVector(int size,
+    const int *inds, const double *elems);
+  void gutsOfSetVector(int size, int numberIndices,
+    const int *inds, const double *elems);
+  void gutsOfSetPackedVector(int size, int numberIndices,
+    const int *inds, const double *elems);
+  void gutsOfSetConstant(int size,
+    const int *inds, double value);
+protected:
+  int *indices_;
+  double *elements_;
+  int nElements_;
+  int capacity_;
+  int offset_;
+  bool packedMode_;
+};
+void CoinIndexedVectorUnitTest();
+class CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return static_cast< CoinBigIndex >(size_);
+  }
+  inline CoinBigIndex rawSize() const
+  {
+    return static_cast< CoinBigIndex >(size_);
+  }
+  inline bool switchedOn() const
+  {
+    return size_ != -1;
+  }
+  inline CoinBigIndex capacity() const
+  {
+    return (size_ > -2) ? static_cast< CoinBigIndex >(size_) : static_cast< CoinBigIndex >((-size_) - 2);
+  }
+  inline void setCapacity()
+  {
+    if (size_ <= -2)
+      size_ = (-size_) - 2;
+  }
+  inline const char *array() const
+  {
+    return (size_ > -2) ? array_ : __null;
+  }
+  inline void setSize(int value)
+  {
+    size_ = value;
+  }
+  inline void switchOff()
+  {
+    size_ = -1;
+  }
+  inline void switchOn(int alignment = 3)
+  {
+    size_ = -2;
+    alignment_ = alignment;
+  }
+  void setPersistence(int flag, int currentLength);
+  void clear();
+  void swap(CoinArrayWithLength &other);
+  void extend(int newSize);
+  char *conditionalNew(CoinBigIndex sizeWanted);
+  void conditionalDelete();
+  inline CoinArrayWithLength()
+    : array_(__null)
+    , size_(-1)
+    , offset_(0)
+    , alignment_(0)
+  {
+  }
+  inline CoinArrayWithLength(CoinBigIndex size)
+    : size_(-1)
+    , offset_(0)
+    , alignment_(0)
+  {
+    array_ = new char[size];
+  }
+  CoinArrayWithLength(CoinBigIndex size, int mode);
+  CoinArrayWithLength(const CoinArrayWithLength &rhs);
+  CoinArrayWithLength(const CoinArrayWithLength *rhs);
+  CoinArrayWithLength &operator=(const CoinArrayWithLength &rhs);
+  void copy(const CoinArrayWithLength &rhs, int numberBytes = -1);
+  void allocate(const CoinArrayWithLength &rhs, CoinBigIndex numberBytes);
+  ~CoinArrayWithLength();
+  void getArray(CoinBigIndex size);
+  void reallyFreeArray();
+  void getCapacity(CoinBigIndex numberBytes, CoinBigIndex numberIfNeeded = -1);
+protected:
+  char *array_;
+  CoinBigIndex size_;
+  int offset_;
+  int alignment_;
+};
+class CoinDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(double)));
+  }
+  inline double *array() const
+  {
+    return reinterpret_cast< double * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(double)));
+  }
+  inline double *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< double * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(double)))) : -1));
+  }
+  inline CoinDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(double)))];
+    size_ = -1;
+  }
+  inline CoinDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(double))), mode)
+  {
+  }
+  inline CoinDoubleArrayWithLength(const CoinDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinDoubleArrayWithLength(const CoinDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinDoubleArrayWithLength &operator=(const CoinDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinFactorizationDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(CoinFactorizationDouble)));
+  }
+  inline CoinFactorizationDouble *array() const
+  {
+    return reinterpret_cast< CoinFactorizationDouble * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(CoinFactorizationDouble)));
+  }
+  inline CoinFactorizationDouble *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< CoinFactorizationDouble * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(CoinFactorizationDouble)))) : -1));
+  }
+  inline CoinFactorizationDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinFactorizationDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(CoinFactorizationDouble)))];
+    size_ = -1;
+  }
+  inline CoinFactorizationDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(CoinFactorizationDouble))), mode)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength(const CoinFactorizationDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength(const CoinFactorizationDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationDoubleArrayWithLength &operator=(const CoinFactorizationDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinFactorizationLongDoubleArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(long double)));
+  }
+  inline long double *array() const
+  {
+    return reinterpret_cast< long double * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(long double)));
+  }
+  inline long double *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< long double * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(long double)))) : -1));
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(long double)))];
+    size_ = -1;
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(long double))), mode)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(const CoinFactorizationLongDoubleArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength(const CoinFactorizationLongDoubleArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinFactorizationLongDoubleArrayWithLength &operator=(const CoinFactorizationLongDoubleArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinIntArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(int)));
+  }
+  inline int *array() const
+  {
+    return reinterpret_cast< int * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(int)));
+  }
+  inline int *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< int * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(int)))) : -1));
+  }
+  inline CoinIntArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinIntArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(int)))];
+    size_ = -1;
+  }
+  inline CoinIntArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(int))), mode)
+  {
+  }
+  inline CoinIntArrayWithLength(const CoinIntArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinIntArrayWithLength(const CoinIntArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinIntArrayWithLength &operator=(const CoinIntArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinBigIndexArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(CoinBigIndex)));
+  }
+  inline CoinBigIndex *array() const
+  {
+    return reinterpret_cast< CoinBigIndex * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(CoinBigIndex value)
+  {
+    size_ = value * (static_cast< int >(sizeof(CoinBigIndex)));
+  }
+  inline CoinBigIndex *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< CoinBigIndex * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(CoinBigIndex)))) : -1));
+  }
+  inline CoinBigIndexArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinBigIndexArrayWithLength(CoinBigIndex size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(CoinBigIndex)))];
+    size_ = -1;
+  }
+  inline CoinBigIndexArrayWithLength(CoinBigIndex size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(CoinBigIndex))), mode)
+  {
+  }
+  inline CoinBigIndexArrayWithLength(const CoinBigIndexArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinBigIndexArrayWithLength(const CoinBigIndexArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinBigIndexArrayWithLength &operator=(const CoinBigIndexArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinUnsignedIntArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(unsigned int)));
+  }
+  inline unsigned int *array() const
+  {
+    return reinterpret_cast< unsigned int * >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(unsigned int)));
+  }
+  inline unsigned int *conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< unsigned int * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(unsigned int)))) : -1));
+  }
+  inline CoinUnsignedIntArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinUnsignedIntArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(unsigned int)))];
+    size_ = -1;
+  }
+  inline CoinUnsignedIntArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(unsigned int))), mode)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength(const CoinUnsignedIntArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength(const CoinUnsignedIntArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinUnsignedIntArrayWithLength &operator=(const CoinUnsignedIntArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinVoidStarArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / (static_cast< int >(sizeof(void *)));
+  }
+  inline void **array() const
+  {
+    return reinterpret_cast< void ** >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * (static_cast< int >(sizeof(void *)));
+  }
+  inline void **conditionalNew(CoinBigIndex sizeWanted)
+  {
+    return reinterpret_cast< void ** >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*(static_cast< int >(sizeof(void *)))) : -1));
+  }
+  inline CoinVoidStarArrayWithLength()
+  {
+    array_ = __null;
+    size_ = -1;
+  }
+  inline CoinVoidStarArrayWithLength(int size)
+  {
+    array_ = new char[size * (static_cast< int >(sizeof(void *)))];
+    size_ = -1;
+  }
+  inline CoinVoidStarArrayWithLength(int size, int mode)
+    : CoinArrayWithLength(size * (static_cast< int >(sizeof(void *))), mode)
+  {
+  }
+  inline CoinVoidStarArrayWithLength(const CoinVoidStarArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinVoidStarArrayWithLength(const CoinVoidStarArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinVoidStarArrayWithLength &operator=(const CoinVoidStarArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+};
+class CoinArbitraryArrayWithLength : public CoinArrayWithLength {
+public:
+  inline CoinBigIndex getSize() const
+  {
+    return size_ / lengthInBytes_;
+  }
+  inline void **array() const
+  {
+    return reinterpret_cast< void ** >((size_ > -2) ? array_ : __null);
+  }
+  inline void setSize(int value)
+  {
+    size_ = value * lengthInBytes_;
+  }
+  inline char *conditionalNew(CoinBigIndex length, CoinBigIndex sizeWanted)
+  {
+    lengthInBytes_ = length;
+    return reinterpret_cast< char * >(CoinArrayWithLength::conditionalNew(sizeWanted >= 0 ? static_cast< long long >((sizeWanted)*lengthInBytes_) : -1));
+  }
+  inline CoinArbitraryArrayWithLength(int length = 1)
+  {
+    array_ = __null;
+    size_ = -1;
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(int length, int size)
+  {
+    array_ = new char[size * length];
+    size_ = -1;
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(int length, int size, int mode)
+    : CoinArrayWithLength(size * length, mode)
+  {
+    lengthInBytes_ = length;
+  }
+  inline CoinArbitraryArrayWithLength(const CoinArbitraryArrayWithLength &rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinArbitraryArrayWithLength(const CoinArbitraryArrayWithLength *rhs)
+    : CoinArrayWithLength(rhs)
+  {
+  }
+  inline CoinArbitraryArrayWithLength &operator=(const CoinArbitraryArrayWithLength &rhs)
+  {
+    CoinArrayWithLength::operator=(rhs);
+    return *this;
+  }
+protected:
+  CoinBigIndex lengthInBytes_;
+};
+class CoinPartitionedVector : public CoinIndexedVector {
+public:
+  inline int getNumElements(int partition) const
+  {
+    (static_cast<void> (0));
+    return numberElementsPartition_[partition];
+  }
+  inline int getNumPartitions() const
+  {
+    return numberPartitions_;
+  }
+  inline int getNumElements() const { return nElements_; }
+  inline int startPartition(int partition) const
+  {
+    (static_cast<void> (0));
+    return startPartition_[partition];
+  }
+  inline const int *startPartitions() const
+  {
+    return startPartition_;
+  }
+  inline void setNumElementsPartition(int partition, int value)
+  {
+    (static_cast<void> (0));
+    if (numberPartitions_)
+      numberElementsPartition_[partition] = value;
+  }
+  inline void setTempNumElementsPartition(int partition, int value)
+  {
+    (static_cast<void> (0));
+    numberElementsPartition_[partition] = value;
+  }
+  void computeNumberElements();
+  void compact();
+  void reserve(int n);
+  void setPartitions(int number, const int *starts);
+  void clearAndReset();
+  void clearAndKeep();
+  void clearPartition(int partition);
+  inline void checkClear() {};
+  inline void checkClean() {};
+  int scan(int partition, double tolerance = 0.0);
+  void print() const;
+  void sort();
+  CoinPartitionedVector();
+  CoinPartitionedVector(int size, const int *inds, const double *elems);
+  CoinPartitionedVector(int size, const int *inds, double element);
+  CoinPartitionedVector(int size, const double *elements);
+  CoinPartitionedVector(int size);
+  CoinPartitionedVector(const CoinPartitionedVector &);
+  CoinPartitionedVector(const CoinPartitionedVector *);
+  CoinPartitionedVector &operator=(const CoinPartitionedVector &);
+  ~CoinPartitionedVector();
+protected:
+  int startPartition_[8 + 1];
+  int numberElementsPartition_[8];
+  int numberPartitions_;
+};
+inline double *roundUpDouble(double *address)
+{
+  int64_t xx = reinterpret_cast< int64_t >(address);
+  int iBottom = static_cast< int >(xx & 63);
+  if (iBottom)
+    return address + ((64 - iBottom) >> 3);
+  else
+    return address;
+}
+class ClpDualRowPivot;
+class ClpPrimalColumnPivot;
+class ClpFactorization;
+class CoinFactorization;
+class CoinIndexedVector;
+class ClpNonLinearCost;
+class ClpNodeStuff;
+class CoinStructuredModel;
+class OsiClpSolverInterface;
+class CoinWarmStartBasis;
+class ClpDisasterHandler;
+class ClpConstraint;
+class ClpSimplex : public ClpModel {
+  friend void ClpSimplexUnitTest(const std::string &mpsDir);
+public:
+  enum Status {
+    isFree = 0x00,
+    basic = 0x01,
+    atUpperBound = 0x02,
+    atLowerBound = 0x03,
+    superBasic = 0x04,
+    isFixed = 0x05
+  };
+  enum FakeBound {
+    noFake = 0x00,
+    lowerFake = 0x01,
+    upperFake = 0x02,
+    bothFake = 0x03
+  };
+  ClpSimplex(bool emptyMessages = false);
+  ClpSimplex(const ClpSimplex &rhs, int scalingMode = -1);
+  ClpSimplex(const ClpModel &rhs, int scalingMode = -1);
+  ClpSimplex(const ClpModel *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true,
+    bool fixOthers = false);
+  ClpSimplex(const ClpSimplex *wholeModel,
+    int numberRows, const int *whichRows,
+    int numberColumns, const int *whichColumns,
+    bool dropNames = true, bool dropIntegers = true,
+    bool fixOthers = false);
+  ClpSimplex(ClpSimplex *wholeModel,
+    int numberColumns, const int *whichColumns);
+  void originalModel(ClpSimplex *miniModel);
+  void setPersistenceFlag(int value);
+  void makeBaseModel();
+  void deleteBaseModel();
+  inline ClpSimplex *baseModel() const
+  {
+    return baseModel_;
+  }
+  void setToBaseModel(ClpSimplex *model = __null);
+  ClpSimplex &operator=(const ClpSimplex &rhs);
+  ~ClpSimplex();
+  void loadProblem(const ClpMatrixBase &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const CoinPackedMatrix &matrix,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  void loadProblem(const int numcols, const int numrows,
+    const CoinBigIndex *start, const int *index,
+    const double *value, const int *length,
+    const double *collb, const double *colub,
+    const double *obj,
+    const double *rowlb, const double *rowub,
+    const double *rowObjective = __null);
+  int loadProblem(CoinModel &modelObject, bool keepSolution = false);
+  int readMps(const char *filename,
+    bool keepNames = false,
+    bool ignoreErrors = false);
+  int readGMPL(const char *filename, const char *dataName,
+    bool keepNames = false);
+  int readLp(const char *filename, const double epsilon = 1e-5);
+  void writeLp(const char *filename,
+    const char *extension = "lp",
+    double epsilon = 1e-5,
+    int numberAcross = 10,
+    int decimals = 5,
+    double objSense = 0.0,
+    bool useRowNames = true) const;
+  void borrowModel(ClpModel &otherModel);
+  void borrowModel(ClpSimplex &otherModel);
+  void passInEventHandler(const ClpEventHandler *eventHandler);
+  void getbackSolution(const ClpSimplex &smallModel, const int *whichRow, const int *whichColumn);
+  int loadNonLinear(void *info, int &numberConstraints,
+    ClpConstraint **&constraints);
+  int initialSolve(ClpSolve &options);
+  int initialSolve();
+  int initialDualSolve();
+  int initialPrimalSolve();
+  int initialBarrierSolve();
+  int initialBarrierNoCrossSolve();
+  int dual(int ifValuesPass = 0, int startFinishOptions = 0);
+  int dualDebug(int ifValuesPass = 0, int startFinishOptions = 0);
+  int primal(int ifValuesPass = 0, int startFinishOptions = 0);
+  int nonlinearSLP(int numberPasses, double deltaTolerance);
+  int nonlinearSLP(int numberConstraints, ClpConstraint **constraints,
+    int numberPasses, double deltaTolerance);
+  int barrier(bool crossover = true);
+  int reducedGradient(int phase = 0);
+  int solve(CoinStructuredModel *model);
+  int loadProblem(CoinStructuredModel &modelObject,
+    bool originalOrder = true, bool keepSolution = false);
+  int cleanup(int cleanupScaling);
+  int cleanPrimalSolution(double exactMultiple);
+  int dualRanging(int numberCheck, const int *which,
+    double *costIncrease, int *sequenceIncrease,
+    double *costDecrease, int *sequenceDecrease,
+    double *valueIncrease = __null, double *valueDecrease = __null);
+  int primalRanging(int numberCheck, const int *which,
+    double *valueIncrease, int *sequenceIncrease,
+    double *valueDecrease, int *sequenceDecrease);
+  int modifyCoefficientsAndPivot(int number,
+    const int *which,
+    const CoinBigIndex *start,
+    const int *row,
+    const double *newCoefficient,
+    const unsigned char *newStatus = __null,
+    const double *newLower = __null,
+    const double *newUpper = __null,
+    const double *newObjective = __null);
+  int outDuplicateRows(int numberLook, int *whichRows, bool noOverlaps = false, double tolerance = -1.0,
+    double cleanUp = 0.0);
+  double moveTowardsPrimalFeasible();
+  void removeSuperBasicSlacks(int threshold = 0);
+  ClpSimplex *miniPresolve(char *rowType, char *columnType, void **info);
+  void miniPostsolve(const ClpSimplex *presolvedModel, void *info);
+  void miniSolve(char *rowType, char *columnType, int algorithm, int startUp);
+  int writeBasis(const char *filename,
+    bool writeValues = false,
+    int formatType = 0) const;
+  int readBasis(const char *filename);
+  CoinWarmStartBasis *getBasis() const;
+  void setFactorization(ClpFactorization &factorization);
+  ClpFactorization *swapFactorization(ClpFactorization *factorization);
+  void copyFactorization(ClpFactorization &factorization);
+  int tightenPrimalBounds(double factor = 0.0, int doTight = 0, bool tightIntegers = false);
+  int crash(double gap, int pivot);
+  void setDualRowPivotAlgorithm(ClpDualRowPivot &choice);
+  void setPrimalColumnPivotAlgorithm(ClpPrimalColumnPivot &choice);
+  void markHotStart(void *&saveStuff);
+  void solveFromHotStart(void *saveStuff);
+  void unmarkHotStart(void *saveStuff);
+  int strongBranching(int numberVariables, const int *variables,
+    double *newLower, double *newUpper,
+    double **outputSolution,
+    int *outputStatus, int *outputIterations,
+    bool stopOnFirstInfeasible = true,
+    bool alwaysFinish = false,
+    int startFinishOptions = 0);
+  int fathom(void *stuff);
+  int fathomMany(void *stuff);
+  double doubleCheck();
+  int startFastDual2(ClpNodeStuff *stuff);
+  int fastDual2(ClpNodeStuff *stuff);
+  void stopFastDual2(ClpNodeStuff *stuff);
+  ClpSimplex *fastCrunch(ClpNodeStuff *stuff, int mode);
+  int pivot();
+  int primalPivotResult();
+  int dualPivotResultPart1();
+  int pivotResultPart2(int algorithm, int state);
+  int startup(int ifValuesPass, int startFinishOptions = 0);
+  void finish(int startFinishOptions = 0);
+  bool statusOfProblem(bool initial = false);
+  void defaultFactorizationFrequency();
+  void copyEnabledStuff(const ClpSimplex *rhs);
+  inline bool primalFeasible() const
+  {
+    return (numberPrimalInfeasibilities_ == 0);
+  }
+  inline bool dualFeasible() const
+  {
+    return (numberDualInfeasibilities_ == 0);
+  }
+  inline ClpFactorization *factorization() const
+  {
+    return factorization_;
+  }
+  bool sparseFactorization() const;
+  void setSparseFactorization(bool value);
+  int factorizationFrequency() const;
+  void setFactorizationFrequency(int value);
+  inline double dualBound() const
+  {
+    return dualBound_;
+  }
+  void setDualBound(double value);
+  inline double infeasibilityCost() const
+  {
+    return infeasibilityCost_;
+  }
+  void setInfeasibilityCost(double value);
+  inline int perturbation() const
+  {
+    return perturbation_;
+  }
+  void setPerturbation(int value);
+  inline int algorithm() const
+  {
+    return algorithm_;
+  }
+  inline void setAlgorithm(int value)
+  {
+    algorithm_ = value;
+  }
+  bool isObjectiveLimitTestValid() const;
+  inline double sumDualInfeasibilities() const
+  {
+    return sumDualInfeasibilities_;
+  }
+  inline void setSumDualInfeasibilities(double value)
+  {
+    sumDualInfeasibilities_ = value;
+  }
+  inline double sumOfRelaxedDualInfeasibilities() const
+  {
+    return sumOfRelaxedDualInfeasibilities_;
+  }
+  inline void setSumOfRelaxedDualInfeasibilities(double value)
+  {
+    sumOfRelaxedDualInfeasibilities_ = value;
+  }
+  inline int numberDualInfeasibilities() const
+  {
+    return numberDualInfeasibilities_;
+  }
+  inline void setNumberDualInfeasibilities(int value)
+  {
+    numberDualInfeasibilities_ = value;
+  }
+  inline int numberDualInfeasibilitiesWithoutFree() const
+  {
+    return numberDualInfeasibilitiesWithoutFree_;
+  }
+  inline double sumPrimalInfeasibilities() const
+  {
+    return sumPrimalInfeasibilities_;
+  }
+  inline void setSumPrimalInfeasibilities(double value)
+  {
+    sumPrimalInfeasibilities_ = value;
+  }
+  inline double sumOfRelaxedPrimalInfeasibilities() const
+  {
+    return sumOfRelaxedPrimalInfeasibilities_;
+  }
+  inline void setSumOfRelaxedPrimalInfeasibilities(double value)
+  {
+    sumOfRelaxedPrimalInfeasibilities_ = value;
+  }
+  inline int numberPrimalInfeasibilities() const
+  {
+    return numberPrimalInfeasibilities_;
+  }
+  inline void setNumberPrimalInfeasibilities(int value)
+  {
+    numberPrimalInfeasibilities_ = value;
+  }
+  int saveModel(const char *fileName);
+  int restoreModel(const char *fileName);
+  void checkSolution(int setToBounds = 0);
+  void checkSolutionInternal();
+  void checkUnscaledSolution();
+  inline CoinIndexedVector *rowArray(int index) const
+  {
+    return rowArray_[index];
+  }
+  inline CoinIndexedVector *columnArray(int index) const
+  {
+    return columnArray_[index];
+  }
+  int getSolution(const double *rowActivities,
+    const double *columnActivities);
+  int getSolution();
+  int createPiecewiseLinearCosts(const int *starts,
+    const double *lower, const double *gradient);
+  inline ClpDualRowPivot *dualRowPivot() const
+  {
+    return dualRowPivot_;
+  }
+  inline ClpPrimalColumnPivot *primalColumnPivot() const
+  {
+    return primalColumnPivot_;
+  }
+  inline bool goodAccuracy() const
+  {
+    return (largestPrimalError_ < 1.0e-7 && largestDualError_ < 1.0e-7);
+  }
+  void returnModel(ClpSimplex &otherModel);
+  int internalFactorize(int solveType);
+  ClpDataSave saveData();
+  void restoreData(ClpDataSave saved);
+  void cleanStatus();
+  int factorize();
+  void computeDuals(double *givenDjs);
+  void computePrimals(const double *rowActivities,
+    const double *columnActivities);
+  void add(double *array,
+    int column, double multiplier) const;
+  void unpack(CoinIndexedVector *rowArray) const;
+  void unpack(CoinIndexedVector *rowArray, int sequence) const;
+  void unpackPacked(CoinIndexedVector *rowArray);
+  void unpackPacked(CoinIndexedVector *rowArray, int sequence);
+protected:
+  int housekeeping(double objectiveChange);
+  void checkPrimalSolution(const double *rowActivities = __null,
+    const double *columnActivies = __null);
+  void checkDualSolution();
+  void checkBothSolutions();
+  double scaleObjective(double value);
+  int solveDW(CoinStructuredModel *model, ClpSolve &options);
+  int solveBenders(CoinStructuredModel *model, ClpSolve &options);
+public:
+  void setValuesPassAction(double incomingInfeasibility,
+    double allowedInfeasibility);
+  int cleanFactorization(int ifValuesPass);
+public:
+  inline double alphaAccuracy() const
+  {
+    return alphaAccuracy_;
+  }
+  inline void setAlphaAccuracy(double value)
+  {
+    alphaAccuracy_ = value;
+  }
+public:
+  inline void setDisasterHandler(ClpDisasterHandler *handler)
+  {
+    disasterArea_ = handler;
+  }
+  inline ClpDisasterHandler *disasterHandler() const
+  {
+    return disasterArea_;
+  }
+  inline double largeValue() const
+  {
+    return largeValue_;
+  }
+  void setLargeValue(double value);
+  inline double largestPrimalError() const
+  {
+    return largestPrimalError_;
+  }
+  inline double largestDualError() const
+  {
+    return largestDualError_;
+  }
+  inline void setLargestPrimalError(double value)
+  {
+    largestPrimalError_ = value;
+  }
+  inline void setLargestDualError(double value)
+  {
+    largestDualError_ = value;
+  }
+  inline double zeroTolerance() const
+  {
+    return zeroTolerance_;
+  }
+  inline void setZeroTolerance(double value)
+  {
+    zeroTolerance_ = value;
+  }
+  inline int *pivotVariable() const
+  {
+    return pivotVariable_;
+  }
+  inline bool automaticScaling() const
+  {
+    return automaticScale_ != 0;
+  }
+  inline void setAutomaticScaling(bool onOff)
+  {
+    automaticScale_ = onOff ? 1 : 0;
+  }
+  inline double currentDualTolerance() const
+  {
+    return dualTolerance_;
+  }
+  inline void setCurrentDualTolerance(double value)
+  {
+    dualTolerance_ = value;
+  }
+  inline double currentPrimalTolerance() const
+  {
+    return primalTolerance_;
+  }
+  inline void setCurrentPrimalTolerance(double value)
+  {
+    primalTolerance_ = value;
+  }
+  inline int numberRefinements() const
+  {
+    return numberRefinements_;
+  }
+  void setNumberRefinements(int value);
+  inline double alpha() const
+  {
+    return alpha_;
+  }
+  inline void setAlpha(double value)
+  {
+    alpha_ = value;
+  }
+  inline double dualIn() const
+  {
+    return dualIn_;
+  }
+  inline void setDualIn(double value)
+  {
+    dualIn_ = value;
+  }
+  inline int pivotRow() const
+  {
+    return pivotRow_;
+  }
+  inline void setPivotRow(int value)
+  {
+    pivotRow_ = value;
+  }
+  double valueIncomingDual() const;
+protected:
+  int gutsOfSolution(double *givenDuals,
+    const double *givenPrimals,
+    bool valuesPass = false);
+  void gutsOfDelete(int type);
+  void gutsOfCopy(const ClpSimplex &rhs);
+  bool createRim(int what, bool makeRowCopy = false, int startFinishOptions = 0);
+  void createRim1(bool initial);
+  void createRim4(bool initial);
+  void createRim5(bool initial);
+  void deleteRim(int getRidOfFactorizationData = 2);
+  bool sanityCheck();
+public:
+  inline double *solutionRegion(int section) const
+  {
+    if (!section)
+      return rowActivityWork_;
+    else
+      return columnActivityWork_;
+  }
+  inline double *djRegion(int section) const
+  {
+    if (!section)
+      return rowReducedCost_;
+    else
+      return reducedCostWork_;
+  }
+  inline double *lowerRegion(int section) const
+  {
+    if (!section)
+      return rowLowerWork_;
+    else
+      return columnLowerWork_;
+  }
+  inline double *upperRegion(int section) const
+  {
+    if (!section)
+      return rowUpperWork_;
+    else
+      return columnUpperWork_;
+  }
+  inline double *costRegion(int section) const
+  {
+    if (!section)
+      return rowObjectiveWork_;
+    else
+      return objectiveWork_;
+  }
+  inline double *solutionRegion() const
+  {
+    return solution_;
+  }
+  inline double *djRegion() const
+  {
+    return dj_;
+  }
+  inline double *lowerRegion() const
+  {
+    return lower_;
+  }
+  inline double *upperRegion() const
+  {
+    return upper_;
+  }
+  inline double *costRegion() const
+  {
+    return cost_;
+  }
+  inline Status getStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence] & 7);
+  }
+  inline void setStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  bool startPermanentArrays();
+  void setInitialDenseFactorization(bool onOff);
+  bool initialDenseFactorization() const;
+  inline int sequenceIn() const
+  {
+    return sequenceIn_;
+  }
+  inline int sequenceOut() const
+  {
+    return sequenceOut_;
+  }
+  inline void setSequenceIn(int sequence)
+  {
+    sequenceIn_ = sequence;
+  }
+  inline void setSequenceOut(int sequence)
+  {
+    sequenceOut_ = sequence;
+  }
+  inline int directionIn() const
+  {
+    return directionIn_;
+  }
+  inline int directionOut() const
+  {
+    return directionOut_;
+  }
+  inline void setDirectionIn(int direction)
+  {
+    directionIn_ = direction;
+  }
+  inline void setDirectionOut(int direction)
+  {
+    directionOut_ = direction;
+  }
+  inline double valueOut() const
+  {
+    return valueOut_;
+  }
+  inline double lowerOut() const
+  {
+    return lowerOut_;
+  }
+  inline double upperOut() const
+  {
+    return upperOut_;
+  }
+  inline void setValueOut(double value)
+  {
+    valueOut_ = value;
+  }
+  inline double dualOut() const
+  {
+    return dualOut_;
+  }
+  inline void setDualOut(double value)
+  {
+    dualOut_ = value;
+  }
+  inline void setLowerOut(double value)
+  {
+    lowerOut_ = value;
+  }
+  inline void setUpperOut(double value)
+  {
+    upperOut_ = value;
+  }
+  inline void setTheta(double value)
+  {
+    theta_ = value;
+  }
+  inline int isColumn(int sequence) const
+  {
+    return sequence < numberColumns_ ? 1 : 0;
+  }
+  inline int sequenceWithin(int sequence) const
+  {
+    return sequence < numberColumns_ ? sequence : sequence - numberColumns_;
+  }
+  inline double solution(int sequence)
+  {
+    return solution_[sequence];
+  }
+  inline double &solutionAddress(int sequence)
+  {
+    return solution_[sequence];
+  }
+  inline double reducedCost(int sequence)
+  {
+    return dj_[sequence];
+  }
+  inline double &reducedCostAddress(int sequence)
+  {
+    return dj_[sequence];
+  }
+  inline double lower(int sequence)
+  {
+    return lower_[sequence];
+  }
+  inline double &lowerAddress(int sequence)
+  {
+    return lower_[sequence];
+  }
+  inline double upper(int sequence)
+  {
+    return upper_[sequence];
+  }
+  inline double &upperAddress(int sequence)
+  {
+    return upper_[sequence];
+  }
+  inline double cost(int sequence)
+  {
+    return cost_[sequence];
+  }
+  inline double &costAddress(int sequence)
+  {
+    return cost_[sequence];
+  }
+  inline double originalLower(int iSequence) const
+  {
+    if (iSequence < numberColumns_)
+      return columnLower_[iSequence];
+    else
+      return rowLower_[iSequence - numberColumns_];
+  }
+  inline double originalUpper(int iSequence) const
+  {
+    if (iSequence < numberColumns_)
+      return columnUpper_[iSequence];
+    else
+      return rowUpper_[iSequence - numberColumns_];
+  }
+  inline double theta() const
+  {
+    return theta_;
+  }
+  inline double lowerIn() const
+  {
+    return lowerIn_;
+  }
+  inline double valueIn() const
+  {
+    return valueIn_;
+  }
+  inline double upperIn() const
+  {
+    return upperIn_;
+  }
+  inline double bestPossibleImprovement() const
+  {
+    return bestPossibleImprovement_;
+  }
+  inline ClpNonLinearCost *nonLinearCost() const
+  {
+    return nonLinearCost_;
+  }
+  void setNonLinearCost(ClpNonLinearCost &nonLinearCost);
+  inline int moreSpecialOptions() const
+  {
+    return moreSpecialOptions_;
+  }
+  inline int vectorMode() const
+  {
+    return vectorMode_;
+  }
+  inline void setMoreSpecialOptions(int value)
+  {
+    moreSpecialOptions_ = value;
+  }
+  inline void setVectorMode(int value)
+  {
+    vectorMode_ = value;
+  }
+  inline void setFakeBound(int sequence, FakeBound fakeBound)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~24);
+    st_byte = static_cast< unsigned char >(st_byte | (fakeBound << 3));
+  }
+  inline FakeBound getFakeBound(int sequence) const
+  {
+    return static_cast< FakeBound >((status_[sequence] >> 3) & 3);
+  }
+  inline void setRowStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence + numberColumns_];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  inline Status getRowStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence + numberColumns_] & 7);
+  }
+  inline void setColumnStatus(int sequence, Status newstatus)
+  {
+    unsigned char &st_byte = status_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & ~7);
+    st_byte = static_cast< unsigned char >(st_byte | newstatus);
+  }
+  inline Status getColumnStatus(int sequence) const
+  {
+    return static_cast< Status >(status_[sequence] & 7);
+  }
+  inline void setPivoted(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] | 32);
+  }
+  inline void clearPivoted(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] & ~32);
+  }
+  inline bool pivoted(int sequence) const
+  {
+    return (((status_[sequence] >> 5) & 1) != 0);
+  }
+  void setFlagged(int sequence);
+  inline void clearFlagged(int sequence)
+  {
+    status_[sequence] = static_cast< unsigned char >(status_[sequence] & ~64);
+  }
+  inline bool flagged(int sequence) const
+  {
+    return ((status_[sequence] & 64) != 0);
+  }
+  inline void setActive(int iRow)
+  {
+    status_[iRow] = static_cast< unsigned char >(status_[iRow] | 128);
+  }
+  inline void clearActive(int iRow)
+  {
+    status_[iRow] = static_cast< unsigned char >(status_[iRow] & ~128);
+  }
+  inline bool active(int iRow) const
+  {
+    return ((status_[iRow] & 128) != 0);
+  }
+  inline void setPerturbed(int iSequence)
+  {
+    status_[iSequence] = static_cast< unsigned char >(status_[iSequence] | 128);
+  }
+  inline void clearPerturbed(int iSequence)
+  {
+    status_[iSequence] = static_cast< unsigned char >(status_[iSequence] & ~128);
+  }
+  inline bool perturbed(int iSequence) const
+  {
+    return ((status_[iSequence] & 128) != 0);
+  }
+  void createStatus();
+  void allSlackBasis(bool resetSolution = false);
+  inline int lastBadIteration() const
+  {
+    return lastBadIteration_;
+  }
+  inline void setLastBadIteration(int value)
+  {
+    lastBadIteration_ = value;
+  }
+  inline int progressFlag() const
+  {
+    return (progressFlag_ & 3);
+  }
+  inline ClpSimplexProgress *progress()
+  {
+    return &progress_;
+  }
+  inline int forceFactorization() const
+  {
+    return forceFactorization_;
+  }
+  inline void forceFactorization(int value)
+  {
+    forceFactorization_ = value;
+  }
+  inline double rawObjectiveValue() const
+  {
+    return objectiveValue_;
+  }
+  void computeObjectiveValue(bool useWorkingSolution = false);
+  double computeInternalObjectiveValue();
+  double *infeasibilityRay(bool fullRay = false) const;
+  inline int numberExtraRows() const
+  {
+    return numberExtraRows_;
+  }
+  inline int maximumBasic() const
+  {
+    return maximumBasic_;
+  }
+  inline int baseIteration() const
+  {
+    return baseIteration_;
+  }
+  void generateCpp(FILE *fp, bool defaultFactor = false);
+  ClpFactorization *getEmptyFactorization();
+  void setEmptyFactorization();
+  void moveInfo(const ClpSimplex &rhs, bool justStatus = false);
+  void getBInvARow(int row, double *z, double *slack = __null);
+  void getBInvRow(int row, double *z);
+  void getBInvACol(int col, double *vec);
+  void getBInvCol(int col, double *vec);
+  void getBasics(int *index);
+  void setObjectiveCoefficient(int elementIndex, double elementValue);
+  inline void setObjCoeff(int elementIndex, double elementValue)
+  {
+    setObjectiveCoefficient(elementIndex, elementValue);
+  }
+  void setColumnLower(int elementIndex, double elementValue);
+  void setColumnUpper(int elementIndex, double elementValue);
+  void setColumnBounds(int elementIndex,
+    double lower, double upper);
+  void setColumnSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  inline void setColLower(int elementIndex, double elementValue)
+  {
+    setColumnLower(elementIndex, elementValue);
+  }
+  inline void setColUpper(int elementIndex, double elementValue)
+  {
+    setColumnUpper(elementIndex, elementValue);
+  }
+  inline void setColBounds(int elementIndex,
+    double newlower, double newupper)
+  {
+    setColumnBounds(elementIndex, newlower, newupper);
+  }
+  inline void setColSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList)
+  {
+    setColumnSetBounds(indexFirst, indexLast, boundList);
+  }
+  void setRowLower(int elementIndex, double elementValue);
+  void setRowUpper(int elementIndex, double elementValue);
+  void setRowBounds(int elementIndex,
+    double lower, double upper);
+  void setRowSetBounds(const int *indexFirst,
+    const int *indexLast,
+    const double *boundList);
+  void resize(int newNumberRows, int newNumberColumns);
+protected:
+  double bestPossibleImprovement_;
+  double zeroTolerance_;
+  int columnPrimalSequence_;
+  int rowPrimalSequence_;
+  double bestObjectiveValue_;
+  int moreSpecialOptions_;
+  int baseIteration_;
+  int vectorMode_;
+  double primalToleranceToGetOptimal_;
+  double largeValue_;
+  double largestPrimalError_;
+  double largestDualError_;
+  double alphaAccuracy_;
+  double dualBound_;
+  double alpha_;
+  double theta_;
+  double lowerIn_;
+  double valueIn_;
+  double upperIn_;
+  double dualIn_;
+  double lowerOut_;
+  double valueOut_;
+  double upperOut_;
+  double dualOut_;
+  double dualTolerance_;
+  double primalTolerance_;
+  double sumDualInfeasibilities_;
+  double sumPrimalInfeasibilities_;
+  double infeasibilityCost_;
+  double sumOfRelaxedDualInfeasibilities_;
+  double sumOfRelaxedPrimalInfeasibilities_;
+  double acceptablePivot_;
+  double minimumPrimalTolerance_;
+  double averageInfeasibility_[5];
+  double *lower_;
+  double *rowLowerWork_;
+  double *columnLowerWork_;
+  double *upper_;
+  double *rowUpperWork_;
+  double *columnUpperWork_;
+  double *cost_;
+  double *rowObjectiveWork_;
+  double *objectiveWork_;
+  CoinIndexedVector *rowArray_[6];
+  CoinIndexedVector *columnArray_[6];
+  int sequenceIn_;
+  int directionIn_;
+  int sequenceOut_;
+  int directionOut_;
+  int pivotRow_;
+  int lastGoodIteration_;
+  double *dj_;
+  double *rowReducedCost_;
+  double *reducedCostWork_;
+  double *solution_;
+  double *rowActivityWork_;
+  double *columnActivityWork_;
+  int numberDualInfeasibilities_;
+  int numberDualInfeasibilitiesWithoutFree_;
+  int numberPrimalInfeasibilities_;
+  int numberRefinements_;
+  ClpDualRowPivot *dualRowPivot_;
+  ClpPrimalColumnPivot *primalColumnPivot_;
+  int *pivotVariable_;
+  ClpFactorization *factorization_;
+  double *savedSolution_;
+  int numberTimesOptimal_;
+  ClpDisasterHandler *disasterArea_;
+  int changeMade_;
+  int algorithm_;
+  int forceFactorization_;
+  int perturbation_;
+  unsigned char *saveStatus_;
+  ClpNonLinearCost *nonLinearCost_;
+  int lastBadIteration_;
+  int lastFlaggedIteration_;
+  int numberFake_;
+  int numberChanged_;
+  int progressFlag_;
+  int firstFree_;
+  int numberExtraRows_;
+  int maximumBasic_;
+  int dontFactorizePivots_;
+  double incomingInfeasibility_;
+  double allowedInfeasibility_;
+  int automaticScale_;
+  int maximumPerturbationSize_;
+  double *perturbationArray_;
+  ClpSimplex *baseModel_;
+  ClpSimplexProgress progress_;
+  int numberDegeneratePivots_;
+public:
+  mutable int spareIntArray_[4];
+  mutable double spareDoubleArray_[4];
+protected:
+  friend class OsiClpSolverInterface;
+  friend class OsiCLPSolverInterface;
+};
+void ClpSimplexUnitTest(const std::string &mpsDir);
+typedef struct {
+  double upperTheta;
+  double bestPossible;
+  double acceptablePivot;
+  double tolerance;
+  double dualTolerance;
+  double theta;
+  double primalRatio;
+  double changeObj;
+  const double * cost;
+  double * solution;
+  double * reducedCost;
+  const double * lower;
+  const double * upper;
+  double * work;
+  int * index;
+  double * spare;
+  const unsigned char * status;
+  int * which;
+  double * infeas;
+  const int * pivotVariable;
+  const double * element;
+  const CoinBigIndex * start;
+  const int * row;
+  int numberAdded;
+  int numberInfeasibilities;
+  int numberRemaining;
+  int startColumn;
+  int numberToDo;
+  int numberColumns;
+} clpTempInfo;
+class CoinPresolveAction;
+enum COIN_Message {
+  COIN_MPS_LINE = 0,
+  COIN_MPS_STATS,
+  COIN_MPS_ILLEGAL,
+  COIN_MPS_BADIMAGE,
+  COIN_MPS_DUPOBJ,
+  COIN_MPS_DUPROW,
+  COIN_MPS_NOMATCHROW,
+  COIN_MPS_NOMATCHCOL,
+  COIN_MPS_FILE,
+  COIN_MPS_BADFILE1,
+  COIN_MPS_BADFILE2,
+  COIN_MPS_EOF,
+  COIN_MPS_RETURNING,
+  COIN_MPS_CHANGED,
+  COIN_SOLVER_MPS,
+  COIN_PRESOLVE_COLINFEAS,
+  COIN_PRESOLVE_ROWINFEAS,
+  COIN_PRESOLVE_COLUMNBOUNDA,
+  COIN_PRESOLVE_COLUMNBOUNDB,
+  COIN_PRESOLVE_NONOPTIMAL,
+  COIN_PRESOLVE_STATS,
+  COIN_PRESOLVE_INFEAS,
+  COIN_PRESOLVE_UNBOUND,
+  COIN_PRESOLVE_INFEASUNBOUND,
+  COIN_PRESOLVE_INTEGERMODS,
+  COIN_PRESOLVE_POSTSOLVE,
+  COIN_PRESOLVE_NEEDS_CLEANING,
+  COIN_PRESOLVE_PASS,
+  COIN_GENERAL_INFO,
+  COIN_GENERAL_INFO2,
+  COIN_GENERAL_WARNING,
+  COIN_DUMMY_END
+};
+class CoinMessage : public CoinMessages {
+public:
+  CoinMessage(Language language = us_en);
+};
+enum __rlimit_resource
+{
+  RLIMIT_CPU = 0,
+  RLIMIT_FSIZE = 1,
+  RLIMIT_DATA = 2,
+  RLIMIT_STACK = 3,
+  RLIMIT_CORE = 4,
+  __RLIMIT_RSS = 5,
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE,
+  RLIMIT_AS = 9,
+  __RLIMIT_NPROC = 6,
+  __RLIMIT_MEMLOCK = 8,
+  __RLIMIT_LOCKS = 10,
+  __RLIMIT_SIGPENDING = 11,
+  __RLIMIT_MSGQUEUE = 12,
+  __RLIMIT_NICE = 13,
+  __RLIMIT_RTPRIO = 14,
+  __RLIMIT_RTTIME = 15,
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+};
+typedef __rlim_t rlim_t;
+typedef __rlim64_t rlim64_t;
+struct rlimit
+  {
+    rlim_t rlim_cur;
+    rlim_t rlim_max;
+  };
+struct rlimit64
+  {
+    rlim64_t rlim_cur;
+    rlim64_t rlim_max;
+ };
+enum __rusage_who
+{
+  RUSAGE_SELF = 0,
+  RUSAGE_CHILDREN = -1
+  ,
+  RUSAGE_THREAD = 1
+};
+struct rusage
+  {
+    struct timeval ru_utime;
+    struct timeval ru_stime;
+    __extension__ union
+      {
+ long int ru_maxrss;
+ __syscall_slong_t __ru_maxrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_ixrss;
+ __syscall_slong_t __ru_ixrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_idrss;
+ __syscall_slong_t __ru_idrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_isrss;
+  __syscall_slong_t __ru_isrss_word;
+      };
+    __extension__ union
+      {
+ long int ru_minflt;
+ __syscall_slong_t __ru_minflt_word;
+      };
+    __extension__ union
+      {
+ long int ru_majflt;
+ __syscall_slong_t __ru_majflt_word;
+      };
+    __extension__ union
+      {
+ long int ru_nswap;
+ __syscall_slong_t __ru_nswap_word;
+      };
+    __extension__ union
+      {
+ long int ru_inblock;
+ __syscall_slong_t __ru_inblock_word;
+      };
+    __extension__ union
+      {
+ long int ru_oublock;
+ __syscall_slong_t __ru_oublock_word;
+      };
+    __extension__ union
+      {
+ long int ru_msgsnd;
+ __syscall_slong_t __ru_msgsnd_word;
+      };
+    __extension__ union
+      {
+ long int ru_msgrcv;
+ __syscall_slong_t __ru_msgrcv_word;
+      };
+    __extension__ union
+      {
+ long int ru_nsignals;
+ __syscall_slong_t __ru_nsignals_word;
+      };
+    __extension__ union
+      {
+ long int ru_nvcsw;
+ __syscall_slong_t __ru_nvcsw_word;
+      };
+    __extension__ union
+      {
+ long int ru_nivcsw;
+ __syscall_slong_t __ru_nivcsw_word;
+      };
+  };
+enum __priority_which
+{
+  PRIO_PROCESS = 0,
+  PRIO_PGRP = 1,
+  PRIO_USER = 2
+};
+extern "C" {
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+      const struct rlimit *__new_limit,
+      struct rlimit *__old_limit) noexcept (true);
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+        const struct rlimit64 *__new_limit,
+        struct rlimit64 *__old_limit) noexcept (true);
+}
+extern "C" {
+typedef int __rlimit_resource_t;
+typedef int __rusage_who_t;
+typedef int __priority_which_t;
+extern int getrlimit (__rlimit_resource_t __resource,
+        struct rlimit *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int getrlimit64 (__rlimit_resource_t __resource,
+   struct rlimit64 *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int setrlimit (__rlimit_resource_t __resource,
+        const struct rlimit *__rlimits) noexcept (true) __attribute__ ((__nonnull__ (2)));
+extern int setrlimit64 (__rlimit_resource_t __resource,
+   const struct rlimit64 *__rlimits) noexcept (true)
+   __attribute__ ((__nonnull__ (2)));
+extern int getrusage (__rusage_who_t __who, struct rusage *__usage) noexcept (true);
+extern int getpriority (__priority_which_t __which, id_t __who) noexcept (true);
+extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
+     noexcept (true);
+}
+extern "C" {
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+extern int gettimeofday (struct timeval *__restrict __tv,
+    void *__restrict __tz) noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int settimeofday (const struct timeval *__tv,
+    const struct timezone *__tz)
+     noexcept (true);
+extern int adjtime (const struct timeval *__delta,
+      struct timeval *__olddelta) noexcept (true);
+enum __itimer_which
+  {
+    ITIMER_REAL = 0,
+    ITIMER_VIRTUAL = 1,
+    ITIMER_PROF = 2
+  };
+struct itimerval
+  {
+    struct timeval it_interval;
+    struct timeval it_value;
+  };
+typedef int __itimer_which_t;
+extern int getitimer (__itimer_which_t __which,
+        struct itimerval *__value) noexcept (true);
+extern int setitimer (__itimer_which_t __which,
+        const struct itimerval *__restrict __new,
+        struct itimerval *__restrict __old) noexcept (true);
+extern int utimes (const char *__file, const struct timeval __tvp[2])
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int lutimes (const char *__file, const struct timeval __tvp[2])
+     noexcept (true) __attribute__ ((__nonnull__ (1)));
+extern int futimes (int __fd, const struct timeval __tvp[2]) noexcept (true);
+extern int futimesat (int __fd, const char *__file,
+        const struct timeval __tvp[2]) noexcept (true);
+}
+
+inline double CoinGetTimeOfDay()
+{
+  struct timeval tv;
+  gettimeofday(&tv, __null);
+  return static_cast< double >(tv.tv_sec) + static_cast< int >(tv.tv_usec) / 1000000.0;
+}
+inline double CoinWallclockTime(double callType = 0)
+{
+  double callTime = CoinGetTimeOfDay();
+  static const double firstCall = callType > 0 ? callType : callTime;
+  return callType < 0 ? firstCall : callTime - firstCall;
+}
+static inline double CoinCpuTime()
+{
+  double cpu_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_SELF, &usage);
+  cpu_temp = static_cast< double >(usage.ru_utime.tv_sec);
+  cpu_temp += 1.0e-6 * (static_cast< double >(usage.ru_utime.tv_usec));
+  return cpu_temp;
+}
+static inline double CoinSysTime()
+{
+  double sys_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_SELF, &usage);
+  sys_temp = static_cast< double >(usage.ru_stime.tv_sec);
+  sys_temp += 1.0e-6 * (static_cast< double >(usage.ru_stime.tv_usec));
+  return sys_temp;
+}
+static inline double CoinCpuTimeJustChildren()
+{
+  double cpu_temp;
+  struct rusage usage;
+  getrusage(RUSAGE_CHILDREN, &usage);
+  cpu_temp = static_cast< double >(usage.ru_utime.tv_sec);
+  cpu_temp += 1.0e-6 * (static_cast< double >(usage.ru_utime.tv_usec));
+  return cpu_temp;
+}
+class CoinTimer {
+private:
+  double start;
+  double limit;
+  double end;
+private:
+  inline bool evaluate(const bool b_tmp) const
+  {
+    return b_tmp;
+  }
+  inline double evaluate(const double d_tmp) const
+  {
+    return d_tmp;
+  }
+public:
+  CoinTimer()
+    : start(0)
+    , limit(1e100)
+    , end(1e100)
+  {
+  }
+  CoinTimer(double lim)
+    : start(CoinCpuTime())
+    , limit(lim)
+    , end(start + lim)
+  {
+  }
+  inline void restart()
+  {
+    start = CoinCpuTime();
+    end = start + limit;
+  }
+  inline void reset() { restart(); }
+  inline void reset(double lim)
+  {
+    limit = lim;
+    restart();
+  }
+  inline bool isPastPercent(double pct) const
+  {
+    return evaluate(start + limit * pct < CoinCpuTime());
+  }
+  inline bool isPast(double lim) const
+  {
+    return evaluate(start + lim < CoinCpuTime());
+  }
+  inline bool isExpired() const
+  {
+    return evaluate(end < CoinCpuTime());
+  }
+  inline double timeLeft() const
+  {
+    return evaluate(end - CoinCpuTime());
+  }
+  inline double timeElapsed() const
+  {
+    return evaluate(CoinCpuTime() - start);
+  }
+  inline void setLimit(double l)
+  {
+    limit = l;
+    return;
+  }
+};
+
+inline void DIE(const char *) {}
+const double ZTOLDP = 1e-12;
+const double ZTOLDP2 = 1e-10;
+class CoinPostsolveMatrix;
+class CoinPresolveAction {
+public:
+  static void throwCoinError(const char *error, const char *ps_routine)
+  {
+    throw CoinError(error, ps_routine, "CoinPresolve");
+  }
+  const CoinPresolveAction *next;
+  CoinPresolveAction(const CoinPresolveAction *next)
+    : next(next)
+  {
+  }
+  inline void setNext(const CoinPresolveAction *nextAction)
+  {
+    next = nextAction;
+  }
+  virtual const char *name() const = 0;
+  virtual void postsolve(CoinPostsolveMatrix *prob) const = 0;
+  virtual ~CoinPresolveAction() {}
+};
+class ClpSimplex;
+class OsiSolverInterface;
+class CoinWarmStartBasis;
+class CoinPrePostsolveMatrix {
+public:
+  CoinPrePostsolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPrePostsolveMatrix(const OsiSolverInterface *si,
+    int ncols_,
+    int nrows_,
+    CoinBigIndex nelems_);
+  CoinPrePostsolveMatrix(const ClpSimplex *si,
+    int ncols_,
+    int nrows_,
+    CoinBigIndex nelems_,
+    double bulkRatio);
+  ~CoinPrePostsolveMatrix();
+  enum Status {
+    isFree = 0x00,
+    basic = 0x01,
+    atUpperBound = 0x02,
+    atLowerBound = 0x03,
+    superBasic = 0x04
+  };
+  inline void setRowStatus(int sequence, Status status)
+  {
+    unsigned char &st_byte = rowstat_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & (~7));
+    st_byte = static_cast< unsigned char >(st_byte | status);
+  }
+  inline Status getRowStatus(int sequence) const
+  {
+    return static_cast< Status >(rowstat_[sequence] & 7);
+  }
+  inline bool rowIsBasic(int sequence) const
+  {
+    return (static_cast< Status >(rowstat_[sequence] & 7) == basic);
+  }
+  inline void setColumnStatus(int sequence, Status status)
+  {
+    unsigned char &st_byte = colstat_[sequence];
+    st_byte = static_cast< unsigned char >(st_byte & (~7));
+    st_byte = static_cast< unsigned char >(st_byte | status);
+    switch (status) {
+    case isFree: {
+      if (clo_[sequence] > -COIN_DBL_MAX || cup_[sequence] < COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " isFree, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case basic: {
+      break;
+    }
+    case atUpperBound: {
+      if (cup_[sequence] >= COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " atUpperBound, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case atLowerBound: {
+      if (clo_[sequence] <= -COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " atLowerBound, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    case superBasic: {
+      if (clo_[sequence] <= -COIN_DBL_MAX && cup_[sequence] >= COIN_DBL_MAX) {
+        std::cout << "Bad status: Var " << sequence
+                  << " superBasic, lb = " << clo_[sequence]
+                  << ", ub = " << cup_[sequence] << std::endl;
+      }
+      break;
+    }
+    default: {
+      (static_cast<void> (0));
+      break;
+    }
+    }
+  }
+  inline Status getColumnStatus(int sequence) const
+  {
+    return static_cast< Status >(colstat_[sequence] & 7);
+  }
+  inline bool columnIsBasic(int sequence) const
+  {
+    return (static_cast< Status >(colstat_[sequence] & 7) == basic);
+  }
+  void setRowStatusUsingValue(int iRow);
+  void setColumnStatusUsingValue(int iColumn);
+  void setStructuralStatus(const char *strucStatus, int lenParam);
+  void setArtificialStatus(const char *artifStatus, int lenParam);
+  void setStatus(const CoinWarmStartBasis *basis);
+  CoinWarmStartBasis *getStatus();
+  const char *columnStatusString(int j) const;
+  const char *rowStatusString(int i) const;
+  void setObjOffset(double offset);
+  void setObjSense(double objSense);
+  void setPrimalTolerance(double primTol);
+  void setDualTolerance(double dualTol);
+  void setColLower(const double *colLower, int lenParam);
+  void setColUpper(const double *colUpper, int lenParam);
+  void setColSolution(const double *colSol, int lenParam);
+  void setCost(const double *cost, int lenParam);
+  void setReducedCost(const double *redCost, int lenParam);
+  void setRowLower(const double *rowLower, int lenParam);
+  void setRowUpper(const double *rowUpper, int lenParam);
+  void setRowPrice(const double *rowSol, int lenParam);
+  void setRowActivity(const double *rowAct, int lenParam);
+  inline int getNumCols() const
+  {
+    return (ncols_);
+  }
+  inline int getNumRows() const
+  {
+    return (nrows_);
+  }
+  inline CoinBigIndex getNumElems() const
+  {
+    return (nelems_);
+  }
+  inline const CoinBigIndex *getColStarts() const
+  {
+    return (mcstrt_);
+  }
+  inline const int *getColLengths() const
+  {
+    return (hincol_);
+  }
+  inline const int *getRowIndicesByCol() const
+  {
+    return (hrow_);
+  }
+  inline const double *getElementsByCol() const
+  {
+    return (colels_);
+  }
+  inline const double *getColLower() const
+  {
+    return (clo_);
+  }
+  inline const double *getColUpper() const
+  {
+    return (cup_);
+  }
+  inline const double *getCost() const
+  {
+    return (cost_);
+  }
+  inline const double *getRowLower() const
+  {
+    return (rlo_);
+  }
+  inline const double *getRowUpper() const
+  {
+    return (rup_);
+  }
+  inline const double *getColSolution() const
+  {
+    return (sol_);
+  }
+  inline const double *getRowActivity() const
+  {
+    return (acts_);
+  }
+  inline const double *getRowPrice() const
+  {
+    return (rowduals_);
+  }
+  inline const double *getReducedCost() const
+  {
+    return (rcosts_);
+  }
+  inline int countEmptyCols()
+  {
+    int empty = 0;
+    for (int i = 0; i < ncols_; i++)
+      if (hincol_[i] == 0)
+        empty++;
+    return (empty);
+  }
+  inline CoinMessageHandler *messageHandler() const
+  {
+    return handler_;
+  }
+  inline void setMessageHandler(CoinMessageHandler *handler)
+  {
+    if (defaultHandler_ == true) {
+      delete handler_;
+      defaultHandler_ = false;
+    }
+    handler_ = handler;
+  }
+  inline CoinMessages messages() const
+  {
+    return messages_;
+  }
+  int ncols_;
+  int nrows_;
+  CoinBigIndex nelems_;
+  int ncols0_;
+  int nrows0_;
+  CoinBigIndex nelems0_;
+  CoinBigIndex bulk0_;
+  double bulkRatio_;
+  CoinBigIndex *mcstrt_;
+  int *hincol_;
+  int *hrow_;
+  double *colels_;
+  double *cost_;
+  double originalOffset_;
+  double *clo_;
+  double *cup_;
+  double *rlo_;
+  double *rup_;
+  int *originalColumn_;
+  int *originalRow_;
+  double ztolzb_;
+  double ztoldj_;
+  double maxmin_;
+  double *sol_;
+  double *rowduals_;
+  double *acts_;
+  double *rcosts_;
+  unsigned char *colstat_;
+  unsigned char *rowstat_;
+  CoinMessageHandler *handler_;
+  bool defaultHandler_;
+  CoinMessage messages_;
+};
+const char *statusName(CoinPrePostsolveMatrix::Status status);
+class presolvehlink {
+public:
+  int pre, suc;
+};
+inline void PRESOLVE_REMOVE_LINK(presolvehlink *link, int i)
+{
+  int ipre = link[i].pre;
+  int isuc = link[i].suc;
+  if (ipre >= 0) {
+    link[ipre].suc = isuc;
+  }
+  if (isuc >= 0) {
+    link[isuc].pre = ipre;
+  }
+  link[i].pre = -66666666, link[i].suc = -66666666;
+}
+inline void PRESOLVE_INSERT_LINK(presolvehlink *link, int i, int j)
+{
+  int isuc = link[j].suc;
+  link[j].suc = i;
+  link[i].pre = j;
+  if (isuc >= 0) {
+    link[isuc].pre = i;
+  }
+  link[i].suc = isuc;
+}
+inline void PRESOLVE_MOVE_LINK(presolvehlink *link, int i, int j)
+{
+  int ipre = link[i].pre;
+  int isuc = link[i].suc;
+  if (ipre >= 0) {
+    link[ipre].suc = j;
+  }
+  if (isuc >= 0) {
+    link[isuc].pre = j;
+  }
+  link[i].pre = -66666666, link[i].suc = -66666666;
+}
+class CoinPresolveMatrix : public CoinPrePostsolveMatrix {
+public:
+  CoinPresolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPresolveMatrix(int ncols0,
+    double maxmin,
+    ClpSimplex *si,
+    int nrows,
+    CoinBigIndex nelems,
+    bool doStatus,
+    double nonLinearVariable,
+    double bulkRatio);
+  void update_model(ClpSimplex *si,
+    int nrows0,
+    int ncols0,
+    CoinBigIndex nelems0);
+  CoinPresolveMatrix(int ncols0,
+    double maxmin,
+    OsiSolverInterface *si,
+    int nrows,
+    CoinBigIndex nelems,
+    bool doStatus,
+    double nonLinearVariable,
+    const char *prohibited,
+    const char *rowProhibited = __null);
+  void update_model(OsiSolverInterface *si,
+    int nrows0,
+    int ncols0,
+    CoinBigIndex nelems0);
+  ~CoinPresolveMatrix();
+  friend void assignPresolveToPostsolve(CoinPresolveMatrix *&preObj);
+  void setMatrix(const CoinPackedMatrix *mtx);
+  inline int countEmptyRows()
+  {
+    int empty = 0;
+    for (int i = 0; i < nrows_; i++)
+      if (hinrow_[i] == 0)
+        empty++;
+    return (empty);
+  }
+  inline void setVariableType(int i, int variableType)
+  {
+    if (integerType_ == 0)
+      integerType_ = new unsigned char[ncols0_];
+    integerType_[i] = static_cast< unsigned char >(variableType);
+  }
+  void setVariableType(const unsigned char *variableType, int lenParam);
+  void setVariableType(bool allIntegers, int lenParam);
+  inline void setAnyInteger(bool anyInteger = true)
+  {
+    anyInteger_ = anyInteger;
+  }
+  inline const CoinBigIndex *getRowStarts() const
+  {
+    return (mrstrt_);
+  }
+  inline const int *getColIndicesByRow() const
+  {
+    return (hcol_);
+  }
+  inline const double *getElementsByRow() const
+  {
+    return (rowels_);
+  }
+  inline bool isInteger(int i) const
+  {
+    if (integerType_ == 0) {
+      return (anyInteger_);
+    } else if (integerType_[i] == 1) {
+      return (true);
+    } else {
+      return (false);
+    }
+  }
+  inline bool anyInteger() const
+  {
+    return (anyInteger_);
+  }
+  inline int presolveOptions() const
+  {
+    return presolveOptions_;
+  }
+  inline void setPresolveOptions(int value)
+  {
+    presolveOptions_ = value;
+  }
+  presolvehlink *clink_;
+  presolvehlink *rlink_;
+  double dobias_;
+  inline void change_bias(double change_amount)
+  {
+    dobias_ += change_amount;
+  }
+  CoinBigIndex *mrstrt_;
+  int *hinrow_;
+  double *rowels_;
+  int *hcol_;
+  unsigned char *integerType_;
+  bool anyInteger_;
+  bool tuning_;
+  void statistics();
+  double startTime_;
+  double feasibilityTolerance_;
+  inline double feasibilityTolerance()
+  {
+    return (feasibilityTolerance_);
+  }
+  inline void setFeasibilityTolerance(double val)
+  {
+    feasibilityTolerance_ = val;
+  }
+  int status_;
+  inline int status()
+  {
+    return (status_);
+  }
+  inline void setStatus(int status)
+  {
+    status_ = (status & 0x3);
+  }
+  int pass_;
+  inline void setPass(int pass = 0)
+  {
+    pass_ = pass;
+  }
+  int maxSubstLevel_;
+  inline void setMaximumSubstitutionLevel(int level)
+  {
+    maxSubstLevel_ = level;
+  }
+  unsigned char *colChanged_;
+  int *colsToDo_;
+  int numberColsToDo_;
+  int *nextColsToDo_;
+  int numberNextColsToDo_;
+  unsigned char *rowChanged_;
+  int *rowsToDo_;
+  int numberRowsToDo_;
+  int *nextRowsToDo_;
+  int numberNextRowsToDo_;
+  int presolveOptions_;
+  bool anyProhibited_;
+  int *usefulRowInt_;
+  double *usefulRowDouble_;
+  int *usefulColumnInt_;
+  double *usefulColumnDouble_;
+  double *randomNumber_;
+  int *infiniteUp_;
+  double *sumUp_;
+  int *infiniteDown_;
+  double *sumDown_;
+  int recomputeSums(int whichRow);
+  void initializeStuff();
+  void deleteStuff();
+  void initColsToDo();
+  int stepColsToDo();
+  inline int numberColsToDo()
+  {
+    return (numberColsToDo_);
+  }
+  inline bool colChanged(int i) const
+  {
+    return (colChanged_[i] & 1) != 0;
+  }
+  inline void unsetColChanged(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~1));
+  }
+  inline void setColChanged(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (1));
+  }
+  inline void addCol(int i)
+  {
+    if ((colChanged_[i] & 1) == 0) {
+      colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (1));
+      nextColsToDo_[numberNextColsToDo_++] = i;
+    }
+  }
+  inline bool colProhibited(int i) const
+  {
+    return (colChanged_[i] & 2) != 0;
+  }
+  inline bool colProhibited2(int i) const
+  {
+    if (!anyProhibited_)
+      return false;
+    else
+      return (colChanged_[i] & 2) != 0;
+  }
+  inline void setColProhibited(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (2));
+  }
+  inline bool colUsed(int i) const
+  {
+    return (colChanged_[i] & 4) != 0;
+  }
+  inline void setColUsed(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (4));
+  }
+  inline void unsetColUsed(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~4));
+  }
+  inline bool colInfinite(int i) const
+  {
+    return (colChanged_[i] & 8) != 0;
+  }
+  inline void unsetColInfinite(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] & (~8));
+  }
+  inline void setColInfinite(int i)
+  {
+    colChanged_[i] = static_cast< unsigned char >(colChanged_[i] | (8));
+  }
+  void initRowsToDo();
+  int stepRowsToDo();
+  inline int numberRowsToDo()
+  {
+    return (numberRowsToDo_);
+  }
+  inline bool rowChanged(int i) const
+  {
+    return (rowChanged_[i] & 1) != 0;
+  }
+  inline void unsetRowChanged(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] & (~1));
+  }
+  inline void setRowChanged(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (1));
+  }
+  inline void addRow(int i)
+  {
+    if ((rowChanged_[i] & 1) == 0) {
+      rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (1));
+      nextRowsToDo_[numberNextRowsToDo_++] = i;
+    }
+  }
+  inline bool rowProhibited(int i) const
+  {
+    return (rowChanged_[i] & 2) != 0;
+  }
+  inline bool rowProhibited2(int i) const
+  {
+    if (!anyProhibited_)
+      return false;
+    else
+      return (rowChanged_[i] & 2) != 0;
+  }
+  inline void setRowProhibited(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (2));
+  }
+  inline bool rowUsed(int i) const
+  {
+    return (rowChanged_[i] & 4) != 0;
+  }
+  inline void setRowUsed(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] | (4));
+  }
+  inline void unsetRowUsed(int i)
+  {
+    rowChanged_[i] = static_cast< unsigned char >(rowChanged_[i] & (~4));
+  }
+  inline bool anyProhibited() const
+  {
+    return anyProhibited_;
+  }
+  inline void setAnyProhibited(bool val = true)
+  {
+    anyProhibited_ = val;
+  }
+};
+class CoinPostsolveMatrix : public CoinPrePostsolveMatrix {
+public:
+  CoinPostsolveMatrix(int ncols_alloc, int nrows_alloc,
+    CoinBigIndex nelems_alloc);
+  CoinPostsolveMatrix(ClpSimplex *si,
+    int ncols0,
+    int nrows0,
+    CoinBigIndex nelems0,
+    double maxmin_,
+    double *sol,
+    double *acts,
+    unsigned char *colstat,
+    unsigned char *rowstat);
+  CoinPostsolveMatrix(OsiSolverInterface *si,
+    int ncols0,
+    int nrows0,
+    CoinBigIndex nelems0,
+    double maxmin_,
+    double *sol,
+    double *acts,
+    unsigned char *colstat,
+    unsigned char *rowstat);
+  void assignPresolveToPostsolve(CoinPresolveMatrix *&preObj);
+  ~CoinPostsolveMatrix();
+  CoinBigIndex free_list_;
+  CoinBigIndex maxlink_;
+  CoinBigIndex *link_;
+  char *cdone_;
+  char *rdone_;
+  void check_nbasic();
+};
+void presolve_make_memlists( int *lengths,
+  presolvehlink *link, int n);
+bool presolve_expand_major(CoinBigIndex *majstrts, double *majels,
+  int *minndxs, int *majlens,
+  presolvehlink *majlinks, int nmaj, int k);
+inline bool presolve_expand_col(CoinBigIndex *mcstrt, double *colels,
+  int *hrow, int *hincol,
+  presolvehlink *clink, int ncols, int colx)
+{
+  return presolve_expand_major(mcstrt, colels,
+    hrow, hincol, clink, ncols, colx);
+}
+inline bool presolve_expand_row(CoinBigIndex *mrstrt, double *rowels,
+  int *hcol, int *hinrow,
+  presolvehlink *rlink, int nrows, int rowx)
+{
+  return presolve_expand_major(mrstrt, rowels,
+    hcol, hinrow, rlink, nrows, rowx);
+}
+inline CoinBigIndex presolve_find_minor(int tgt,
+  CoinBigIndex ks, CoinBigIndex ke,
+  const int *minndxs)
+{
+  CoinBigIndex k;
+  for (k = ks; k < ke; k++)
+  {
+    if (minndxs[k] == tgt)
+      break;
+  }
+  return (k);
+}
+inline CoinBigIndex presolve_find_row(int row, CoinBigIndex kcs,
+  CoinBigIndex kce, const int *hrow)
+{
+  return presolve_find_minor(row, kcs, kce, hrow);
+}
+inline CoinBigIndex presolve_find_col(int col, CoinBigIndex krs,
+  CoinBigIndex kre, const int *hcol)
+{
+  return presolve_find_minor(col, krs, kre, hcol);
+}
+CoinBigIndex presolve_find_minor1(int tgt, CoinBigIndex ks, CoinBigIndex ke,
+  const int *minndxs);
+inline CoinBigIndex presolve_find_row1(int row, CoinBigIndex kcs,
+  CoinBigIndex kce, const int *hrow)
+{
+  return presolve_find_minor1(row, kcs, kce, hrow);
+}
+inline CoinBigIndex presolve_find_col1(int col, CoinBigIndex krs,
+  CoinBigIndex kre, const int *hcol)
+{
+  return presolve_find_minor1(col, krs, kre, hcol);
+}
+CoinBigIndex presolve_find_minor2(int tgt, CoinBigIndex ks, int majlen,
+  const int *minndxs,
+  const CoinBigIndex *majlinks);
+inline CoinBigIndex presolve_find_row2(int row, CoinBigIndex kcs, int collen,
+  const int *hrow,
+  const CoinBigIndex *clinks)
+{
+  return presolve_find_minor2(row, kcs, collen, hrow, clinks);
+}
+CoinBigIndex presolve_find_minor3(int tgt, CoinBigIndex ks, int majlen,
+  const int *minndxs,
+  const CoinBigIndex *majlinks);
+inline CoinBigIndex presolve_find_row3(int row, CoinBigIndex kcs, int collen,
+  const int *hrow,
+  const CoinBigIndex *clinks)
+{
+  return presolve_find_minor3(row, kcs, collen, hrow, clinks);
+}
+inline void presolve_delete_from_major(int majndx, int minndx,
+  const CoinBigIndex *majstrts,
+  int *majlens, int *minndxs, double *els)
+{
+  const CoinBigIndex ks = majstrts[majndx];
+  const CoinBigIndex ke = ks + majlens[majndx];
+  const CoinBigIndex kmi = presolve_find_minor(minndx, ks, ke, minndxs);
+  minndxs[kmi] = minndxs[ke - 1];
+  els[kmi] = els[ke - 1];
+  majlens[majndx]--;
+  return;
+}
+inline void presolve_delete_many_from_major(int majndx, char *marked,
+  const CoinBigIndex *majstrts,
+  int *majlens, int *minndxs, double *els)
+{
+  const CoinBigIndex ks = majstrts[majndx];
+  const CoinBigIndex ke = ks + majlens[majndx];
+  CoinBigIndex put = ks;
+  for (CoinBigIndex k = ks; k < ke; k++) {
+    int iMinor = minndxs[k];
+    if (!marked[iMinor]) {
+      minndxs[put] = iMinor;
+      els[put++] = els[k];
+    } else {
+      marked[iMinor] = 0;
+    }
+  }
+  majlens[majndx] = static_cast< int >(put - ks);
+  return;
+}
+inline void presolve_delete_from_col(int row, int col,
+  const CoinBigIndex *mcstrt,
+  int *hincol, int *hrow, double *colels)
+{
+  presolve_delete_from_major(col, row, mcstrt, hincol, hrow, colels);
+}
+inline void presolve_delete_from_row(int row, int col,
+  const CoinBigIndex *mrstrt,
+  int *hinrow, int *hcol, double *rowels)
+{
+  presolve_delete_from_major(row, col, mrstrt, hinrow, hcol, rowels);
+}
+void presolve_delete_from_major2(int majndx, int minndx,
+  CoinBigIndex *majstrts, int *majlens,
+  int *minndxs, CoinBigIndex *majlinks,
+  CoinBigIndex *free_listp);
+inline void presolve_delete_from_col2(int row, int col, CoinBigIndex *mcstrt,
+  int *hincol, int *hrow,
+  CoinBigIndex *clinks, CoinBigIndex *free_listp)
+{
+  presolve_delete_from_major2(col, row, mcstrt, hincol, hrow, clinks, free_listp);
+}
+double *presolve_dupmajor(const double *elems, const int *indices,
+  int length, CoinBigIndex offset, int tgt = -1);
+void coin_init_random_vec(double *work, int n);
+class ClpPresolve {
+public:
+  ClpPresolve();
+  virtual ~ClpPresolve();
+  ClpSimplex *presolvedModel(ClpSimplex &si,
+    double feasibilityTolerance = 0.0,
+    bool keepIntegers = true,
+    int numberPasses = 5,
+    bool dropNames = false,
+    bool doRowObjective = false,
+    const char *prohibitedRows = __null,
+    const char *prohibitedColumns = __null);
+  int presolvedModelToFile(ClpSimplex &si, std::string fileName,
+    double feasibilityTolerance = 0.0,
+    bool keepIntegers = true,
+    int numberPasses = 5,
+    bool dropNames = false,
+    bool doRowObjective = false);
+  ClpSimplex *model() const;
+  ClpSimplex *originalModel() const;
+  void setOriginalModel(ClpSimplex *model);
+  const int *originalColumns() const;
+  const int *originalRows() const;
+  inline void setNonLinearValue(double value)
+  {
+    nonLinearValue_ = value;
+  }
+  inline double nonLinearValue() const
+  {
+    return nonLinearValue_;
+  }
+  inline bool doDual() const
+  {
+    return (presolveActions_ & 1) == 0;
+  }
+  inline void setDoDual(bool doDual)
+  {
+    if (doDual)
+      presolveActions_ &= ~1;
+    else
+      presolveActions_ |= 1;
+  }
+  inline bool doSingleton() const
+  {
+    return (presolveActions_ & 2) == 0;
+  }
+  inline void setDoSingleton(bool doSingleton)
+  {
+    if (doSingleton)
+      presolveActions_ &= ~2;
+    else
+      presolveActions_ |= 2;
+  }
+  inline bool doDoubleton() const
+  {
+    return (presolveActions_ & 4) == 0;
+  }
+  inline void setDoDoubleton(bool doDoubleton)
+  {
+    if (doDoubleton)
+      presolveActions_ &= ~4;
+    else
+      presolveActions_ |= 4;
+  }
+  inline bool doTripleton() const
+  {
+    return (presolveActions_ & 8) == 0;
+  }
+  inline void setDoTripleton(bool doTripleton)
+  {
+    if (doTripleton)
+      presolveActions_ &= ~8;
+    else
+      presolveActions_ |= 8;
+  }
+  inline bool doTighten() const
+  {
+    return (presolveActions_ & 16) == 0;
+  }
+  inline void setDoTighten(bool doTighten)
+  {
+    if (doTighten)
+      presolveActions_ &= ~16;
+    else
+      presolveActions_ |= 16;
+  }
+  inline bool doForcing() const
+  {
+    return (presolveActions_ & 32) == 0;
+  }
+  inline void setDoForcing(bool doForcing)
+  {
+    if (doForcing)
+      presolveActions_ &= ~32;
+    else
+      presolveActions_ |= 32;
+  }
+  inline bool doImpliedFree() const
+  {
+    return (presolveActions_ & 64) == 0;
+  }
+  inline void setDoImpliedFree(bool doImpliedfree)
+  {
+    if (doImpliedfree)
+      presolveActions_ &= ~64;
+    else
+      presolveActions_ |= 64;
+  }
+  inline bool doDupcol() const
+  {
+    return (presolveActions_ & 128) == 0;
+  }
+  inline void setDoDupcol(bool doDupcol)
+  {
+    if (doDupcol)
+      presolveActions_ &= ~128;
+    else
+      presolveActions_ |= 128;
+  }
+  inline bool doDuprow() const
+  {
+    return (presolveActions_ & 256) == 0;
+  }
+  inline void setDoDuprow(bool doDuprow)
+  {
+    if (doDuprow)
+      presolveActions_ &= ~256;
+    else
+      presolveActions_ |= 256;
+  }
+  inline bool doDependency() const
+  {
+    return (presolveActions_ & 32768) != 0;
+  }
+  inline void setDoDependency(bool doDependency)
+  {
+    if (doDependency)
+      presolveActions_ |= 32768;
+    else
+      presolveActions_ &= ~32768;
+  }
+  inline bool doTransfer() const
+  {
+    return (presolveActions_ & 65536) != 0;
+  }
+  inline void setDoTransfer(bool doTransfer)
+  {
+    if (doTransfer)
+      presolveActions_ |= 65536;
+    else
+      presolveActions_ &= ~65536;
+  }
+  inline bool doSingletonColumn() const
+  {
+    return (presolveActions_ & 512) == 0;
+  }
+  inline void setDoSingletonColumn(bool doSingleton)
+  {
+    if (doSingleton)
+      presolveActions_ &= ~512;
+    else
+      presolveActions_ |= 512;
+  }
+  inline bool doGubrow() const
+  {
+    return (presolveActions_ & 1024) == 0;
+  }
+  inline void setDoGubrow(bool doGubrow)
+  {
+    if (doGubrow)
+      presolveActions_ &= ~1024;
+    else
+      presolveActions_ |= 1024;
+  }
+  inline bool doTwoxTwo() const
+  {
+    return (presolveActions_ & 2048) != 0;
+  }
+  inline void setDoTwoxtwo(bool doTwoxTwo)
+  {
+    if (!doTwoxTwo)
+      presolveActions_ &= ~2048;
+    else
+      presolveActions_ |= 2048;
+  }
+  inline bool doIntersection() const
+  {
+    return (presolveActions_ & 4096) != 0;
+  }
+  inline void setDoIntersection(bool doIntersection)
+  {
+    if (doIntersection)
+      presolveActions_ &= ~4096;
+    else
+      presolveActions_ |= 4096;
+  }
+  inline int zeroSmall() const
+  {
+    return (presolveActions_ & (8192 | 16384)) >> 13;
+  }
+  inline void setZeroSmall(int value)
+  {
+    presolveActions_ &= ~(8192 | 16384);
+    presolveActions_ |= value << 13;
+  }
+  inline int presolveActions() const
+  {
+    return presolveActions_ & 0xffffff;
+  }
+  inline void setPresolveActions(int action)
+  {
+    presolveActions_ = (presolveActions_ & 0xff000000) | (action & 0xffffff);
+  }
+  inline void setSubstitution(int value)
+  {
+    substitution_ = value;
+  }
+  inline void statistics()
+  {
+    presolveActions_ |= 0x80000000;
+  }
+  int presolveStatus() const;
+  virtual void postsolve(bool updateStatus = true);
+  void destroyPresolve();
+private:
+  ClpSimplex *originalModel_;
+  ClpSimplex *presolvedModel_;
+  double nonLinearValue_;
+  int *originalColumn_;
+  int *originalRow_;
+  double *rowObjective_;
+  const CoinPresolveAction *paction_;
+  int ncols_;
+  int nrows_;
+  CoinBigIndex nelems_;
+  int numberPasses_;
+  int substitution_;
+  std::string saveFile_;
+  int presolveActions_;
+protected:
+  virtual const CoinPresolveAction *presolve(CoinPresolveMatrix *prob);
+  virtual void postsolve(CoinPostsolveMatrix &prob);
+  virtual ClpSimplex *gutsOfPresolvedModel(ClpSimplex *originalModel,
+    double feasibilityTolerance,
+    bool keepIntegers,
+    int numberPasses,
+    bool dropNames,
+    bool doRowObjective,
+    const char *prohibitedRows = __null,
+    const char *prohibitedColumns = __null);
+};
+
+class ClpSimplex;
+class CoinIndexedVector;
+class ClpDualRowPivot {
+public:
+  virtual int pivotRow() = 0;
+  virtual double updateWeights(CoinIndexedVector *input,
+    CoinIndexedVector *spare,
+    CoinIndexedVector *spare2,
+    CoinIndexedVector *updatedColumn)
+    = 0;
+  virtual void updatePrimalSolution(CoinIndexedVector *input,
+    double theta,
+    double &changeInObjective)
+    = 0;
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  virtual void checkAccuracy();
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const
+  {
+    return false;
+  }
+  virtual void maximumPivotsChanged() {}
+  ClpDualRowPivot();
+  ClpDualRowPivot(const ClpDualRowPivot &);
+  ClpDualRowPivot &operator=(const ClpDualRowPivot &rhs);
+  virtual ~ClpDualRowPivot();
+  virtual ClpDualRowPivot *clone(bool copyData = true) const = 0;
+  inline ClpSimplex *model()
+  {
+    return model_;
+  }
+  inline void setModel(ClpSimplex *newmodel)
+  {
+    model_ = newmodel;
+  }
+  inline int type()
+  {
+    return type_;
+  }
+protected:
+  ClpSimplex *model_;
+  int type_;
+};
+class CoinIndexedVector;
+class ClpDualRowSteepest : public ClpDualRowPivot {
+public:
+  virtual int pivotRow();
+  virtual double updateWeights(CoinIndexedVector *input,
+    CoinIndexedVector *spare,
+    CoinIndexedVector *spare2,
+    CoinIndexedVector *updatedColumn);
+  virtual void updatePrimalSolution(CoinIndexedVector *input,
+    double theta,
+    double &changeInObjective);
+  virtual void saveWeights(ClpSimplex *model, int mode);
+  void passInSavedWeights(const CoinIndexedVector *saved);
+  inline CoinIndexedVector *savedWeights()
+  {
+    return savedWeights_;
+  }
+  virtual void unrollWeights();
+  virtual void clearArrays();
+  virtual bool looksOptimal() const;
+  virtual void maximumPivotsChanged();
+  enum Persistence {
+    normal = 0x00,
+    keep = 0x01
+  };
+  ClpDualRowSteepest(int mode = 3);
+  ClpDualRowSteepest(const ClpDualRowSteepest &);
+  ClpDualRowSteepest &operator=(const ClpDualRowSteepest &rhs);
+  void fill(const ClpDualRowSteepest &rhs);
+  virtual ~ClpDualRowSteepest();
+  virtual ClpDualRowPivot *clone(bool copyData = true) const;
+  inline int mode() const
+  {
+    return mode_;
+  }
+  inline void setMode(int mode)
+  {
+    mode_ = mode;
+  }
+  inline void setPersistence(Persistence life)
+  {
+    persistence_ = life;
+  }
+  inline Persistence persistence() const
+  {
+    return persistence_;
+  }
+protected:
+  int state_;
+  int mode_;
+  Persistence persistence_;
+  double *weights_;
+  CoinIndexedVector *infeasible_;
+  CoinIndexedVector *alternateWeights_;
+  CoinIndexedVector *savedWeights_;
+  int *dubiousWeights_;
+};
+
@@ -58934 +70463,2 @@
-void LpMotionStabilizer::stabilize(int, const std::vector<Mat>&, std::pair<int,int>, Mat*)
+void LpMotionStabilizer::stabilize(
+        int size, const std::vector<Mat> &motions, std::pair<int,int> , Mat *stabilizationMotions)
@@ -58936 +70466,318 @@
-    cv::errorNoReturn( Error::StsError, "The library is built without Clp support", __func__, "/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp", 137 );
+    do { if(!!(model_ <= MM_AFFINE)) ; else cv::errorNoReturn( cv::Error::StsAssert, "model_ <= MM_AFFINE", __func__, "/home/xiaoyu/cmake-analyzer/cmake-projects/opencv/modules/videostab/src/motion_stabilizing.cpp", 145 ); } while(0);
+    int N = size;
+    const std::vector<Mat> &M = motions;
+    Mat *S = stabilizationMotions;
+    double w = frameSize_.width, h = frameSize_.height;
+    double tw = w * trimRatio_, th = h * trimRatio_;
+    int ncols = 4*N + 6*(N-1) + 6*(N-2) + 6*(N-3);
+    int nrows = 8*N + 2*6*(N-1) + 2*6*(N-2) + 2*6*(N-3);
+    rows_.clear();
+    cols_.clear();
+    elems_.clear();
+    obj_.assign(ncols, 0);
+    collb_.assign(ncols, -1e10);
+    colub_.assign(ncols, 1e10);
+    int c = 4*N;
+    for (int t = 0; t < N-1; ++t, c += 6)
+    {
+        obj_[c] = w4_*w1_;
+        collb_[c] = 0;
+        obj_[c+1] = w4_*w1_;
+        collb_[c+1] = 0;
+        obj_[c+2] = w1_;
+        collb_[c+2] = 0;
+        obj_[c+3] = w4_*w1_;
+        collb_[c+3] = 0;
+        obj_[c+4] = w4_*w1_;
+        collb_[c+4] = 0;
+        obj_[c+5] = w1_;
+        collb_[c+5] = 0;
+    }
+    for (int t = 0; t < N-2; ++t, c += 6)
+    {
+        obj_[c] = w4_*w2_;
+        collb_[c] = 0;
+        obj_[c+1] = w4_*w2_;
+        collb_[c+1] = 0;
+        obj_[c+2] = w2_;
+        collb_[c+2] = 0;
+        obj_[c+3] = w4_*w2_;
+        collb_[c+3] = 0;
+        obj_[c+4] = w4_*w2_;
+        collb_[c+4] = 0;
+        obj_[c+5] = w2_;
+        collb_[c+5] = 0;
+    }
+    for (int t = 0; t < N-3; ++t, c += 6)
+    {
+        obj_[c] = w4_*w3_;
+        collb_[c] = 0;
+        obj_[c+1] = w4_*w3_;
+        collb_[c+1] = 0;
+        obj_[c+2] = w3_;
+        collb_[c+2] = 0;
+        obj_[c+3] = w4_*w3_;
+        collb_[c+3] = 0;
+        obj_[c+4] = w4_*w3_;
+        collb_[c+4] = 0;
+        obj_[c+5] = w3_;
+        collb_[c+5] = 0;
+    }
+    elems_.clear();
+    rowlb_.assign(nrows, -1e10);
+    rowub_.assign(nrows, 1e10);
+    int r = 0;
+    const Point2d pt[] = {Point2d(0,0), Point2d(w,0), Point2d(w,h), Point2d(0,h)};
+    for (int t = 0; t < N; ++t)
+    {
+        c = 4*t;
+        for (int i = 0; i < 4; ++i, r += 2)
+        {
+            set(r, c, pt[i].x); set(r, c+1, pt[i].y); set(r, c+2, 1);
+            set(r+1, c, pt[i].y); set(r+1, c+1, -pt[i].x); set(r+1, c+3, 1);
+            rowlb_[r] = pt[i].x-tw;
+            rowub_[r] = pt[i].x+tw;
+            rowlb_[r+1] = pt[i].y-th;
+            rowub_[r+1] = pt[i].y+th;
+        }
+    }
+    for (int t = 0; t < N-1; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M);
+        c = 4*t;
+        set(r, c, -1);
+        set(r+1, c+1, -1);
+        set(r+2, c+2, -1);
+        set(r+3, c+1, 1);
+        set(r+4, c, -1);
+        set(r+5, c+3, -1);
+        c = 4*(t+1);
+        set(r, c, M0(0,0)); set(r, c+1, M0(1,0));
+        set(r+1, c, M0(0,1)); set(r+1, c+1, M0(1,1));
+        set(r+2, c, M0(0,2)); set(r+2, c+1, M0(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M0(1,0)); set(r+3, c+1, -M0(0,0));
+        set(r+4, c, M0(1,1)); set(r+4, c+1, -M0(0,1));
+        set(r+5, c, M0(1,2)); set(r+5, c+1, -M0(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, -1);
+        rowub_[r] = 0;
+        rowub_[r+1] = 0;
+        rowub_[r+2] = 0;
+        rowub_[r+3] = 0;
+        rowub_[r+4] = 0;
+        rowub_[r+5] = 0;
+    }
+    for (int t = 0; t < N-1; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M);
+        c = 4*t;
+        set(r, c, -1);
+        set(r+1, c+1, -1);
+        set(r+2, c+2, -1);
+        set(r+3, c+1, 1);
+        set(r+4, c, -1);
+        set(r+5, c+3, -1);
+        c = 4*(t+1);
+        set(r, c, M0(0,0)); set(r, c+1, M0(1,0));
+        set(r+1, c, M0(0,1)); set(r+1, c+1, M0(1,1));
+        set(r+2, c, M0(0,2)); set(r+2, c+1, M0(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M0(1,0)); set(r+3, c+1, -M0(0,0));
+        set(r+4, c, M0(1,1)); set(r+4, c+1, -M0(0,1));
+        set(r+5, c, M0(1,2)); set(r+5, c+1, -M0(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, 1);
+        rowlb_[r] = 0;
+        rowlb_[r+1] = 0;
+        rowlb_[r+2] = 0;
+        rowlb_[r+3] = 0;
+        rowlb_[r+4] = 0;
+        rowlb_[r+5] = 0;
+    }
+    for (int t = 0; t < N-2; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M), M1 = at(t+1,M);
+        c = 4*t;
+        set(r, c, 1);
+        set(r+1, c+1, 1);
+        set(r+2, c+2, 1);
+        set(r+3, c+1, -1);
+        set(r+4, c, 1);
+        set(r+5, c+3, 1);
+        c = 4*(t+1);
+        set(r, c, -M0(0,0)-1); set(r, c+1, -M0(1,0));
+        set(r+1, c, -M0(0,1)); set(r+1, c+1, -M0(1,1)-1);
+        set(r+2, c, -M0(0,2)); set(r+2, c+1, -M0(1,2)); set(r+2, c+2, -2);
+        set(r+3, c, -M0(1,0)); set(r+3, c+1, M0(0,0)+1);
+        set(r+4, c, -M0(1,1)-1); set(r+4, c+1, M0(0,1));
+        set(r+5, c, -M0(1,2)); set(r+5, c+1, M0(0,2)); set(r+5, c+3, -2);
+        c = 4*(t+2);
+        set(r, c, M1(0,0)); set(r, c+1, M1(1,0));
+        set(r+1, c, M1(0,1)); set(r+1, c+1, M1(1,1));
+        set(r+2, c, M1(0,2)); set(r+2, c+1, M1(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M1(1,0)); set(r+3, c+1, -M1(0,0));
+        set(r+4, c, M1(1,1)); set(r+4, c+1, -M1(0,1));
+        set(r+5, c, M1(1,2)); set(r+5, c+1, -M1(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*(N-1) + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, -1);
+        rowub_[r] = 0;
+        rowub_[r+1] = 0;
+        rowub_[r+2] = 0;
+        rowub_[r+3] = 0;
+        rowub_[r+4] = 0;
+        rowub_[r+5] = 0;
+    }
+    for (int t = 0; t < N-2; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M), M1 = at(t+1,M);
+        c = 4*t;
+        set(r, c, 1);
+        set(r+1, c+1, 1);
+        set(r+2, c+2, 1);
+        set(r+3, c+1, -1);
+        set(r+4, c, 1);
+        set(r+5, c+3, 1);
+        c = 4*(t+1);
+        set(r, c, -M0(0,0)-1); set(r, c+1, -M0(1,0));
+        set(r+1, c, -M0(0,1)); set(r+1, c+1, -M0(1,1)-1);
+        set(r+2, c, -M0(0,2)); set(r+2, c+1, -M0(1,2)); set(r+2, c+2, -2);
+        set(r+3, c, -M0(1,0)); set(r+3, c+1, M0(0,0)+1);
+        set(r+4, c, -M0(1,1)-1); set(r+4, c+1, M0(0,1));
+        set(r+5, c, -M0(1,2)); set(r+5, c+1, M0(0,2)); set(r+5, c+3, -2);
+        c = 4*(t+2);
+        set(r, c, M1(0,0)); set(r, c+1, M1(1,0));
+        set(r+1, c, M1(0,1)); set(r+1, c+1, M1(1,1));
+        set(r+2, c, M1(0,2)); set(r+2, c+1, M1(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M1(1,0)); set(r+3, c+1, -M1(0,0));
+        set(r+4, c, M1(1,1)); set(r+4, c+1, -M1(0,1));
+        set(r+5, c, M1(1,2)); set(r+5, c+1, -M1(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*(N-1) + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, 1);
+        rowlb_[r] = 0;
+        rowlb_[r+1] = 0;
+        rowlb_[r+2] = 0;
+        rowlb_[r+3] = 0;
+        rowlb_[r+4] = 0;
+        rowlb_[r+5] = 0;
+    }
+    for (int t = 0; t < N-3; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M), M1 = at(t+1,M), M2 = at(t+2,M);
+        c = 4*t;
+        set(r, c, -1);
+        set(r+1, c+1, -1);
+        set(r+2, c+2, -1);
+        set(r+3, c+1, 1);
+        set(r+4, c, -1);
+        set(r+5, c+3, -1);
+        c = 4*(t+1);
+        set(r, c, M0(0,0)+2); set(r, c+1, M0(1,0));
+        set(r+1, c, M0(0,1)); set(r+1, c+1, M0(1,1)+2);
+        set(r+2, c, M0(0,2)); set(r+2, c+1, M0(1,2)); set(r+2, c+2, 3);
+        set(r+3, c, M0(1,0)); set(r+3, c+1, -M0(0,0)-2);
+        set(r+4, c, M0(1,1)+2); set(r+4, c+1, -M0(0,1));
+        set(r+5, c, M0(1,2)); set(r+5, c+1, -M0(0,2)); set(r+5, c+3, 3);
+        c = 4*(t+2);
+        set(r, c, -2*M1(0,0)-1); set(r, c+1, -2*M1(1,0));
+        set(r+1, c, -2*M1(0,1)); set(r+1, c+1, -2*M1(1,1)-1);
+        set(r+2, c, -2*M1(0,2)); set(r+2, c+1, -2*M1(1,2)); set(r+2, c+2, -3);
+        set(r+3, c, -2*M1(1,0)); set(r+3, c+1, 2*M1(0,0)+1);
+        set(r+4, c, -2*M1(1,1)-1); set(r+4, c+1, 2*M1(0,1));
+        set(r+5, c, -2*M1(1,2)); set(r+5, c+1, 2*M1(0,2)); set(r+5, c+3, -3);
+        c = 4*(t+3);
+        set(r, c, M2(0,0)); set(r, c+1, M2(1,0));
+        set(r+1, c, M2(0,1)); set(r+1, c+1, M2(1,1));
+        set(r+2, c, M2(0,2)); set(r+2, c+1, M2(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M2(1,0)); set(r+3, c+1, -M2(0,0));
+        set(r+4, c, M2(1,1)); set(r+4, c+1, -M2(0,1));
+        set(r+5, c, M2(1,2)); set(r+5, c+1, -M2(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*(N-1) + 6*(N-2) + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, -1);
+        rowub_[r] = 0;
+        rowub_[r+1] = 0;
+        rowub_[r+2] = 0;
+        rowub_[r+3] = 0;
+        rowub_[r+4] = 0;
+        rowub_[r+5] = 0;
+    }
+    for (int t = 0; t < N-3; ++t, r += 6)
+    {
+        Mat_<float> M0 = at(t,M), M1 = at(t+1,M), M2 = at(t+2,M);
+        c = 4*t;
+        set(r, c, -1);
+        set(r+1, c+1, -1);
+        set(r+2, c+2, -1);
+        set(r+3, c+1, 1);
+        set(r+4, c, -1);
+        set(r+5, c+3, -1);
+        c = 4*(t+1);
+        set(r, c, M0(0,0)+2); set(r, c+1, M0(1,0));
+        set(r+1, c, M0(0,1)); set(r+1, c+1, M0(1,1)+2);
+        set(r+2, c, M0(0,2)); set(r+2, c+1, M0(1,2)); set(r+2, c+2, 3);
+        set(r+3, c, M0(1,0)); set(r+3, c+1, -M0(0,0)-2);
+        set(r+4, c, M0(1,1)+2); set(r+4, c+1, -M0(0,1));
+        set(r+5, c, M0(1,2)); set(r+5, c+1, -M0(0,2)); set(r+5, c+3, 3);
+        c = 4*(t+2);
+        set(r, c, -2*M1(0,0)-1); set(r, c+1, -2*M1(1,0));
+        set(r+1, c, -2*M1(0,1)); set(r+1, c+1, -2*M1(1,1)-1);
+        set(r+2, c, -2*M1(0,2)); set(r+2, c+1, -2*M1(1,2)); set(r+2, c+2, -3);
+        set(r+3, c, -2*M1(1,0)); set(r+3, c+1, 2*M1(0,0)+1);
+        set(r+4, c, -2*M1(1,1)-1); set(r+4, c+1, 2*M1(0,1));
+        set(r+5, c, -2*M1(1,2)); set(r+5, c+1, 2*M1(0,2)); set(r+5, c+3, -3);
+        c = 4*(t+3);
+        set(r, c, M2(0,0)); set(r, c+1, M2(1,0));
+        set(r+1, c, M2(0,1)); set(r+1, c+1, M2(1,1));
+        set(r+2, c, M2(0,2)); set(r+2, c+1, M2(1,2)); set(r+2, c+2, 1);
+        set(r+3, c, M2(1,0)); set(r+3, c+1, -M2(0,0));
+        set(r+4, c, M2(1,1)); set(r+4, c+1, -M2(0,1));
+        set(r+5, c, M2(1,2)); set(r+5, c+1, -M2(0,2)); set(r+5, c+3, 1);
+        c = 4*N + 6*(N-1) + 6*(N-2) + 6*t;
+        for (int i = 0; i < 6; ++i)
+            set(r+i, c+i, 1);
+        rowlb_[r] = 0;
+        rowlb_[r+1] = 0;
+        rowlb_[r+2] = 0;
+        rowlb_[r+3] = 0;
+        rowlb_[r+4] = 0;
+        rowlb_[r+5] = 0;
+    }
+    CoinPackedMatrix A(true, &rows_[0], &cols_[0], &elems_[0], elems_.size());
+    A.setDimensions(nrows, ncols);
+    ClpSimplex model(false);
+    model.loadProblem(A, &collb_[0], &colub_[0], &obj_[0], &rowlb_[0], &rowub_[0]);
+    ClpDualRowSteepest dualSteep(1);
+    model.setDualRowPivotAlgorithm(dualSteep);
+    ClpPrimalColumnSteepest primalSteep(1);
+    model.setPrimalColumnPivotAlgorithm(primalSteep);
+    model.scaling(1);
+    ClpPresolve presolveInfo;
+    Ptr<ClpSimplex> presolvedModel(presolveInfo.presolvedModel(model));
+    if (presolvedModel)
+    {
+        presolvedModel->dual();
+        presolveInfo.postsolve(true);
+        model.checkSolution();
+        model.primal(1);
+    }
+    else
+    {
+        model.dual();
+        model.checkSolution();
+        model.primal(1);
+    }
+    const double *sol = model.getColSolution();
+    c = 0;
+    for (int t = 0; t < N; ++t, c += 4)
+    {
+        Mat_<float> S0 = Mat::eye(3, 3, 5);
+        S0(1,1) = S0(0,0) = sol[c];
+        S0(0,1) = sol[c+1];
+        S0(1,0) = -sol[c+1];
+        S0(0,2) = sol[c+2];
+        S0(1,2) = sol[c+3];
+        S[t] = S0;
+    }
